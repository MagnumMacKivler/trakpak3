@name johnhenry/John Henry Trakpak3 Track Generator
@inputs Active InputVons:array VonGo FileBuffer:entity
@outputs NextFrame EntID SmoothPolyID FileName:string FileText:string
#Gauge Settings
@persist GaugeName:string RidiculousTies InterpolateTies MakeBallast Scale AnimateSwitches TextureRailEnds
@persist OriginHeight BallastHeight RailBottomHeight RailTopHeight TieBottomHeight TieTopHeight BankHeight CheckLength SwitchThrow TieSeparation TieWidth TieThickness TiePlateWidth TiePlateCenter
@persist [BallastSkins BallastTrackbedSkins BallastTiesSkins TiesSkins TieNoPlateSkins TiePlateSkins]:array
@persist [Mat_Ballast Mat_Trackbed_NoTies Mat_Trackbed_Ties Mat_Ties Mat_RailSide Mat_RailTop Mat_RailTop_Rusty Mat_Tie Mat_Tie_Plates]:string
@persist BallastU BallastV BallastScale RailSideU RailSideV RailSideScale RailTopU RailTopV RailTopScale TieU TieV TieScale
@persist [TrackSep_Ang0 TrackSep_Ang1 TrackSep_Ang2 TrackSep_Ang4]:vector2 [TrackFace_Ang0 TrackFace_Ang1 TrackFace_Ang2 TrackFace_Ang4 Textures]:table
#Compile Data
@persist SegID InternalBrushID StartingBrushID NearPoints:array FarPoints:array SegmentTypes:array SegType TexCodes:array TexNear TexFar [JA JB JC JD JE JF JG JH JI JK JL JM JN]:array BrushWriteStep Tex:table
@persist EntID [MasterString EntString]:string [BrushStrings Entities EntBrushMins EntBrushMaxs EntClasses EntVisGroups EntOrigins EntTargets]:array EntSkins:table BID MinBID MaxBID CompileStep NumBrushes
@persist SwitchCompileStep SWP_MN:array SWP_DV:array SwitchXover WholeSwitchXover
@persist O:entity E:entity SoundIndex CompileStartTime

#SMD
@persist PolyGroupKeys:array NumPolyGroups ActivePolyGroup:table PolyGroupID SmoothPolyID SmoothTable:table SmoothSpeed SMD_Text:string SMD_Tag:string

#Von Direct
@persist Vons:array VonID AutoVon FileExpecting
#Track Pieces:
@persist TrackNames:array TrackTypes:array

#Working Data

@persist SelectedTrack PieceID FullyDefined:array
#Straights
@persist [StraightStartPos StraightDir StraightLength StraightHeight StraightSegments]:array 
@persist [StraightStartPosDefined StraightDirDefined StraightLengthDefined StraightHeightDefined StraightSegmentsDefined]:array
#Arc Curves
@persist [ArcStartPos ArcStartDir ArcEndPos ArcEndDir ArcRadius ArcHeight ArcSegments]:array
@persist [ArcStartPosDefined ArcStartDirDefined ArcEndPosDefined ArcEndDirDefined ArcRadiusDefined ArcHeightDefined ArcSegmentsDefined]:array
#Banked Arc Curves
@persist [BankedArcStartPos BankedArcStartDir BankedArcEndPos BankedArcEndDir BankedArcRadius BankedArcHeight BankedArcSegments BankedArcBlendIn BankedArcBlendOut BankedArcGoesLeft]:array
@persist [BankedArcStartPosDefined BankedArcStartDirDefined BankedArcEndPosDefined BankedArcEndDirDefined BankedArcRadiusDefined BankedArcHeightDefined BankedArcSegmentsDefined BankedArcBlendInDefined BankedArcBlendOutDefined]:array
#Bezier Curves
@persist [BezStartPos BezStartDir BezEndPos BezEndDir BezStartCPLength BezEndCPLength BezMinRadius BezHeight BezSegments BezXovers]:array
@persist [BezStartPosDefined BezStartDirDefined BezEndPosDefined BezEndDirDefined BezStartCPLengthDefined BezEndCPLengthDefined BezHeightDefined BezSegmentsDefined]:array
#Switches
@persist [SwitchMainPiece SwitchDivPiece SwitchSplit SwitchMainLeft]:array
@persist [SwitchMainPieceDefined SwitchDivPieceDefined SwitchSplitDefined]:array

#Intermediate Data

@persist Plots:table Plotted:array Traces:table SegTypeLists:table HasLead:array
@persist [JointsLists PhysJointsLists]:table
@persist DrawAnchor:entity DrawSeg [DA DB DC DD DE DF DG DH DI DJ DK DL DM DN]:array RopeIndex
@persist [MainSegmentOverlap DivSegmentOverlap Jlap_MN Jlap_DV Jmap_MN Jmap_DV JLC_MN JLC_DV JLD_MN JLD_DV]:array NumSegsMN NumSegsDV NumOverlapsMN NumOverlapsDV OLID
@persist [AutoPointMN AutoPointDV]:vector
@persist MainLeft SplitMode:string [Inner_MN Outer_MN Inner_DV Outer_DV Inner_Split Outer_Split FinalTri_MN FinalTri_DV]:array SPLID
@persist CardinalPoint:vector2 CardinalDir:vector2 CardinalAng:angle StockToChopMN StockToChopDV ClosureIndexMN ClosureIndexDV StockIndexMN StockIndexDV Adjusted_MN Adjusted_DV Need1MN Need1DV Rail1MN:array Rail2MN:array Rail3MN:array Rail1DV:array Rail2DV:array Rail3DV:array
@persist [Patch1MN Patch2MN Patch1DV Patch2DV]:array
@persist TopPointsMN:array TopPointsDV:array RailSegID RIMN RIDV I_Top:vector2 I_Bottom:vector2 FrogPos:vector
@persist ClosurePointGroups:table ClosurePointGroupsMN:table ClosurePointGroupsDV:table ClosureThrowsMN:array ClosureThrowsDV:array ThrowAxisMN:vector2 ThrowAxisDV:vector2 BladeCenter:vector
@persist [ClosurePointInnerMN ClosurePointOuterMN ClosureCornerMN ClosureCornerDV ClosureDirMN ClosurePointInnerDV ClosurePointOuterDV ClosureDirDV]:vector2 RailWidth
@persist [SWPointsFarMN SWPointsNearMN SWPointsFarDV SWPointsNearDV]:vector2
@persist [ContactPointInnerDV ContactPointOuterDV ContactPointInnerMN ContactPointOuterMN]:vector
@persist CheckPointGroups:table Do:array
@persist [Tmap_LMN Tmap_RMN Tmap_LDV Tmap_RDV TP_LMN TP_RMN TP_LDV TP_RDV]:array TC CardLine:array PerpDir:vector2 Inset:vector2 LastSingleTie LastFusedTie
@persist [StP StEs StFs StA StSegTypes StDistances]:array StStartSeg StEndSeg StMaxZ SingleTieZ StStep
@persist [SingleTieCenters SingleTieAngles SingleTieHeights]:array STC TieID LeftMaxSeg RightMaxSeg LeftMinPos RightMinPos [SegOfTieMN SegOfTieDV]:array
@persist [PlatePointGroups BridgePointGroups]:table [PlateTexCenters BridgeTexCenters SideStates]:array PlateID BridgeID MaxPlates MaxBridges MN_MinZ DV_MinZ MN_MinZ_Seg DV_MinZ_Seg
@persist VisGroups:array
@persist TexRailEnds:table

#Visualization

@persist TightestPoint TraceC [Red Orange Yellow Green Cyan Blue Magenta Black White Gray]:vector
@persist Driver:entity WQ AQ SQ DQ UpQ DnQ M1Q M2Q SpaceQ ActiveQ RepeatDelay RepeatPrd
@persist DebugHoloIndex

#Options

@persist SMDQC AutoVis AutoDraw AutoName Script:array ScriptLine RunningScript SuppressOutput DrawCheap AutoVMFName VMFName:string ForceSegmentType BufferWrite
@persist AutoCompile AutoCompileID FinalCompileID DoubleRailPrecision

#Version Info

@persist Version:string

@trigger 
@model models/workshop/weapons/c_models/c_sledgehammer/c_sledgehammer.mdl

if(first()){
    #Version Info - Don't Change This!
    Version = "1.6"
    
    #What track gauge are you developing for?
    #include "johnhenry/gauges/standard_bridge"
    
    SMDQC = 1 #Generate SMD and QC files instead of VMF files... Recommended.
    
    DoubleRailPrecision = 0 #If 1, rail vertices will snap to half-unit precision. This allows smoother curves. SMDQC must be 1 for this to work.
    #If set, all models will have '_drp' appended to the file names. This setting is only recommended for arc/banked/bezier curves.
	#Not tested extensively with switches! Use with caution.
    
    #End of Simple Launch Options
    
    if(SMDQC){
        #include "johnhenry/library/smd"
    }else{
        #include "johnhenry/library/vmf"
    }
    #include "johnhenry/library/linalg"
    #include "johnhenry/library/consolescreen"
    
    AutoVis = 0
    AutoDraw = 0
    AutoName = 1
    AutoVMFName = 1
    SuppressOutput = 0
    DrawCheap = 0
    
    ForceSegmentType = 0 #Sets the minimum physics level, limited applicability to switches:
    #0 - Allows trapezoidal or convexed ballast and block rails. This is the default mode.
    #1 - Allows block ballast and block rails, like flat curves (VMF).
    #2 - Allows triangular ballast and block rails, like banked curves (VMF).
    #3 - Forces all segments to have triangular ballast and triangular rails, like a curved ramp (VMF). Very expensive, don't use unless you know what you're doing.
    
    VMFName = "pootis"
    
    #MasterString = initBlocks() #Must define later due to visgroups
    O = owner()
    E = entity()
    runOnChat(1)
    E:isWeldedTo():propDelete()
    
    Script = array(
        ".newpiece straight 1",
        ".define startpos 0 0",
        ".define dir 0",
        ".define length 512",
        ".define height 0",
        ".define segments 1",
        ".plot"
        #".draw",
        
        #".newpiece arc 1",
        #".define startpos 0 0",
        #".define startdir 0",
        #".define endpos 192 768",
        #".define enddir -2",
        #".define radius 1536",
        #".define segments 6",
        #".define height 0",
        #".plot",
        #".draw",
        
        #".newpiece bezier 1",
        #".define startpos 0 0",
        #".define startdir 0",
        #".define endpos 128 1536",
        #".define enddir 0",
        #".define height 0",
        #".define cp 768",
        #".define segments 16",
        #".plot"
        #".draw"
        
        #".newpiece switch pootis",
        #".define mainpiece 1",
        #".define divpiece 2",
        #".define split main",
        #".plot"
    )
    
    ScriptLine = 1
    
    BufferWrite = ->FileBuffer
    
    #JHUI Init
    CS:initPage(0)
    EGP:egpInitPage(0)
    RepeatDelay = 500
    RepeatPrd = 100
    if(Active){
        ActiveQ = 1
        Driver = Pod:driver()
        runOnKeys(Driver,1)
    }
    TrackGauge = 2*TrackFace_Ang0["rail_inner",vector2]:x()
    BallastBlockWidth = 2*TrackFace_Ang0["ballast_corner",vector2]:x()
    EGP_DrawScale = 1/Scale
    
    Red = vec(255,0,0)
    Orange = vec(255,127,0)
    Yellow = vec(255,255,0)
    Green = vec(0,255,0)
    Cyan = vec(0,255,255)
    Blue = vec(0,0,255)
    Magenta = vec(255,0,255)
    Black = vec()
    White = vec(255)
    Gray = vec(127)
    
    
    STC = 0
    
    #Ger-VON-imo!
    if(->VonGo){
        NextFrame = 1
    }
    
    #Signals for File Buffer
    signalSetGroup("john_henry")
    runOnSignal("ack_file",1,1)
    
    #SMD Texture Processing
    if(SMDQC){
        BallastSkins = smd_texture(BallastSkins)
        BallastTrackbedSkins = smd_texture(BallastTrackbedSkins)
        BallastTiesSkins = smd_texture(BallastTiesSkins)
        TiesSkins = smd_texture(TiesSkins)
        TieNoPlateSkins = smd_texture(TieNoPlateSkins)
        TiePlateSkins = smd_texture(TiePlateSkins)
        
        Mat_RailSide = smd_texture(Mat_RailSide)
        Mat_RailTop = smd_texture(Mat_RailTop)
        Mat_RailTop_Rusty = smd_texture(Mat_RailTop_Rusty)
    }
    
    Mat_Ballast = BallastSkins[1,string]
    Mat_Trackbed_NoTies = BallastTrackbedSkins[1,string]
    Mat_Trackbed_Ties = BallastTiesSkins[1,string]
    Mat_Ties = TiesSkins[1,string]
    Mat_Tie = TieNoPlateSkins[1,string]
    Mat_Tie_Plates = TiePlateSkins[1,string]
    
    #Track Pieces by TrackID
    #Each Piece has:
        #2 or 3 Handles which define end points, by HandleID
        #1 or 2 Paths which define the primary path of train motion, used for texture alignment and shit, by PathID
        #Any number of Brushes, by BrushID
    #Each Handle has:
        #A Position as a vector
        #A Direction as a vector
    #Each Path has:
        #A list of points which define, in rough terms, each segment joint of a piece of track. Direction and Texture alignment info is calculated off of it.
    #Each Brush has:
        #A list of sides, by SideID
    #Each Side has:
        #A list of Three counterclockwise (Right Hand Rule) Vertices. RHR Axis formed by points is normal to polygon surface.
        #Texture String
        #U and V Texture Axes
        #U and V Texture Offsets
        #Overall Scale
    
    #Operational Pipeline
    
    #1 - Define a basic track piece
        #Straight
            #Start Direction
            #"Forward" Length
            #Height
        #Curve (Arc)
            #Start Direction
            #End Direction
            #Radius
            #Resolution
            #Handle Points (Used to add Adapter Segments)
            #Height
            #Banking
        #Bezier
            #Start Direction
            #End Direction
            #Resolution
            #Handle Points
            #CP Distance
            #Height
        #Name It
            
    #2 - Process for Switches
        #Sew the Ballast Brushes together
        #Sew the Rails together
        #Generate Ties
        #Merge the two into one track piece
        #Auto-Generate Divergent Path
        
    #3 - "Paint" the track piece
        #Expand to 3D
        #Compile Brush Info for each brush
            #Compile Raw Side Data
            #Assign Textures
            #Map Textures
        #Create Phys Meshes
    
    #4 - Compile
    #5 - Save
    
    #Abbreviations
    #fw - foward
    #lt - left
    #rt - right
    #up - up
    #dn - down
    #r - radius
    #minr - minimum radius
    #mn - main
    #dv - diverging
    
    #The Folder Structure
    
    #trakpak3_* - substitute asterisk for Gauge name.
        #str - Straights
            #flat - 0% Grade
                #ang0fw_1024x0000x000
                #ang2lt_2048x1024x000
                #ang1rt_1024x0256x000
            #1g - <2% Grade
            #2g - 2-3% Grade
            #3g - 3-4% Grade
            #(etc)
        #arc - Arc Curves
            #flat
                #ang0fw_8rt_r2048_2048x2048x000
                #ang0fw_2rt_r2048_1536x0384x000
            #(etc)
        #sup - Superelevated (Banked) Arc curves
            #flat
                #ang0fw_8rt_r2048_2048x2048x000_ff
                #ang0fw_2rt_r2048_1536x0384x000_fb
            #(etc)
        #bez - Bezier Curves
            #flat
                #ang0fw_0fw_minr2048_2048x0192x000
            #(etc)
        #swi - Switches
            #str_arc
                #ang0fw_0fw_1rt_r2048_1024x0000_1280x0096_mn (_dv)
            #str_bez
                #ang0fw_0fw_0fw_minr3072_2048x0000_2048x0192_mn (_dv)
            #arc_arc
                #ang0fw_ang1lt_ang1rt_r1536_r1536_1024x0096_1024x0096_mn (_dv)
            #arc_bez
                #(etc)
            #bez_bez
                #(etc)
    #You will need:
#A function that makes a ballast brush given N arbitrary points and a texture alignment
#A function that makes ballast edges given 2 arbitrary points and a texture alignment
	
#The Algorithm for making switches:
#1 - Compare the minimum point-to-point distance (not including leads) and find which piece has bigger segments
#2 - Identify all segments which intersect and mark them somehow (start at the joint and move out)
#3 - For all vertices in the smaller piece, split the larger brush horizontally (relative to dir of larger piece). Record the new verts, and specify which is the "inner" one
#4 - Find the midpoint of each vertex on the intersecting brushes (except for the last one) and snap them together
#5 - For the last pair (which should not intersect), split the segment to triangulate so a new vertex appears at the intersection point
#6 - Use the functions to make brushes given the groups of points, using the texture alignments of the base curves
#7 - Compile all the non-marked brushes normally, then compile the new brushes, add them together

#EGP Pages

#1: Main Menu
    #New Piece
    #Select Piece
    #Edit Piece
    #Compile
#2: New Piece Menu
    #Type
    #Name
#3: Select Piece Menu
    #List of Pieces (1,2,3)
#4: Edit Piece Menu
    #All the Info you need for the piece. Yup.
    
    function void filePush(Name:string, Text:string){
        FileName = Name
        FileText = Text
        FileExpecting = 1
        signalSendDirect("push_file",FileBuffer)
        timer("FileTimeout",1000)
    }
    
    DebugHoloIndex = 1
    function void debugHolo(Position:vector2,Color:vector,StandOut){
        holoCreate(DebugHoloIndex,E:toWorld(vec(Position)),StandOut ? vec(0.25,0.25,1) : vec(0.5),ang(),Color,"cube")
        holoParent(DebugHoloIndex,E)
        DebugHoloIndex++
        return void
    }
    
    function void debugHoloArray(Points:array,Start:vector,End:vector){
        local Divs = max(Points:count()-1,1)
        for(N=1,Points:count()){
            debugHolo(Points[N,vector2],Start + (End-Start)*(N-1)/Divs,N>2)
        }
    }
    
    function array array:around(){
        foreach(K,V:vector2=This){
            V = round(V)
        }
        return This
    }
    
    function vector2 swap(V:vector2){
        return vec2(V:y(),V:x())
    }
    function vector2 flip(V:vector2){
        return vec2(-V:x(),V:y())
    }
    function vector2 flipy(V:vector2){
        return vec2(V:x(),-V:y())
    }
    
    
    function number dir2ang(Dir:vector2){
        local D = vec(Dir,0)
        local Angle = -bearing(vec(),ang(),D)
        return Angle
    }
    function vector heightColor(Z,TotalHeight){
        local HeightMax = abs(TotalHeight)
        if(HeightMax==0){
            return vec(0,255,0)
        }else{
            local R = clamp(255*(1+(Z - (HeightMax/2))/(HeightMax/2)),0,255)
            local G = clamp(255*(1+((HeightMax/2)-abs(Z))/(HeightMax/2)),0,255)
            local B = clamp(255*(1+(-Z - (HeightMax/2))/(HeightMax/2)),0,255)
            
            return vec(R,G,B)
        }
    }
    function vector2 getTangent(Prev:vector,Current:vector,Next:vector){
        local DN = (Next-Current):normalized()
        local DP = (Current-Prev):normalized()
        
        return vec2(DN+DP):normalized()
    }
    function table getJointsByDN(Center:vector,Direction){
        #print("DN!")
        local Out = table()
        
        local Rot = 0
        
        #-4 -2 -1 0 1 2 4
        if(inrange(Direction,-4,4)){
            Rot = 0
        }elseif(inrange(Direction,4,12)){
            Rot = 90
            Direction += -8
        }elseif(inrange(Direction,-12,-4)){
            Rot = -90
            Direction += 8
        }elseif(Direction>12){
            Rot = 180
            Direction += -16
        }elseif(Direction<-12){
            Rot = 180
            Direction += 16
        }
        local Rail_Inner = vec2()
        local Rail_Outer = vec2()
        local Ballast_Corner = vec2()
        local Ballast_Edge = vec2()
        
        switch(abs(Direction)){
            case 0,
                Rail_Inner = TrackFace_Ang0["rail_inner",vector2]:rotate(Rot)
                Rail_Outer = TrackFace_Ang0["rail_outer",vector2]:rotate(Rot)
                Ballast_Corner = TrackFace_Ang0["ballast_corner",vector2]:rotate(Rot)
                Ballast_Edge = TrackFace_Ang0["ballast_edge",vector2]:rotate(Rot)
                break
            case 1,
                Rail_Inner = TrackFace_Ang1["rail_inner",vector2]:rotate(Rot)
                Rail_Outer = TrackFace_Ang1["rail_outer",vector2]:rotate(Rot)
                Ballast_Corner = TrackFace_Ang1["ballast_corner",vector2]:rotate(Rot)
                Ballast_Edge = TrackFace_Ang1["ballast_edge",vector2]:rotate(Rot)
                break
            case 2,
                Rail_Inner = TrackFace_Ang2["rail_inner",vector2]:rotate(Rot)
                Rail_Outer = TrackFace_Ang2["rail_outer",vector2]:rotate(Rot)
                Ballast_Corner = TrackFace_Ang2["ballast_corner",vector2]:rotate(Rot)
                Ballast_Edge = TrackFace_Ang2["ballast_edge",vector2]:rotate(Rot)
                break
            case 4,
                Rail_Inner = TrackFace_Ang4["rail_inner",vector2]:rotate(Rot)
                Rail_Outer = TrackFace_Ang4["rail_outer",vector2]:rotate(Rot)
                Ballast_Corner = TrackFace_Ang4["ballast_corner",vector2]:rotate(Rot)
                Ballast_Edge = TrackFace_Ang4["ballast_edge",vector2]:rotate(Rot)
                break
            default,
                break
        }
        
        if(sign(Direction)<0){
            Rail_Inner = flipy(Rail_Inner)
            Rail_Outer = flipy(Rail_Outer)
            Ballast_Corner = flipy(Ballast_Corner)
            Ballast_Edge = flipy(Ballast_Edge)
        }
        
        #Implement DoubleRailPrecision
        local PScale = 1
        if(SMDQC & DoubleRailPrecision){PScale = 2}
        
        #          K M      N L
        #          G I      J H
        #       E----------------F
        #   /   |                |   \
        # A-----C----------------D-----B
        
        Out["A",vector] = round(Center + vec(-Ballast_Edge,-OriginHeight))
        Out["B",vector] = round(Center + vec(Ballast_Edge,-OriginHeight))
        Out["C",vector] = round(Center + vec(-Ballast_Corner,-OriginHeight))
        Out["D",vector] = round(Center + vec(Ballast_Corner,-OriginHeight))
        Out["E",vector] = round(Center + vec(-Ballast_Corner,-OriginHeight+BallastHeight))
        Out["F",vector] = round(Center + vec(Ballast_Corner,-OriginHeight+BallastHeight))
        Out["G",vector] = round((Center + vec(-Rail_Outer,-OriginHeight+RailBottomHeight))*PScale)/PScale
        Out["H",vector] = round((Center + vec(Rail_Outer,-OriginHeight+RailBottomHeight))*PScale)/PScale
        Out["I",vector] = round((Center + vec(-Rail_Inner,-OriginHeight+RailBottomHeight))*PScale)/PScale
        Out["J",vector] = round((Center + vec(Rail_Inner,-OriginHeight+RailBottomHeight))*PScale)/PScale
        Out["K",vector] = round((Center + vec(-Rail_Outer,-OriginHeight+RailTopHeight))*PScale)/PScale
        Out["L",vector] = round((Center + vec(Rail_Outer,-OriginHeight+RailTopHeight))*PScale)/PScale
        Out["M",vector] = round((Center + vec(-Rail_Inner,-OriginHeight+RailTopHeight))*PScale)/PScale
        Out["N",vector] = round((Center + vec(Rail_Inner,-OriginHeight+RailTopHeight))*PScale)/PScale
        
        return Out
    }
    function table getJointsByDV(Center:vector,Direction:vector2){
        local Out = table()
        
        local Ang = dir2ang(Direction)-90
        
        local Rail_Inner = (TrackFace_Ang0["rail_inner",vector2]+vec2(0.4,0)):rotate(Ang)
        local Rail_Outer = (TrackFace_Ang0["rail_outer",vector2]+vec2(0.4,0)):rotate(Ang)
        local Ballast_Corner = (TrackFace_Ang0["ballast_corner",vector2]):rotate(Ang)
        local Ballast_Edge = (TrackFace_Ang0["ballast_edge",vector2]):rotate(Ang)
        
        #Implement DoubleRailPrecision
        local PScale = 1
        if(SMDQC & DoubleRailPrecision){PScale = 2}
        
        Out["A",vector] = round(Center + vec(-Ballast_Edge,-OriginHeight))
        Out["B",vector] = round(Center + vec(Ballast_Edge,-OriginHeight))
        Out["C",vector] = round(Center + vec(-Ballast_Corner,-OriginHeight))
        Out["D",vector] = round(Center + vec(Ballast_Corner,-OriginHeight))
        Out["E",vector] = round(Center + vec(-Ballast_Corner,-OriginHeight+BallastHeight))
        Out["F",vector] = round(Center + vec(Ballast_Corner,-OriginHeight+BallastHeight))
        Out["G",vector] = round((Center + vec(-Rail_Outer,-OriginHeight+RailBottomHeight))*PScale)/PScale
        Out["H",vector] = round((Center + vec(Rail_Outer,-OriginHeight+RailBottomHeight))*PScale)/PScale
        Out["I",vector] = round((Center + vec(-Rail_Inner,-OriginHeight+RailBottomHeight))*PScale)/PScale
        Out["J",vector] = round((Center + vec(Rail_Inner,-OriginHeight+RailBottomHeight))*PScale)/PScale
        Out["K",vector] = round((Center + vec(-Rail_Outer,-OriginHeight+RailTopHeight))*PScale)/PScale
        Out["L",vector] = round((Center + vec(Rail_Outer,-OriginHeight+RailTopHeight))*PScale)/PScale
        Out["M",vector] = round((Center + vec(-Rail_Inner,-OriginHeight+RailTopHeight))*PScale)/PScale
        Out["N",vector] = round((Center + vec(Rail_Inner,-OriginHeight+RailTopHeight))*PScale)/PScale
        #print(Out["A",vector])
        return Out
    }
    
    function void table:bankAdjust(BlendIn:vector2,BlendOut:vector2,Height,CurveLeft){
        local BHs = array()
        #          K M      N L
        #          G I      J H
        #       E----------------F
        #   /   |                |   \
        # A-----C----------------D-----B
        local Es = This["E",array]
        local Fs = This["F",array]
        local Gs = This["G",array]
        local Hs = This["H",array]
        local Is = This["I",array]
        local Js = This["J",array]
        local Ks = This["K",array]
        local Ls = This["L",array]
        local Ms = This["M",array]
        local Ns = This["N",array]
        
        local JCount = Es:count() #Plus 0
        
        #Find Banked Heights
        
        local StartIn = BlendIn:x()
        local EndIn = BlendIn:y()
        local StartOut = JCount - BlendOut:y()
        local EndOut = JCount - BlendOut:x()
        
        #Start with real flats just in case
        if(StartIn>0){
            for(N=0,StartIn){
                BHs[N,number] = 0
            }
        }
        #Transition In (if any)
        if(EndIn>StartIn){
            for(N=StartIn,EndIn){
                BHs[N,number] = Height*((N-StartIn)/(EndIn-StartIn))
            }
        }
        #Full Banked
        if(StartOut>EndIn){
            for(N=EndIn,StartOut){
                BHs[N,number] = Height
            }
        }
        #Transition Out (if any)
        if(EndOut>StartOut){
            for(N=StartOut,EndOut){
                BHs[N,number] = Height*((JCount-N-BlendOut:x())/(EndOut-StartOut))
            }
        }
        #end just in case
        if(EndOut<JCount){
            for(N=EndOut,JCount){
                BHs[N,number] = 0
            }
        }
        
        #Rail Adjust
        if(CurveLeft){
            for(N=0,JCount){
                Ns[N,vector] = round(Ns[N,vector] + vec(0,0,BHs[N,number]))
                Ls[N,vector] = round(Ls[N,vector] + vec(0,0,BHs[N,number]))
                Js[N,vector] = round(Js[N,vector] + vec(0,0,BHs[N,number]))
                Hs[N,vector] = round(Hs[N,vector] + vec(0,0,BHs[N,number]))
            }
        }else{
            for(N=0,JCount){
                Ks[N,vector] = round(Ks[N,vector] + vec(0,0,BHs[N,number]))
                Ms[N,vector] = round(Ms[N,vector] + vec(0,0,BHs[N,number]))
                Gs[N,vector] = round(Gs[N,vector] + vec(0,0,BHs[N,number]))
                Is[N,vector] = round(Is[N,vector] + vec(0,0,BHs[N,number]))
            }
        }
        
        #          K M      N L
        #          G I      J H
        #       E----------------F
        #   /   |                |   \
        # A-----C----------------D-----B
        
        #Ballast Adjust
        for(N=0,JCount){
            local BW = (Fs[N,vector]-Es[N,vector]):length()
            
            local LF = line(vec2(BW/2,0),vec2(0,1))
            local LE = line(vec2(-BW/2,0),vec2(0,1))
            local LeftPoint = (CurveLeft ? Gs[N,vector] : Is[N,vector])
            local RightPoint = (CurveLeft ? Js[N,vector] : Hs[N,vector])
            local Gauge = (vec(1,1,0)*(LeftPoint-RightPoint)):length()
            local CrossLine = line(vec2(-Gauge/2,CurveLeft ? 0 : BHs[N,number]),vec2(Gauge,CurveLeft ? BHs[N,number] : -BHs[N,number]))
            
            local LeftAdjust = ceil(vec(0,0,intersection(LE,CrossLine)[2,vector2]:y()))
            local RightAdjust = ceil(vec(0,0,intersection(LF,CrossLine)[2,vector2]:y()))
            Es[N,vector] = (Es[N,vector] + LeftAdjust)
            Fs[N,vector] = (Fs[N,vector] + RightAdjust)
        }
        
        This["E",array] = Es
        This["F",array] = Fs
        This["G",array] = Gs
        This["H",array] = Hs
        This["I",array] = Is
        This["J",array] = Js
        This["K",array] = Ks
        This["L",array] = Ls
        This["M",array] = Ms
        This["N",array] = Ns
        
        
        return void
    }
    
    function vector2 vround(In:vector2){
        if(SMDQC){
            return round(In,2)
        }else{
            return round(In)
        }
    }
    
    function void hitSound(){
        local HitSounds = array(
            "weapons/wrench_hit_build_success1.wav",
            "weapons/wrench_hit_build_success2.wav",
            "weapons/wrench_hit_world.wav"
            #"weapons/crowbar/crowbar_impact1.wav",
            #"weapons/crowbar/crowbar_impact2.wav"
        )
        if(SoundIndex<1){SoundIndex=1}
        soundPlay(SoundIndex,1,HitSounds[randint(1,HitSounds:count()),string])
        soundPitch(SoundIndex,110)
        SoundIndex++
        if(SoundIndex>3){SoundIndex=1}
        return void
    }
    function string pad3s(Number){
        Number = round(Number)
        local String = ""
        switch(sign(Number)){
            case -1,
                String = "-"
                break
            case 0,
                String = "0"
                break
            case 1,
                String = "+"
                break
        }
        Number = abs(Number)
        if(Number>99){
            String += Number:toString()
        }elseif(Number>9){
            String += "0"+Number
        }elseif(Number>=0){
            String += "00"+Number
        }
        return String
    }
    
    function string pad4s(Number){
        Number = round(Number)
        local String = ""
        switch(sign(Number)){
            case -1,
                String = "-"
                break
            case 0,
                String = "0"
                break
            case 1,
                String = "+"
                break
        }
        Number = abs(Number)
        if(Number>999){
            String += Number:toString()
        }elseif(Number>99){
            String += "0"+Number
        }elseif(Number>9){
            String += "00"+Number
        }elseif(Number>=0){
            String += "000"+Number
        }
        return String
    }
    
    function string pad4(Number){
        local String = ""
        Number = abs(round(Number))
        if(Number>999){
            String += Number:toString()
        }elseif(Number>99){
            String += "0"+Number
        }elseif(Number>9){
            String += "00"+Number
        }elseif(Number>=0){
            String += "000"+Number
        }
        return String
    }
    
    function number number:minsnap(P:array){
        local Out = 0
        if(This>P[P:count(),number]){
            Out = P[P:count(),number]
        }else{
            for(N=1,P:count()-1){
                if((This>=P[N,number])&(This<P[N+1,number])){
                    Out = P[N,number]
                    break
                }
            }
        }
        return Out
    }
    
    #Does all the definitions shit in one go
    function void newCompletePiece(VONDATA:string){
        local Data = vonDecodeTable(VONDATA)
        local Index = Data["Index",number]
        SelectedTrack = Index
        local Type = Data["Type",string]
        TrackNames[Index,string] = toString(Index)
        TrackTypes[Index,string] = Type
        #printTable(Data)
        switch(Type){
            case "straight", #StartPos Dir Length Height Segments
                StraightStartPos[Index,vector2] = Data["StartPos",vector2]*Scale
                StraightStartPosDefined[Index,number] = 1
                
                StraightDir[Index,number] = Data["Dir",number]
                StraightDirDefined[Index,number] = 1
                
                StraightLength[Index,number] = Data["Length",number]*Scale
                StraightLengthDefined[Index,number] = 1
                
                StraightHeight[Index,number] = Data["Height",number]*Scale
                StraightHeightDefined[Index,number] = 1
                
                StraightSegments[Index,number] = Data["Segments",number]
                StraightSegmentsDefined[Index,number] = 1
            break
            case "arc", #StartPos StartDir EndPos EndDir Radius Height Segments
                ArcStartPos[Index,vector2] = Data["StartPos",vector2]*Scale
                ArcStartPosDefined[Index,number] = 1
                
                ArcStartDir[Index,number] = Data["StartDir",number]
                ArcStartDirDefined[Index,number] = 1
                
                ArcEndPos[Index,vector2] = Data["EndPos",vector2]*Scale
                ArcEndPosDefined[Index,number] = 1
                
                ArcEndDir[Index,number] = Data["EndDir",number]
                ArcEndDirDefined[Index,number] = 1
                
                ArcRadius[Index,number] = Data["Radius",number]*Scale
                ArcRadiusDefined[Index,number] = 1
                
                ArcHeight[Index,number] = Data["Height",number]*Scale
                ArcHeightDefined[Index,number] = 1
                
                ArcSegments[Index,number] = Data["Segments",number]
                ArcSegmentsDefined[Index,number] = 1
            break
            case "banked_arc", #StartPos StartDir EndPos EndDir Radius Height Segments BlendIn BlendOut
                BankedArcStartPos[Index,vector2] = Data["StartPos",vector2]*Scale
                BankedArcStartPosDefined[Index,number] = 1
                
                BankedArcStartDir[Index,number] = Data["StartDir",number]
                BankedArcStartDirDefined[Index,number] = 1
                
                BankedArcEndPos[Index,vector2] = Data["EndPos",vector2]*Scale
                BankedArcEndPosDefined[Index,number] = 1
                
                BankedArcEndDir[Index,number] = Data["EndDir",number]
                BankedArcEndDirDefined[Index,number] = 1
                
                BankedArcRadius[Index,number] = Data["Radius",number]*Scale
                BankedArcRadiusDefined[Index,number] = 1
                
                BankedArcHeight[Index,number] = Data["Height",number]*Scale
                BankedArcHeightDefined[Index,number] = 1
                
                BankedArcSegments[Index,number] = Data["Segments",number]
                BankedArcSegmentsDefined[Index,number] = 1
                
                BankedArcBlendIn[Index,vector2] = Data["BlendIn",vector2]
                BankedArcBlendInDefined[Index,number] = 1
                
                BankedArcBlendOut[Index,vector2] = Data["BlendOut",vector2]
                BankedArcBlendOutDefined[Index,number] = 1
            break
            case "bezier", #StartPos StartDir EndPos EndDir StartCPLength EndCPLength Height Segments
                BezStartPos[Index,vector2] = Data["StartPos",vector2]*Scale
                BezStartPosDefined[Index,number] = 1
                
                BezStartDir[Index,number] = Data["StartDir",number]
                BezStartDirDefined[Index,number] = 1
                
                BezEndPos[Index,vector2] = Data["EndPos",vector2]*Scale
                BezEndPosDefined[Index,number] = 1
                
                BezEndDir[Index,number] = Data["EndDir",number]
                BezEndDirDefined[Index,number] = 1
                
                BezStartCPLength[Index,number] = Data["StartCPLength",number]*Scale
                BezStartCPLengthDefined[Index,number] = 1
                
                BezEndCPLength[Index,number] = Data["EndCPLength",number]*Scale
                BezEndCPLengthDefined[Index,number] = 1
                
                BezHeight[Index,number] = Data["Height",number]*Scale
                BezHeightDefined[Index,number] = 1
                
                BezSegments[Index,number] = Data["Segments",number]
                BezSegmentsDefined[Index,number] = 1
                
                BezXovers[Index,number] = Data["Xover",number]
            break
            case "switch", #MainPiece DivPiece Split
                SwitchMainPiece[Index,number] = Data["MainPiece",number]
                SwitchMainPieceDefined[Index,number] = 1
                
                SwitchDivPiece[Index,number] = Data["DivPiece",number]
                SwitchDivPieceDefined[Index,number] = 1
                
                SwitchSplit[Index,string] = Data["Split",string]
                SwitchSplitDefined[Index,number] = 1
            break
        }
        FullyDefined[Index,number] = 1
    }
    
    function void jprintf(Message:string){
        printColor(vec(95,95,127),"[JH] ",vec(255),Message)
        return void
    }
    
    function void jprint(Message:string){
        if(!SuppressOutput){printColor(vec(95,95,127),"[JH] ",vec(255),Message)}
        return void
    }
    function void cprint(Message:string){
        if(!SuppressOutput){printColor(vec(223),Message)}
        return void
    }
    
    function void vocalize(Sound:string){
        soundPlay("JH",5,Sound)
        soundPitch("JH",85)
    }
    
    JointsLists = table()
    
    #Put Textures into Table
    Textures["Mat_Ballast",string] = Mat_Ballast
    Textures["Mat_Trackbed_NoTies",string] = Mat_Trackbed_NoTies
    Textures["Mat_Trackbed_Ties",string] = Mat_Trackbed_Ties
    Textures["Mat_RailSide",string] = Mat_RailSide
    Textures["Mat_RailTop",string] = Mat_RailTop
    Textures["Mat_RailTop_Rusty",string] = Mat_RailTop_Rusty
    Textures["Mat_Ties",string] = Mat_Ties
    Textures["Mat_Tie",string] = Mat_Tie
    Textures["Mat_Tie_Plates",string] = Mat_Tie_Plates
    
    Textures["BallastU",number] = BallastU
    Textures["BallastV",number] = BallastV
    Textures["BallastScale",number] = BallastScale
    Textures["RailSideU",number] = RailSideU
    Textures["RailSideV",number] = RailSideV
    Textures["RailSideScale",number] = RailSideScale
    Textures["RailTopU",number] = RailTopU
    Textures["RailTopV",number] = RailTopV
    Textures["RailTopScale",number] = RailTopScale
    Textures["TieU",number] = TieU
    Textures["TieV",number] = TieV
    Textures["TieScale",number] = TieScale
    
    Textures["OriginHeight",number] = OriginHeight
    Textures["BallastHeight",number] = BallastHeight
    Textures["PeakHeight",number] = PeakHeight
    Textures["RailTopHeight",number] = RailTopHeight
    Textures["RailBottomHeight",number] = RailBottomHeight
    
    Textures["TieBottomHeight",number] = TieBottomHeight
    Textures["TieTopHeight",number] = TieTopHeight
    
    Textures["TieWidth",number] = TieWidth
    Textures["TieThickness",number] = TieThickness
    Textures["TiePlateWidth",number] = TiePlateWidth
    Textures["TiePlateCenter",number] = TiePlateCenter
    
    Textures["EdgeWidth",number] = (TrackFace_Ang0["ballast_edge",vector2] - TrackFace_Ang0["ballast_corner",vector2]):x()/2
    
    Textures["RailWidth",number] = RailWidth = (TrackFace_Ang0["rail_outer",vector2]-TrackFace_Ang0["rail_inner",vector2]):x()
    
    SwitchCompileStep = 0
    
    #VMF_GaugeName = GaugeName
    #SMD_GaugeName = GaugeName
    
    #Direction Holo
    holoCreate(0,E:toWorld(vec(0,32,16)),vec(1),E:toWorld(ang(0,0,-90)),vec(0,255,0),"cone")
    holoParent(0,E)
    
    #Intro Printo
    jprint("Welcome to John Henry, the Trakpak3 Track Generator!")
    if(->CS & ->EGP & ->Pod & ->Active){
        cprint("Ready to generate a track piece from the EGP Interface.")
    }elseif(->InputVons & ->VonGo & ->FileBuffer){
        cprint("Ready to generate pieces from a Von Docket.")
    }else{
        cprint("Please connect a Console Screen/EGP/Pod Controller (Single Piece Compile), or a Von Docket Loader, File Buffer, and Button (Mass Compile).")
    }
    
    if(hardQuota()<1e+6){
        jprint("Warning: tick rate is too low! Use the console command 'tp3_jh_prep' to set E2 limits before running.")
        vocalize("vo/engineer_positivevocalization01.mp3")
    }else{
        local Sounds = array(
            "vo/engineer_mvm_wave_start01.mp3",
            "vo/engineer_mvm_ask_ready02.mp3",
            "vo/engineer_battlecry04.mp3",
            "vo/engineer_mvm_stand_alone01.mp3"
            )
        vocalize(Sounds[randint(1,Sounds:count()),string])
    }
    printColor(SMDQC ? vec(0,255,0) : vec(0,0,255),SMDQC ? "SMD Mode Selected." : "VMF Mode Selected.")
}

if(VonGo & ~VonGo){
    Vons = InputVons:clone()
    VonID = 1
    AutoVon = 1
    AutoCompile = 1
    NextFrame = 0
    timer("loadvon",100)
}

if(clk("loadvon")){
    local MyVon = Vons[VonID,string]
    FinalCompileID = Vons:count()
    newCompletePiece(MyVon)
    timer(".plot",100)
}elseif(clk("script")){
    local Command = Script[ScriptLine,string]
    
    
    timer(Command,100)
    printColor(vec(255,255,0),ScriptLine+": "+Command)
    if(ScriptLine<Script:count()){
        timer("script",500)
        ScriptLine++
    }else{
        RunningScript = 0
    }
}
if(clk("makebrush")){
    #This enormous column of code is where all the "normal" (non-switch) track generation happens.
    local MaxSegment = SegmentTypes:count()
    if(SwitchXover){MaxSegment = ceil(MaxSegment/2)}
    switch(BrushWriteStep){
        case 0, #Init Segment
            
            #Segment Codes:
            #3.5 for Tri Rail/Peaked Tri Ballast (Graded Curves)
            #1.5 for Block Rail/Peaked Tri Ballast (Flat Curves)
            #1 for Block Rail/Block Ballast (diverging paths after sewed ballast)
            #0.5 for Block Rail/Peaked Ballast (Straights only)
            #0 for Block Rail/Trapezoidal Ballast (diverging paths after sewed ballast)
            #-1 for Left Rail only (before initial divergence, and for the stock rails up to the frog segment if #4 or #5 does not apply)
            #-1.5 for Left Rail/Left PB Only
            #-1.75 for Left Rail / Full PB
            #-2 for Right rail only (same as -1)
            #-2.5 for Right Rail/Right PB Only
            #-2.75 for Right Rail / Full PB
            #-3 for both rails (stock rails before frog)
            #-4 for skip (make split-up rail brushes!)
            #-4.5 for Split-up rails, Full PB
            #-5 for true skip (used immediate before and after the StockToChop in certain cases)
            #-5.5 for Skip Rails, Full PB
            
            InternalBrushID = sign(InternalBrushID) #Resets IBID to 1 or -1 depending on what is being made
            if((SwitchCompileStep==7)|(SwitchCompileStep==10)){ #MN's MN phys or DV's DV phys, the part the train will go down (facing)
                SegType = 1
            }elseif((SwitchCompileStep==8)|(SwitchCompileStep==9)){ #MN's DV phys or DV's MN phys, the part the train shouldn't be on
                local ST = SegmentTypes[SegID,number]
                SegType = (ST>0) ? 1 : -5
            }elseif(SwitchCompileStep>0){ #All Switch Refs
                local ST = SegmentTypes[SegID,number]
                #print("ST ", ST)
                if(ST==0){ #automatically sorts all zeroes into ones... may remove and simply assign 1 at Seg Assignment time
                    SegType = 1
                }else{
                    SegType = ST
                }
            }else{ #Single Track
                SegType = max(SegmentTypes[SegID,number],ForceSegmentType)
            }
            
            #print("Seg Type: ",SegType)
            
            local N = SegID-1
            local F = SegID
            
            NearPoints = pointPack(PieceID,N,Plots,(InternalBrushID>0) ? JointsLists : PhysJointsLists)
            FarPoints = pointPack(PieceID,F,Plots,(InternalBrushID>0) ? JointsLists : PhysJointsLists)
            
            TexNear = (TexCodes[SegID,number] == 1) | (TexCodes[SegID,number] == 3)
            TexFar = (TexCodes[SegID,number] == 2) | (TexCodes[SegID,number] == 3)
            
            #print(TexNear,TexFar)
            
            BrushWriteStep = 1
            timer("makebrush",100)
        break
        case 1, #Build Brush: BrushStrings[ARRAY] to store individual brush strings.
            local MadeLastBrush = 0
            switch(SegType){
                case -1, #Left Rail Only
                    if(SMDQC){
                        buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                    }else{
                        BrushStrings:buildBrush("rail_block_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                    }
                    
                    SegID++ #Move on to next segment
                    if(SegID > MaxSegment){ #Finished with last segment?
                        MadeLastBrush = 1 #set Flag
                    }else{
                        BrushWriteStep = 0 #Start over for next segment
                    }
                    
                break
                case -1.5, #Left Rail + Left PB
                    switch(InternalBrushID){
                        case 1, #Rail
                            if(SMDQC){
                                buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID++
                        break
                        case 2, #Ballast Center Tris
                            if(SMDQC){
                                buildMesh("ballast_peaked_left_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                InternalBrushID=4
                            }else{
                                BrushStrings:buildBrush("ballast_peaked_tri_left",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                InternalBrushID++
                            }
                        break
                        case 3, "Ballast Edges"
                            BrushStrings:buildBrush("ballast_edges_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 4, #Done
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            break
                    }
                break
                case -1.75, #Left Rail + Full PB
                    switch(InternalBrushID){
                        case 1, #Rail
                            if(SMDQC){
                                buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID++
                        break
                        case 2, #Ballast Center Tris
                            if(SMDQC){
                                buildMesh("ballast_peaked_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                InternalBrushID=4
                            }else{
                                BrushStrings:buildBrush("ballast_peaked_triangles",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                InternalBrushID++
                            }
                        break
                        case 3, "Ballast Edges"
                            BrushStrings:buildBrush("ballast_edges_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            BrushStrings:buildBrush("ballast_edges_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 4, #Done
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            break
                    }
                break
                case -2, #Right Rail Only
                    if(SMDQC){
                        buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                    }else{
                        BrushStrings:buildBrush("rail_block_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                    }
                    
                    SegID++ #Move on to next segment
                    if(SegID > MaxSegment){ #Finished with last segment?
                        MadeLastBrush = 1 #set Flag
                    }else{
                        BrushWriteStep = 0 #Start over for next segment
                    }
                    
                break
                case -2.5, #Right Rail + Right PB
                    switch(InternalBrushID){
                        case 1, #Rail
                            if(SMDQC){
                                buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID++
                        break
                        case 2, #Ballast Center Tris
                            if(SMDQC){
                                buildMesh("ballast_peaked_right_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                InternalBrushID=4
                            }else{
                                BrushStrings:buildBrush("ballast_peaked_tri_right",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                InternalBrushID++
                            }
                        break
                        case 3, "Ballast Edges"
                            BrushStrings:buildBrush("ballast_edges_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 4, #Done
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                        break
                    }
                break
                case -2.75, #Right Rail + Full PB
                    switch(InternalBrushID){
                        case 1, #Rail
                            if(SMDQC){
                                buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID++
                        break
                        case 2, #Ballast Center Tris
                            if(SMDQC){
                                buildMesh("ballast_peaked_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                InternalBrushID=4
                            }else{
                                BrushStrings:buildBrush("ballast_peaked_triangles",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                InternalBrushID++
                            }
                        break
                        case 3, "Ballast Edges"
                            BrushStrings:buildBrush("ballast_edges_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            BrushStrings:buildBrush("ballast_edges_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 4, #Done
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                        break
                    }
                break
                case -3, #Both Rails Only
                    if(SMDQC){
                        buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                        buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                    }else{
                        BrushStrings:buildBrush("rail_block_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                        BrushStrings:buildBrush("rail_block_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                    }
                    
                    SegID++ #Move on to next segment
                    if(SegID > MaxSegment){ #Finished with last segment?
                        MadeLastBrush = 1 #set Flag
                    }else{
                        BrushWriteStep = 0 #Start over for next segment
                    }
                    
                break
                case -4, #Chopped-Up Rails
                
                    local MN = (SwitchCompileStep==1)|(SwitchCompileStep==4)
                    local TN = TexNear #Was gonna do something with these but whatever.
                    local TF = TexFar #It's like 12 extra triangles at most
                    if(MN){
                        if(Rail1MN:count()>0){
                            if(SMDQC){buildGenericRailMesh(Rail1MN,0,0,Textures,TF,TN,0,0,MakeBallast)}else{BrushStrings:buildGenericRailBrush(Rail1MN,Textures,TF,TN,0,0,MakeBallast)}
                        }
                        if(Rail2MN:count()>0){
                            if(SMDQC){buildGenericRailMesh(Rail2MN,0,0,Textures,TF,TN,0,0,MakeBallast)}else{BrushStrings:buildGenericRailBrush(Rail2MN,Textures,TF,TN,0,0,MakeBallast)}
                        }
                        if(Rail3MN:count()>0){
                            if(SMDQC){buildGenericRailMesh(Rail3MN,0,0,Textures,TF,TN,0,0,MakeBallast)}else{BrushStrings:buildGenericRailBrush(Rail3MN,Textures,TF,TN,0,0,MakeBallast)}
                        }
                    }else{
                        if(Rail1DV:count()>0){
                            if(SMDQC){buildGenericRailMesh(Rail1DV,0,0,Textures,TF,TN,0,0,MakeBallast)}else{BrushStrings:buildGenericRailBrush(Rail1DV,Textures,TF,TN,0,0,MakeBallast)}
                        }
                        if(Rail2DV:count()>0){
                            if(SMDQC){buildGenericRailMesh(Rail2DV,0,0,Textures,TF,TN,0,0,MakeBallast)}else{BrushStrings:buildGenericRailBrush(Rail2DV,Textures,TF,TN,0,0,MakeBallast)}
                        }
                        if(Rail3DV:count()>0){
                            if(SMDQC){buildGenericRailMesh(Rail3DV,0,0,Textures,TF,TN,0,0,MakeBallast)}else{BrushStrings:buildGenericRailBrush(Rail3DV,Textures,TF,TN,0,0,MakeBallast)}
                        }
                    }
                
                    SegID++ #Move on to next segment
                    if(SegID > MaxSegment){ #Finished with last segment?
                        MadeLastBrush = 1 #set Flag
                    }else{
                        BrushWriteStep = 0 #Start over for next segment
                    }
                break
                case -4.5, #Chopped-Up Rails with PB
                    switch(InternalBrushID){
                        case 1, #Rail
                            local MN = (SwitchCompileStep==1)|(SwitchCompileStep==4)
                            local TN = TexNear #Was gonna do something with these but whatever.
                            local TF = TexFar #It's like 12 extra triangles at most
                            if(MN){
                                if(Rail1MN:count()>0){
                                    if(SMDQC){buildGenericRailMesh(Rail1MN,0,0,Textures,TF,TN,0,0,MakeBallast)}else{BrushStrings:buildGenericRailBrush(Rail1MN,Textures,TF,TN,0,0,MakeBallast)}
                                }
                                if(Rail2MN:count()>0){
                                    if(SMDQC){buildGenericRailMesh(Rail2MN,0,0,Textures,TF,TN,0,0,MakeBallast)}else{BrushStrings:buildGenericRailBrush(Rail2MN,Textures,TF,TN,0,0,MakeBallast)}
                                }
                                if(Rail3MN:count()>0){
                                    if(SMDQC){buildGenericRailMesh(Rail3MN,0,0,Textures,TF,TN,0,0,MakeBallast)}else{BrushStrings:buildGenericRailBrush(Rail3MN,Textures,TF,TN,0,0,MakeBallast)}
                                }
                            }else{
                                if(Rail1DV:count()>0){
                                    if(SMDQC){buildGenericRailMesh(Rail1DV,0,0,Textures,TF,TN,0,0,MakeBallast)}else{BrushStrings:buildGenericRailBrush(Rail1DV,Textures,TF,TN,0,0,MakeBallast)}
                                }
                                if(Rail2DV:count()>0){
                                    if(SMDQC){buildGenericRailMesh(Rail2DV,0,0,Textures,TF,TN,0,0,MakeBallast)}else{BrushStrings:buildGenericRailBrush(Rail2DV,Textures,TF,TN,0,0,MakeBallast)}
                                }
                                if(Rail3DV:count()>0){
                                    if(SMDQC){buildGenericRailMesh(Rail3DV,0,0,Textures,TF,TN,0,0,MakeBallast)}else{BrushStrings:buildGenericRailBrush(Rail3DV,Textures,TF,TN,0,0,MakeBallast)}
                                }
                            }
                            InternalBrushID++
                        break
                        case 2, #Ballast Center Tris
                            if(SMDQC){
                                buildMesh("ballast_peaked_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                InternalBrushID=4
                            }else{
                                BrushStrings:buildBrush("ballast_peaked_triangles",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                InternalBrushID++
                            }
                        break
                        case 3, "Ballast Edges"
                            BrushStrings:buildBrush("ballast_edges_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            BrushStrings:buildBrush("ballast_edges_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 4, #Done
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                        break
                    }
                break
                case -5, #True Skip
                    SegID++ #Move on to next segment
                    if(SegID > MaxSegment){ #Finished with last segment?
                        MadeLastBrush = 1 #set Flag
                    }else{
                        BrushWriteStep = 0 #Start over for next segment
                    }
                break
                case -5.5, #Skip rails, Full PB
                    switch(InternalBrushID){
                        case 1, #Ballast Center Tris
                            if(SMDQC){
                                buildMesh("ballast_peaked_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                InternalBrushID=3
                            }else{
                                BrushStrings:buildBrush("ballast_peaked_triangles",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                InternalBrushID++
                            }
                        break
                        case 2, "Ballast Edges"
                            BrushStrings:buildBrush("ballast_edges_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            BrushStrings:buildBrush("ballast_edges_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 3, #Done
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                        break
                    }
                break
                case 0, #Straight - Trap Ballast, Block Rails
                    #1 - Ballast
                    #2 - Rail 1
                    #3 - Rail 2
                    #-1 - Ballast PM
                    #-2 - Rails PM
                    
                    switch(InternalBrushID){
                        case 1, #Ballast
                            if(SMDQC){
                                buildMesh("ballast_trapezoid_ref",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("ballast_trapezoid",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID++
                        break
                        case 2, #Rails
                            if(SMDQC){
                                buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                BrushStrings:buildBrush("rail_block_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                        case -1, #Ballast PM
                            if(SMDQC){
                                buildMesh("ballast_block_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("ballast_trapezoid_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID--
                        break
                        case -2, #Rails PM
                            if(SMDQC){
                                buildMesh("rail_convex_phys_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_convex_phys_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                BrushStrings:buildBrush("rail_block_2_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                    }
                    
                    
                break
                case 0.25, #Block Rails Only (With Physics)
                    switch(InternalBrushID){
                        case 1, #Rails
                            if(SMDQC){
                                buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                BrushStrings:buildBrush("rail_block_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                        case -1, #Rails PM
                            if(SMDQC){
                                buildMesh("rail_convex_phys_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_convex_phys_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                BrushStrings:buildBrush("rail_block_2_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                    }
                break
                case 0.5, #Straight - Peaked Ballast, Block Rails
                    #1 - Ballast
                    #2 - Rail 1
                    #3 - Rail 2
                    #-1 - Ballast PM
                    #-2 - Rails PM
                    
                    switch(InternalBrushID){
                        case 1, #Ballast
                            if(SMDQC){
                                buildMesh("ballast_peaked_ref",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("ballast_peaked_simple",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID++
                        break
                        case 2, #Rails
                            if(SMDQC){
                                buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                BrushStrings:buildBrush("rail_block_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                        case -1, #Ballast PM
                            if(SMDQC){
                                buildMesh("ballast_block_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("ballast_trapezoid_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID--
                        break
                        case -2, #Rails PM
                            if(SMDQC){
                                buildMesh("rail_convex_phys_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_convex_phys_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                BrushStrings:buildBrush("rail_block_2_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                    }
                    
                    
                break
                case 1, #Flat Curve - Block Ballast, Block Rails
                    #1 - Ballast Center
                    #2 - Ballast Edges 1
                    #3 - Ballast Edges 2
                    #4 - Rails
                    #-1 - Ballast Center PM
                    #-2 - Rails PM
                    switch(InternalBrushID){
                        case 1, #Ballast center
                            if(SMDQC){
                                buildMesh("ballast_trapezoid_ref",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                                InternalBrushID = 4
                            }else{
                                BrushStrings:buildBrush("ballast_block",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                                InternalBrushID++
                            }
                        break
                        case 2, #Ballast edges 1
                            BrushStrings:buildBrush("ballast_edges_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 3, #Ballast edges 2
                            BrushStrings:buildBrush("ballast_edges_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 4, #Rails
                            if(SMDQC){
                                buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                BrushStrings:buildBrush("rail_block_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                        case -1, #Ballast PM
                            if(SMDQC){
                                buildMesh("ballast_block_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar) #Still a convex don't worry
                            }else{
                                BrushStrings:buildBrush("ballast_block_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID--
                        break
                        case -2, #Rails PM
                            if(SMDQC){
                                buildMesh("rail_convex_phys_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_convex_phys_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                BrushStrings:buildBrush("rail_block_2_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                        
                    }
                    
                break
                case 1.5, #Flat Curve - Tri Peaked Ballast, Block Rails
                    #1 - Ballast Center Tris
                    #2 - Ballast Edges 1
                    #3 - Ballast Edges 2
                    #4 - Rails
                    #-1 - Ballast Center PM (Simplified)
                    #-2 - Rails PM
                    switch(InternalBrushID){
                        case 1, #Ballast Center Triangles
                            if(SMDQC){
                                buildMesh("ballast_peaked_ref",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                                InternalBrushID = 4
                            }else{
                                BrushStrings:buildBrush("ballast_peaked_triangles",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                                InternalBrushID++
                            }
                        break
                        case 2, #Ballast Edges 1
                            BrushStrings:buildBrush("ballast_edges_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 3, #Ballast Edges 2
                            BrushStrings:buildBrush("ballast_edges_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 4, #Rails
                            if(SMDQC){
                                buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                BrushStrings:buildBrush("rail_block_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                        case -1, #Ballast PM
                            if(SMDQC){
                                buildMesh("ballast_block_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("ballast_block_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID--
                        break
                        case -2, #Rails PM
                            if(SMDQC){
                                buildMesh("rail_convex_phys_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_convex_phys_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                BrushStrings:buildBrush("rail_block_2_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                    }
                break
                case 2, #Banked Curve - Tri Ballast, Block Rails
                    #1 - Ballast Center Tris
                    #2 - Ballast Edges 1
                    #3 - Ballast Edges 2
                    #4 - Rails
                    #-1 - Ballast Center PM (Simplified)
                    #-2 - Rails PM
                    switch(InternalBrushID){
                        case 1, #Ballast Center Triangles
                            if(SMDQC){
                                buildMesh("ballast_trapezoid_ref",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                                InternalBrushID = 4
                            }else{
                                BrushStrings:buildBrush("ballast_triangles",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                                InternalBrushID++
                            }
                        break
                        case 2, #Ballast Edges 1
                            BrushStrings:buildBrush("ballast_edges_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 3, #Ballast Edges 2
                            BrushStrings:buildBrush("ballast_edges_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 4, #Rails
                            if(SMDQC){
                                buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                BrushStrings:buildBrush("rail_block_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                        case -1, #Ballast PM
                            if(SMDQC){
                                buildMesh("ballast_block_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("ballast_block_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID--
                        break
                        case -2, #Rails PM
                            if(SMDQC){
                                buildMesh("rail_convex_phys_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_convex_phys_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_block_1_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                BrushStrings:buildBrush("rail_block_2_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                    }
                break
                
                case 3, #Curved Ramp - Tri Ballast, Tri Rails
                    #1 - Ballast Center Tris
                    #2 - Ballast Edges 1
                    #3 - Ballast Edges 2
                    #4 - Rail 1 Tris
                    #5 - Rail 2 Tris
                    #-1 - Rail 1 Tris PM
                    #-2 - Rail 2 Tris PM
                    
                    switch(InternalBrushID){
                        case 1, #Ballast Center Triangles
                            if(SMDQC){
                                buildMesh("ballast_trapezoid_ref",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                                InternalBrushID = 5
                            }else{
                                BrushStrings:buildBrush("ballast_triangles",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                                InternalBrushID++
                            }
                        break
                        case 2, #Ballast Edges 1
                            BrushStrings:buildBrush("ballast_edges_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 3, #Ballast Edges 2
                            BrushStrings:buildBrush("ballast_edges_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 4, #Rail Tris 1
                            BrushStrings:buildBrush("rail_triangles_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 5, #Rail Tris 2
                            if(SMDQC){
                                buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_triangles_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                        case -1, #Rails Tri 2 PM
                            if(SMDQC){
                                buildMesh("ballast_block_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_triangles_1_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID--
                        break
                        case -2, #Rails Tri 1 PM
                            if(SMDQC){
                                buildMesh("rail_convex_phys_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_convex_phys_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_triangles_2_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                    }
                break
                case 3.25, #Tri Rails Only (With Physics)
                    switch(InternalBrushID){
                        case 1, #Rail Tris 1
                            if(!SMDQC){
                                BrushStrings:buildBrush("rail_triangles_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID++
                        break
                        case 2, #Rail Tris 2
                            if(SMDQC){
                                buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_triangles_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                        case -1, #Rails Tri 2 PM
                            if(!SMDQC){
                                BrushStrings:buildBrush("rail_triangles_1_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID--
                        break
                        case -2, #Rails Tri 1 PM
                            if(SMDQC){
                                buildMesh("rail_convex_phys_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_convex_phys_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_triangles_2_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                    }
                break
                case 3.5, #Peaked Curved Ramp - Peaked Tri Ballast, Tri Rails
                    #1 - Ballast Center Tris
                    #2 - Ballast Edges 1
                    #3 - Ballast Edges 2
                    #4 - Rail 1 Tris
                    #5 - Rail 2 Tris
                    #-1 - Rail 1 Tris PM
                    #-2 - Rail 2 Tris PM
                    switch(InternalBrushID){
                        case 1, #Ballast Center Triangles
                            if(SMDQC){
                                buildMesh("ballast_peaked_ref",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                                InternalBrushID = 5
                            }else{
                                BrushStrings:buildBrush("ballast_peaked_triangles",NearPoints,FarPoints,Textures,RidiculousTies==0,RidiculousTies==1,MakeBallast,TexNear,TexFar)
                                InternalBrushID++
                            }
                        break
                        case 2, #Ballast Edges 1
                            BrushStrings:buildBrush("ballast_edges_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 3, #Ballast Edges 2
                            BrushStrings:buildBrush("ballast_edges_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 4, #Rail Tris 1
                            BrushStrings:buildBrush("rail_triangles_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            InternalBrushID++
                        break
                        case 5, #Rail Tris 2
                            if(SMDQC){
                                buildMesh("rail_1_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_2_ref",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_triangles_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++ #Move on to next segment
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                        case -1, #Rails Tri 2 PM
                            if(SMDQC){
                                buildMesh("ballast_block_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_triangles_1_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            InternalBrushID--
                        break
                        case -2, #Rails Tri 1 PM
                            if(SMDQC){
                                buildMesh("rail_convex_phys_1",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                                buildMesh("rail_convex_phys_2",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }else{
                                BrushStrings:buildBrush("rail_triangles_2_phys",NearPoints,FarPoints,Textures,0,0,MakeBallast,TexNear,TexFar)
                            }
                            
                            SegID++
                            if(SegID > MaxSegment){ #Finished with last segment?
                                MadeLastBrush = 1 #set Flag
                            }else{
                                BrushWriteStep = 0 #Start over for next segment
                            }
                            hitSound()
                        break
                    }
                break
                
            }
            if(!MadeLastBrush){
                timer("makebrush",100)
            }else{
                if(InternalBrushID > 0){ #done making ref mesh -> add single ties, add markers OR move on to next switch compile step
                    if(RidiculousTies>1){
                        timer("plotsingleties_single",100)
                        jprint("Making Single Ties (Reference)...")
                    }elseif(SwitchCompileStep==0){ #finished with normal piece - make marker brushes
                        if(SMDQC){
                            timer("makemarkermeshes",100)
                        }else{
                            timer("makemarkerbrushes",100)
                        }
                        
                    }elseif((SwitchCompileStep==1)|(SwitchCompileStep==4)){ #finished MN normal brushes - move on to DV normal
                        SwitchCompileStep++
                        timer(".makebrushes",100)
                    }elseif((SwitchCompileStep==2)|(SwitchCompileStep==5)){ #finished DV normal brushes - move on to MN blended, or skip (peaked)
                        if(MakeBallast==2){ #Peaked - skip sewed ballast
                            timer("fuserails",100)
                        }else{ #Make Sewed Ballast
                            SwitchCompileStep++
                            SegID = 1
                            
                            local MN = SwitchMainPiece[SelectedTrack,number]
                            local DV = SwitchDivPiece[SelectedTrack,number]
                            
                            SWP_MN = Plots[MN,array]
                            SWP_DV = Plots[DV,array]
                            jprint("Building sewed ballast...")
                            timer("makebrushes_mn",100)
                        }
                    }
                }else{ #done with phys mesh - incorporate
                    if((SwitchCompileStep==7)|(SwitchCompileStep==9)){ #Done with MN, Add DV Part
                        local MN = SwitchMainPiece[SelectedTrack,number]
                        local DV = SwitchDivPiece[SelectedTrack,number]
                        
                        if((SwitchCompileStep==7) & (TrackTypes[DV,string]=="straight")){ #Done with MN's MN part; add patches
                            if(Rail3DV:count()>0){
                                if(SMDQC){buildGenericPhysMesh(Rail3DV,Textures)}else{BrushStrings:buildGenericPhysBrush(Rail3DV,Textures)}
                            }
                            
                            local N = vec2(JointsLists[MainLeft ? MN : DV,table]["N",array][(MainLeft ? RIMN : RIDV),vector])
                            local L = vec2(JointsLists[MainLeft ? MN : DV,table]["L",array][(MainLeft ? RIMN : RIDV),vector])
                            local K = vec2(JointsLists[MainLeft ? DV : MN,table]["K",array][(MainLeft ? RIDV : RIMN),vector])
                            local M = vec2(JointsLists[MainLeft ? DV : MN,table]["M",array][(MainLeft ? RIDV : RIMN),vector])
                            
                            local Verts = array()
                            if(!MainLeft){Verts = array(L,N,I_Top+(N-L),I_Top)}else{Verts = array(M,K,I_Top,I_Top+(M-K))}
                            if(SMDQC){buildGenericPhysMesh(Verts,Textures)}else{BrushStrings:buildGenericPhysBrush(Verts,Textures)}
                        }
                        
                        SwitchCompileStep++
                        timer(".makebrushes phys",100)
                    }else{ #Done with DV Part or done with regular track phys
                        local MN = SwitchMainPiece[SelectedTrack,number]
                        local DV = SwitchDivPiece[SelectedTrack,number]
                        if((SwitchCompileStep==10) & (TrackTypes[MN,string]=="straight")){ #Done with DV's DV part; add patches
                            if(Rail3MN:count()>0){
                                if(SMDQC){buildGenericPhysMesh(Rail3MN,Textures)}else{BrushStrings:buildGenericPhysBrush(Rail3MN,Textures)}
                            }

                            local N = vec2(JointsLists[MainLeft ? MN : DV,table]["N",array][(MainLeft ? RIMN : RIDV),vector])
                            local L = vec2(JointsLists[MainLeft ? MN : DV,table]["L",array][(MainLeft ? RIMN : RIDV),vector])
                            local K = vec2(JointsLists[MainLeft ? DV : MN,table]["K",array][(MainLeft ? RIDV : RIMN),vector])
                            local M = vec2(JointsLists[MainLeft ? DV : MN,table]["M",array][(MainLeft ? RIDV : RIMN),vector])
                            
                            local Verts = array()
                            if(MainLeft){Verts = array(L,N,I_Top+(N-L),I_Top)}else{Verts = array(M,K,I_Top,I_Top+(M-K))}
                            if(SMDQC){buildGenericPhysMesh(Verts,Textures)}else{BrushStrings:buildGenericPhysBrush(Verts,Textures)}
                            
                            #debugHoloArray(Verts,vec(255,0,0),vec(0,0,255))
                        }
                    
                        if(SMDQC){
                            timer("smooth_init",100)
                        }else{
                            
                            EntBrushMins[EntID,number] = StartingBrushID #Set the starting and ending Brush IDs for this entity
                            EntBrushMaxs[EntID,number] = maxBrushID()-1
                            #Set Entity name and class
                            if(SwitchCompileStep>0){
                                Entities[EntID,string] = (SwitchCompileStep==8 ? "mn" : "dv")+"_phys"
                            }else{
                                Entities[EntID,string] = "phys"
                            }
                            EntClasses[EntID,string] = "func_brush"
                            EntVisGroups[EntID,number] = ((SwitchCompileStep==8)) ? 1 : (SwitchCompileStep==10) ? 2 : 0
                            EntID++
                            StartingBrushID = maxBrushID()
                            if(StartingBrushID==0){StartingBrushID = 1}
                            
                            if((SwitchCompileStep==8)){
                            SwitchCompileStep++
                            timer(".makebrushes phys",100)
                            }else{
                                if(1){
                                    timer(".compile",100)
                                    soundPlay(0,0,"player/taunt_bumpkins_banjo_music_fast.wav")
                                }else{
                                    soundPlay(0,1,"player/taunt_bumpkins_banjo_music_stop.wav")
                                }
                            }
                        }
                        jprint("Phys Brushes Done!")
                    }
                    
                    
                }
            }
        break
    }
    
    
    
}elseif(clk("makebrushes_mn")){ #Make the sewed ballast brushes for the MN side
    #function array array:buildGenericBallastBlock(Verts:array,Textures:table,SegmentCenter:vector,SegmentAngle:angle){
    
    local NewNumOverlaps = 0
    switch(SwitchSplit[SelectedTrack,string]){
        case "none",
        case "main",
            NewNumOverlaps = NumOverlapsDV
            break
        case "diverging",
            NewNumOverlaps = NumOverlapsMN
            break
    }
    #Get Verts
    local Verts = array()
    local IF = Inner_MN[SegID,vector2]
    local IN = Inner_MN[SegID-1,vector2]
    local OF = Outer_MN[SegID,vector2]
    local ON = Outer_MN[SegID-1,vector2]
    if(MainLeft){
        Verts = array(IN,IF,OF,ON)
    }else{
        Verts = array(ON,OF,IF,IN)
    }    
    
    #Get Segment Center & Angle
    local PN = vec()
    local PF = vec()
    
    if(SwitchSplit[SelectedTrack,string]=="main"){
        local S = Jmap_DV[SegID-1,number]
        PN = SWP_MN[S,vector]
        PF = SWP_MN[S-1,vector]
    }else{
        PN = SWP_MN[SegID,vector]
        PF = SWP_MN[SegID-1,vector]
    }
    
    local SegmentCenter = (PN+PF)/2
    local SegmentAngle = -heading(vec(),ang(),PF-PN)
    
    #make block brush
    if(SMDQC){
        buildGenericBallastBlock(Verts,Textures,SegmentCenter,SegmentAngle,0,MakeBallast)
    }else{
        BrushStrings:buildGenericBallastBlock(Verts,Textures,SegmentCenter,SegmentAngle,0,MakeBallast)
        #print("Verts:")
        #printTable(Verts)
    }
    
    #get info for edges
    local EdgeWidth = (TrackFace_Ang0["ballast_edge",vector2] - TrackFace_Ang0["ballast_corner",vector2]):x()
    
    
    local OuterN = Outer_MN[SegID-1,vector2]
    local OuterF = Outer_MN[SegID,vector2]
    local InnerN = Inner_MN[SegID-1,vector2]
    local InnerF = Inner_MN[SegID,vector2]
    
    if(MainLeft){ #Up the Left
        local CN = OuterN
        local CF = OuterF
        local AN = round(CN + EdgeWidth*ax2(InnerN,OuterN))
        local AF = round(CF + EdgeWidth*ax2(InnerF,OuterF))
        
        #Patch first and last segments to ensure proper fit with other pieces
        if(SegID==1){
            local MN = SwitchMainPiece[SelectedTrack,number]
            AN = vec2(JointsLists[MN,table]["A",array][0,vector])
        }elseif(SegID==NewNumOverlaps){
            local MN = SwitchMainPiece[SelectedTrack,number]
            AF = vec2(JointsLists[MN,table]["A",array][NumOverlapsMN,vector])
        }
        if(SMDQC){
            buildGenericBallastEdges(CN,CF,AN,AF,Textures,SegmentCenter,SegmentAngle,MakeBallast)
        }else{
            BrushStrings:buildGenericBallastEdges(CN,CF,AN,AF,Textures,SegmentCenter,SegmentAngle,MakeBallast)
        }
    }else{ #Down the Right
        local CN = OuterF
        local CF = OuterN
        local AN = round(CN + EdgeWidth*ax2(InnerF,OuterF))
        local AF = round(CF + EdgeWidth*ax2(InnerN,OuterN))
        
        #Patch first and last segments to ensure proper fit with other pieces
        if(SegID==1){
            local MN = SwitchMainPiece[SelectedTrack,number]
            AF = vec2(JointsLists[MN,table]["B",array][0,vector])
        }elseif(SegID==NewNumOverlaps){
            local MN = SwitchMainPiece[SelectedTrack,number]
            AN = vec2(JointsLists[MN,table]["B",array][NumOverlapsMN,vector])
        }
        if(SMDQC){
            buildGenericBallastEdges(CN,CF,AN,AF,Textures,SegmentCenter,SegmentAngle,MakeBallast)
        }else{
            BrushStrings:buildGenericBallastEdges(CN,CF,AN,AF,Textures,SegmentCenter,SegmentAngle,MakeBallast)
        }
    }
    
    if(SegID==NewNumOverlaps){ #Last sewed segment - add Triangle/patch and go to DV
        #Triangle
        if(SMDQC){
            buildGenericBallastBlock(FinalTri_MN,Textures,SegmentCenter,SegmentAngle,0,MakeBallast)
        }else{
            BrushStrings:buildGenericBallastBlock(FinalTri_MN,Textures,SegmentCenter,SegmentAngle,0,MakeBallast)
        }
        
        #Patch
        local MN = SwitchMainPiece[SelectedTrack,number]
        if(MainLeft){ #Right on inside
            local B = vec2(JointsLists[MN,table]["B",array][NumOverlapsMN,vector])
            local D = vec2(JointsLists[MN,table]["D",array][NumOverlapsMN,vector])
            local I = Inner_MN[SegID,vector2]
            
            if(SMDQC){
                buildBallastPatchR(B,D,I,Textures,SegmentCenter,SegmentAngle,MakeBallast)
            }else{
                BrushStrings:buildBallastPatchR(B,D,I,Textures,SegmentCenter,SegmentAngle,MakeBallast)
            }
        }else{ #Left on Inside
            local A = vec2(JointsLists[MN,table]["A",array][NumOverlapsMN,vector])
            local C = vec2(JointsLists[MN,table]["C",array][NumOverlapsMN,vector])
            local I = Inner_MN[SegID,vector2]
            
            if(SMDQC){
                buildBallastPatchL(A,C,I,Textures,SegmentCenter,SegmentAngle,MakeBallast)
            }else{
                BrushStrings:buildBallastPatchL(A,C,I,Textures,SegmentCenter,SegmentAngle,MakeBallast)
            }
        }
        
        SegID = 1
        timer("makebrushes_dv",100)
    }else{ #Do next MN sewed brush
        SegID++
        timer("makebrushes_mn",100)
    }
    
}elseif(clk("makebrushes_dv")){ #Make the sewed ballast brushes for the DV side
    #function array array:buildGenericBallastBlock(Verts:array,Textures:table,SegmentCenter:vector,SegmentAngle:angle){
    
    local NewNumOverlaps = 0
    switch(SwitchSplit[SelectedTrack,string]){
        case "none",
        case "main",
            NewNumOverlaps = NumOverlapsDV
            break
        case "diverging",
            NewNumOverlaps = NumOverlapsMN
            break
    }
    
    #Get Verts
    local Verts = array()
    local IF = Inner_DV[SegID,vector2]
    local IN = Inner_DV[SegID-1,vector2]
    local OF = Outer_DV[SegID,vector2]
    local ON = Outer_DV[SegID-1,vector2]
    if(!MainLeft){
        Verts = array(IN,IF,OF,ON)
    }else{
        Verts = array(ON,OF,IF,IN)
    }    
    
    #Get Segment Center & Angle
    local PN = vec()
    local PF = vec()
    
    if(SwitchSplit[SelectedTrack,string]=="diverging"){
        local S = Jmap_MN[SegID-1,number]
        PN = SWP_DV[S,vector]
        PF = SWP_DV[S-1,vector]
    }else{
        PN = SWP_DV[SegID,vector]
        PF = SWP_DV[SegID-1,vector]
    }
    
    local SegmentCenter = (PN+PF)/2
    local SegmentAngle = -heading(vec(),ang(),PF-PN)
    
    
    if(SMDQC){
        buildGenericBallastBlock(Verts,Textures,SegmentCenter,SegmentAngle,0,MakeBallast)
    }else{
        BrushStrings:buildGenericBallastBlock(Verts,Textures,SegmentCenter,SegmentAngle,0,MakeBallast)
    }
    
    #get info for edges
    local EdgeWidth = (TrackFace_Ang0["ballast_edge",vector2] - TrackFace_Ang0["ballast_corner",vector2]):x()
    
    
    local OuterN = Outer_DV[SegID-1,vector2]
    local OuterF = Outer_DV[SegID,vector2]
    local InnerN = Inner_DV[SegID-1,vector2]
    local InnerF = Inner_DV[SegID,vector2]
    
    if(!MainLeft){ #Up the Left
        local CN = OuterN
        local CF = OuterF
        local AN = round(CN + EdgeWidth*ax2(InnerN,OuterN))
        local AF = round(CF + EdgeWidth*ax2(InnerF,OuterF))
        
        #Patch first and last segments to ensure proper fit with other pieces
        if(SegID==1){
            local DV = SwitchDivPiece[SelectedTrack,number]
            AN = vec2(JointsLists[DV,table]["A",array][0,vector])  
        }elseif(SegID==NewNumOverlaps){
            local DV = SwitchDivPiece[SelectedTrack,number]
            AF = vec2(JointsLists[DV,table]["A",array][NumOverlapsDV,vector])
        }
        
        if(SMDQC){
            buildGenericBallastEdges(CN,CF,AN,AF,Textures,SegmentCenter,SegmentAngle,MakeBallast)
        }else{
            BrushStrings:buildGenericBallastEdges(CN,CF,AN,AF,Textures,SegmentCenter,SegmentAngle,MakeBallast)
        }
    }else{ #Down the Right
        local CN = OuterF
        local CF = OuterN
        local AN = round(CN + EdgeWidth*ax2(InnerF,OuterF))
        local AF = round(CF + EdgeWidth*ax2(InnerN,OuterN))
        
        #Patch first and last segments to ensure proper fit with other pieces
        if(SegID==1){
            local DV = SwitchDivPiece[SelectedTrack,number]
            AF = vec2(JointsLists[DV,table]["B",array][0,vector])
        }elseif(SegID==NewNumOverlaps){ 
            local DV = SwitchDivPiece[SelectedTrack,number]
            AN = vec2(JointsLists[DV,table]["B",array][NumOverlapsDV,vector])
        }
        
        if(SMDQC){
            buildGenericBallastEdges(CN,CF,AN,AF,Textures,SegmentCenter,SegmentAngle,MakeBallast)
        }else{
            BrushStrings:buildGenericBallastEdges(CN,CF,AN,AF,Textures,SegmentCenter,SegmentAngle,MakeBallast)
        }
    }
    
    if(SegID==NewNumOverlaps){ #Done with last sewed segment - go to make frog
        #Triangle
        if(SMDQC){
            buildGenericBallastBlock(FinalTri_DV,Textures,SegmentCenter,SegmentAngle,0,MakeBallast)
        }else{
            BrushStrings:buildGenericBallastBlock(FinalTri_DV,Textures,SegmentCenter,SegmentAngle,0,MakeBallast)
        }
        
        #Patch
        local DV = SwitchDivPiece[SelectedTrack,number]
        if(!MainLeft){ #Right on inside
            local B = vec2(JointsLists[DV,table]["B",array][NumOverlapsDV,vector])
            local D = vec2(JointsLists[DV,table]["D",array][NumOverlapsDV,vector])
            local I = Inner_DV[SegID,vector2]
            
            if(SMDQC){
                buildBallastPatchR(B,D,I,Textures,SegmentCenter,SegmentAngle,MakeBallast)
            }else{
                BrushStrings:buildBallastPatchR(B,D,I,Textures,SegmentCenter,SegmentAngle,MakeBallast)
            }
        }else{ #Left on Inside
            local A = vec2(JointsLists[DV,table]["A",array][NumOverlapsDV,vector])
            local C = vec2(JointsLists[DV,table]["C",array][NumOverlapsDV,vector])
            local I = Inner_DV[SegID,vector2]
            
            if(SMDQC){
                buildBallastPatchL(A,C,I,Textures,SegmentCenter,SegmentAngle,MakeBallast)
            }else{
                BrushStrings:buildBallastPatchL(A,C,I,Textures,SegmentCenter,SegmentAngle,MakeBallast)
            }
        }
        
        timer("fuserails",100)
        
    }else{ #Next DV sewed brush
        SegID++
        timer("makebrushes_dv",100)
    }
    
}elseif(clk("fuserails")){
    #function array array:fuseRails(N:vector2,L:vector2,K:vector2,M:vector2,Top:vector2,Bottom:vector2,Textures:table){
    #          K M      N L
    #          G I      J H
    #       E----------------F
    #   /   |                |   \
    # A-----C----------------D-----B
    local MN = SwitchMainPiece[SelectedTrack,number]
    local DV = SwitchDivPiece[SelectedTrack,number]
    local N = vec2(JointsLists[MainLeft ? MN : DV,table]["N",array][(MainLeft ? RIMN : RIDV),vector])
    local L = vec2(JointsLists[MainLeft ? MN : DV,table]["L",array][(MainLeft ? RIMN : RIDV),vector])
    local K = vec2(JointsLists[MainLeft ? DV : MN,table]["K",array][(MainLeft ? RIDV : RIMN),vector])
    local M = vec2(JointsLists[MainLeft ? DV : MN,table]["M",array][(MainLeft ? RIDV : RIMN),vector])
    
    #debugHolo(1,N,vec(255,0,0))
    #debugHolo(2,I_Bottom,vec(255,255,0))
    #debugHolo(3,I_Top,vec(0,255,0))
    #debugHolo(4,L,vec(0,0,255))
    #print(N,L,K,M)
    
    if(SMDQC){
        fuseRails(N,L,K,M,I_Top,I_Bottom,Textures,MakeBallast)
    }else{
        BrushStrings:fuseRails(N,L,K,M,I_Top,I_Bottom,Textures,MakeBallast)
    }
    
    jprint("Making Closure Rails, Frog, and Switch Points...")
    timer("makeclosurerails",100) 
    
}elseif(clk("makeclosurerails")){
    
    #Each Closure Rail segment is F/F/N/N, ClosureThrows starts at 1 at the bottom and goes up
    
    local PointsDV = (SwitchCompileStep==6)
    
    for(N=1,ClosurePointGroupsMN:count()){
        local Verts = ClosurePointGroupsMN[N,array]:clone()
        if(PointsDV){ #Adjust for switch throw
            for(M=1,4){
                local ThrowIndex = N + (M<3)
                Verts[M,vector2] = Verts[M,vector2] + round(ClosureThrowsMN[ThrowIndex,number]*ThrowAxisMN)
            }
        }
        if(SMDQC){
            local WF = AnimateSwitches ? ClosureThrowsMN[N+1,number]/SwitchThrow : 0
            local WN = AnimateSwitches ? ClosureThrowsMN[N,number]/SwitchThrow : 0
            buildGenericRailMesh(Verts,WF,WN,Textures,0,0,0,0,MakeBallast)
        }else{
            BrushStrings:buildGenericRailBrush(Verts,Textures,0,0,0,0,MakeBallast)
        }
    }
    #print("CTM")
    #printTable(ClosureThrowsMN)
    #print("CTD")
    #printTable(ClosureThrowsDV)
    for(N=1,ClosurePointGroupsDV:count()){
        local Verts = ClosurePointGroupsDV[N,array]:clone()
        if(!PointsDV){ #Adjust for switch throw
            for(M=1,4){
                local ThrowIndex = N + (M<3)
                Verts[M,vector2] = Verts[M,vector2] + round(ClosureThrowsDV[ThrowIndex,number]*ThrowAxisDV)
                #debugHolo(Verts[4,vector2],vec(255,0,0),0)
                #if(N==1){print(round(ClosureThrowsDV[ThrowIndex,number]*ThrowAxisDV))}
            }
        }
        if(SMDQC){
            local WF = AnimateSwitches ? ClosureThrowsDV[N+1,number]/SwitchThrow : 0
            local WN = AnimateSwitches ? ClosureThrowsDV[N,number]/SwitchThrow : 0
            buildGenericRailMesh(Verts,WF,WN,Textures,0,0,0,0,MakeBallast)
            #print(Verts[1,vector2]:y(), WF, Verts[3,vector2]:y(), WN)
        }else{
            BrushStrings:buildGenericRailBrush(Verts,Textures,0,0,0,0,MakeBallast)
        }
    }
    timer("makefrog",100)
}elseif(clk("makefrog")){
    if(SMDQC){
        buildFrog(MainLeft,ClosurePointOuterMN,ClosurePointInnerMN,ClosureCornerMN,ClosurePointOuterDV,ClosurePointInnerDV,ClosureCornerDV,CheckLength,Textures,MakeBallast)
    }else{
        BrushStrings:buildFrog(MainLeft,ClosurePointOuterMN,ClosurePointInnerMN,ClosureCornerMN,ClosurePointOuterDV,ClosurePointInnerDV,ClosureCornerDV,CheckLength,Textures,MakeBallast)
    }
    
    timer("buildpoints",100)
}elseif(clk("buildpoints")){
    
    local PL = array()
    local PR = array()
    
    #SWPointsFarMN SWPointsNearMN SWPointsFarDV SWPointsNearDV EndPointInnerMN EndPointInnerDV EndPointOuterMN EndPointOuterDV
    #PointsDV = 0
    local PointsDV = (SwitchCompileStep==6)
    #B---A
    #|   |
    #C---E
    # \ /
    #  D
    
    #I was right you only need C D and E
    
    local LC = MainLeft ? SWPointsFarMN : SWPointsFarDV
    local LD = MainLeft ? SWPointsNearMN : SWPointsNearDV
    local LE = vec2(MainLeft ? ContactPointInnerDV : ContactPointInnerMN)
    
    local RE = MainLeft ? SWPointsFarDV : SWPointsFarMN
    local RD = MainLeft ? SWPointsNearDV : SWPointsNearMN
    local RC = vec2(MainLeft ? ContactPointInnerMN : ContactPointInnerDV)
    
    local OpenMN = ThrowAxisDV*SwitchThrow
    local OpenDV = ThrowAxisMN*SwitchThrow
    
    BladeCenter = vec((0.5*LD + 0.5*RD),-OriginHeight + RailTopHeight+1)
    
    local TL = 0
    local TR = 0
    if(MainLeft){
        if(PointsDV){ #Lined for DV
            RC += OpenDV
            RD += OpenDV
            RE += OpenDV
            TR = 1
        }else{ #Lined for MN
            TL = 1
            LC += OpenMN
            LD += OpenMN
            LE += OpenMN
        }
    }else{
        if(PointsDV){ #Lined for DV
            LC += OpenDV
            LD += OpenDV
            LE += OpenDV
            TL = 1
        }else{ #Lined for MN
            RC += OpenMN
            RD += OpenMN
            RE += OpenMN
            TR = 1
        }
    }
    #local LeftAngle = -heading(vec(),ang(),vec(LD-LE))
    #local RightAngle = -heading(vec(),ang(),vec(RD-RC))
    if(SMDQC){
        buildPointTip(array(LE,LC,LD),Textures,TL,1,1,MakeBallast,AnimateSwitches)
        buildPointTip(array(RE,RC,RD),Textures,1,TR,0,MakeBallast,AnimateSwitches)
    }else{
        BrushStrings:buildPointTip(array(LE,LC,LD),Textures,TL,1,1,MakeBallast)
        BrushStrings:buildPointTip(array(RE,RC,RD),Textures,1,TR,0,MakeBallast)
    }
    
    #debugHoloArray(array(LE,LC,LD),Red,Yellow)
    #debugHoloArray(array(RE,RC,RD),Green,Blue)
    
    timer("buildcheckrails",100)
}elseif(clk("buildcheckrails")){
    
    if(SMDQC){
        buildGenericRailMesh(CheckPointGroups[1,array],0,0,Textures,0,0,1,0,MakeBallast)
        buildGenericRailMesh(CheckPointGroups[2,array],0,0,Textures,0,0,1,0,MakeBallast)
        buildGenericRailMesh(CheckPointGroups[3,array],0,0,Textures,1,0,1,0,MakeBallast)
        buildGenericRailMesh(CheckPointGroups[4,array],0,0,Textures,0,1,1,0,MakeBallast)
        buildGenericRailMesh(CheckPointGroups[5,array],0,0,Textures,1,0,1,0,MakeBallast)
        buildGenericRailMesh(CheckPointGroups[6,array],0,0,Textures,0,1,1,0,MakeBallast)
    }else{
        BrushStrings:buildGenericRailBrush(CheckPointGroups[1,array],Textures,0,0,1,0,MakeBallast)
        BrushStrings:buildGenericRailBrush(CheckPointGroups[2,array],Textures,0,0,1,0,MakeBallast)
        BrushStrings:buildGenericRailBrush(CheckPointGroups[3,array],Textures,1,0,1,0,MakeBallast)
        BrushStrings:buildGenericRailBrush(CheckPointGroups[4,array],Textures,0,1,1,0,MakeBallast)
        BrushStrings:buildGenericRailBrush(CheckPointGroups[5,array],Textures,1,0,1,0,MakeBallast)
        BrushStrings:buildGenericRailBrush(CheckPointGroups[6,array],Textures,0,1,1,0,MakeBallast)
    }

    hitSound()
    jprint("Placing Ties...")
    if(STC>0){
        TieID = 1
        timer("buildsingleties",100)
    }else{
        #Jump to fused ties - WIP
    }
}elseif(clk("buildsingleties")){
    local Done = 0
    if(STC<=0){
        Done = 1
    }else{
        for(N=1,4){
            if(SMDQC){
                buildSingleTie(SingleTieCenters[TieID,vector],SingleTieAngles[TieID,angle],Textures,SingleTieHeights[TieID,number],RidiculousTies==3,MakeBallast)
            }else{
                BrushStrings:buildSingleTie(SingleTieCenters[TieID,vector],SingleTieAngles[TieID,angle],Textures,SingleTieHeights[TieID,number],RidiculousTies==3,MakeBallast)
            }
            
            if(TieID==STC){
                Done = 1
                TieID++
                break
            }else{
                TieID++
            }
        }
    }
    if(!Done){
        timer("buildsingleties",100)
    }else{
        MaxPlates = PlateID-1
        PlateID = 1
        hitSound()
        if(SwitchCompileStep==0){ #Bail out if not a switch
            if(SMDQC){
                timer("makemarkermeshes",100)
            }else{
                timer("makemarkerbrushes",100)
            }
        }else{
            timer("buildtieplates",100)
        }
    }
 
}elseif(clk("buildtieplates")){
    
    local Done = 0
    for(N=1,4){
        if(SMDQC){
            buildTieMeshOverride(PlatePointGroups[PlateID,array],PlateTexCenters[PlateID,vector2],CardinalAng,Textures,1,SideStates[PlateID,number],RidiculousTies==3,MakeBallast)
        }else{
            BrushStrings:buildTieBrushOverride(PlatePointGroups[PlateID,array],PlateTexCenters[PlateID,vector2],CardinalAng,Textures,1,SideStates[PlateID,number],RidiculousTies==3,MakeBallast)
        }
        if(PlateID==MaxPlates){
            Done = 1
            break
        }else{
            PlateID++
        }
    }
    if(Done){
        PlateID = MaxPlates+1 #Necessary to prevent DV piece from missing a plate
        MaxBridges = BridgeID-1
        BridgeID = 1
        hitSound()
        timer("buildtiebridges",100)
    }else{
        timer("buildtieplates",100)
    }
}elseif(clk("buildtiebridges")){
    local Done = 0
    for(N=1,4){
        if(SMDQC){
            buildTieMeshOverride(BridgePointGroups[BridgeID,array],BridgeTexCenters[BridgeID,vector2],CardinalAng,Textures,0,0,RidiculousTies==3,MakeBallast)
        }else{
            BrushStrings:buildTieBrushOverride(BridgePointGroups[BridgeID,array],BridgeTexCenters[BridgeID,vector2],CardinalAng,Textures,0,0,RidiculousTies==3,MakeBallast)
        }
        if(BridgeID==MaxBridges){
            Done = 1
            break
        }else{
            BridgeID++
        }
    }
    if(Done){
        BridgeID = MaxBridges+1 #Necessary to prevent DV piece from missing a bridge
        hitSound()
        timer("dun",100)
    }else{
        timer("buildtiebridges",100)
    }
}elseif(clk("dun")){
    if(SMDQC){
        timer("makemarkermeshes",100)
    }else{
        timer("finishswitch",100)
    }
}elseif(clk("finishswitch")){
    #Add marker brushes, point ents, and finalize
    
    local MN = SwitchMainPiece[SelectedTrack,number]
    local DV = SwitchDivPiece[SelectedTrack,number]
    local PMN = Plots[MN,array]
    local PDV = Plots[DV,array]
    
    local X1 = BezXovers[MN,number]
    local X2 = BezXovers[DV,number]
    
    local P1 = PMN[PMN:count(),vector]
    local P2 = PDV[PDV:count(),vector]
    
    if(X1){P1 = PMN[ceil(PMN:count()/2),vector]}
    if(X2){P2 = PDV[ceil(PDV:count()/2),vector]}
    
    #print("Crossover status: ",X1,X2)
    
    BrushStrings:buildSingleMarkerBrush(vec2(PMN[0,vector]),Textures,0)
    BrushStrings:buildSingleMarkerBrush(vec2(P1),Textures,X1)
    BrushStrings:buildSingleMarkerBrush(vec2(P2),Textures,X2)
    
    EntBrushMins[EntID,number] = StartingBrushID #Set the starting and ending Brush IDs for this entity
    EntBrushMaxs[EntID,number] = maxBrushID()-1
    Entities[EntID,string] = TrackNames[SelectedTrack,string]+(SwitchCompileStep==3 ? "_mn" : "_dv") #Set Entity name and class
    EntClasses[EntID,string] = "propper_model"
    EntVisGroups[EntID,number] = (SwitchCompileStep==3) ? 1 : (SwitchCompileStep==6) ? 2 : 0
    #print("SCS "+SwitchCompileStep)
    EntID++
    
    local SwitchProp = Entities[EntID-1,string]
    
    #Attachments and skins
    if(SwitchCompileStep==3){
        #Attachment: Point on MN to throw DV
        if(!WholeSwitchXover){
            Entities[EntID,string] = "autopoint1"
            EntClasses[EntID,string] = "propper_attachment"
            EntVisGroups[EntID,number] = 1
            
            EntOrigins[EntID,vector] = AutoPointDV
            EntTargets[EntID,string] = SwitchProp
            EntID++
        }
        
        #Attachment: Frog
        Entities[EntID,string] = "frog1"
        EntClasses[EntID,string] = "propper_attachment"
        EntVisGroups[EntID,number] = 1
        
        EntOrigins[EntID,vector] = FrogPos
        EntTargets[EntID,string] = SwitchProp
        EntID++
        
        #Attachment: Blade Center
        Entities[EntID,string] = "bladecenter1"
        EntClasses[EntID,string] = "propper_attachment"
        EntVisGroups[EntID,number] = 1
        
        EntOrigins[EntID,vector] = BladeCenter
        EntTargets[EntID,string] = SwitchProp
        EntID++
        
        #Skins
        Entities[EntID,string] = "skin"
        EntClasses[EntID,string] = "propper_skins"
        EntVisGroups[EntID,number] = 1
        EntTargets[EntID,string] = SwitchProp
        EntSkins[EntID,array] = BallastSkins
        EntID++
        
        Entities[EntID,string] = "skin"
        EntClasses[EntID,string] = "propper_skins"
        EntVisGroups[EntID,number] = 1
        EntTargets[EntID,string] = SwitchProp
        EntSkins[EntID,array] = (RidiculousTies==1) ? BallastTrackbedSkins : BallastTiesSkins
        EntID++
        
        if(RidiculousTies==1){
            Entities[EntID,string] = "skin"
            EntClasses[EntID,string] = "propper_skins"
            EntVisGroups[EntID,number] = 1
            EntTargets[EntID,string] = SwitchProp
            EntSkins[EntID,array] = TiesSkins
            EntID++
        }

        Entities[EntID,string] = "skin"
        EntClasses[EntID,string] = "propper_skins"
        EntVisGroups[EntID,number] = 1
        EntTargets[EntID,string] = SwitchProp
        EntSkins[EntID,array] = TieNoPlateSkins
        EntID++
        
        Entities[EntID,string] = "skin"
        EntClasses[EntID,string] = "propper_skins"
        EntVisGroups[EntID,number] = 1
        EntTargets[EntID,string] = SwitchProp
        EntSkins[EntID,array] = TiePlateSkins
        EntID++

    }elseif(SwitchCompileStep==6){
        #Attachment: Point on DV to throw MN
        Entities[EntID,string] = "autopoint1"
        EntClasses[EntID,string] = "propper_attachment"
        EntVisGroups[EntID,number] = 2
        
        EntOrigins[EntID,vector] = AutoPointMN
        EntTargets[EntID,string] = SwitchProp
        EntID++
        
        #Attachment: Frog
        Entities[EntID,string] = "frog1"
        EntClasses[EntID,string] = "propper_attachment"
        EntVisGroups[EntID,number] = 2
        
        EntOrigins[EntID,vector] = FrogPos
        EntTargets[EntID,string] = SwitchProp
        EntID++
        
        #Attachment: Blade Center
        Entities[EntID,string] = "bladecenter1"
        EntClasses[EntID,string] = "propper_attachment"
        EntVisGroups[EntID,number] = 2
        
        EntOrigins[EntID,vector] = BladeCenter
        EntTargets[EntID,string] = SwitchProp
        EntID++
        
        #Skins
        Entities[EntID,string] = "skin"
        EntClasses[EntID,string] = "propper_skins"
        EntVisGroups[EntID,number] = 2
        EntTargets[EntID,string] = SwitchProp
        EntSkins[EntID,array] = BallastSkins
        EntID++
        
        Entities[EntID,string] = "skin"
        EntClasses[EntID,string] = "propper_skins"
        EntVisGroups[EntID,number] = 2
        EntTargets[EntID,string] = SwitchProp
        EntSkins[EntID,array] = (RidiculousTies==1) ? BallastTrackbedSkins : BallastTiesSkins
        EntID++
        
        if(RidiculousTies==1){
            Entities[EntID,string] = "skin"
            EntClasses[EntID,string] = "propper_skins"
            EntVisGroups[EntID,number] = 2
            EntTargets[EntID,string] = SwitchProp
            EntSkins[EntID,array] = TiesSkins
            EntID++
        }

        Entities[EntID,string] = "skin"
        EntClasses[EntID,string] = "propper_skins"
        EntVisGroups[EntID,number] = 2
        EntTargets[EntID,string] = SwitchProp
        EntSkins[EntID,array] = TieNoPlateSkins
        EntID++
        
        Entities[EntID,string] = "skin"
        EntClasses[EntID,string] = "propper_skins"
        EntVisGroups[EntID,number] = 2
        EntTargets[EntID,string] = SwitchProp
        EntSkins[EntID,array] = TiePlateSkins
        EntID++

    }
    
    
    StartingBrushID = maxBrushID()
    if(StartingBrushID==0){StartingBrushID = 1}
    
    if(SwitchCompileStep==3){ #Done with main ref mesh, proceed to div
        SwitchCompileStep = 4
        jprint("Repeating for Diverging-thrown switch mesh...")
        timer(".makebrushes",100)
    }elseif(SwitchCompileStep==6){ #Done with div ref mesh, proceed to phys meshes
        SwitchCompileStep = 7
        timer(".makebrushes phys",100)
    }else{
        jprint("Something went wrong!")
    }
    
}elseif(clk("plotsingleties_single")){
    #Normal Piece: Plot all the single ties.
    #Switch Pieces: Plot all the single ties AFTER the switch ties.
    StP = array()
    StEs = array()
    StFs = array()
    StA = array()
    StSegTypes = array()
    local StMakeTies = 0
    local MyMinZ = 0
    StStartSeg = 1
    #print("MN: "+MN_MinZ+", DV: "+DV_MinZ)
    
    #If a switch, only does the MN piece's ties since they are persisted so the DV piece gets them automatically (hence 1 & 2)
    if(SwitchCompileStep==0){ #Whole Piece, Normal
        StP = Plots[SelectedTrack,array]
        local JL = JointsLists[SelectedTrack,table]
        StEs = JL["E",array]
        StFs = JL["F",array]
        StSegTypes = SegTypeLists[SelectedTrack,array]
        StMakeTies = 1
        StEndSeg = StP:count()
        if(BezXovers[SelectedTrack,number]){StEndSeg = ceil(StEndSeg/2)}
    }elseif(SwitchCompileStep==1){ #MN's MN Ties
        local MN = SwitchMainPiece[SelectedTrack,number]
        StP = Plots[MN,array]
        local JL = JointsLists[MN,table]
        StEs = JL["E",array]
        StFs = JL["F",array]
        StSegTypes = SegTypeLists[MN,array]
        StMakeTies = 1
        MyMinZ = MN_MinZ
        StStartSeg = MN_MinZ_Seg
        StEndSeg = StP:count()
        if(BezXovers[MN,number]){StEndSeg = ceil(StEndSeg/2)}
    }elseif(SwitchCompileStep==2){ #MN's DV Ties
        local DV = SwitchDivPiece[SelectedTrack,number]
        StP = Plots[DV,array]
        local JL = JointsLists[DV,table]
        StEs = JL["E",array]
        StFs = JL["F",array]
        StSegTypes = SegTypeLists[DV,array]
        StMakeTies = 1
        MyMinZ = DV_MinZ
        StStartSeg = DV_MinZ_Seg
        StEndSeg = StP:count()
        if(BezXovers[DV,number]){StEndSeg = ceil(StEndSeg/2)}
    }
    if(StMakeTies){
        
        
        StDistances = array()
        StMaxZ = 0
        
        #Record Start Point Angle
        StA[StStartSeg-1,angle] = -ang(0, bearing(vec(),ang(),StP[StStartSeg,vector]-StP[StStartSeg-1,vector]), 0)
        
        for(N=StStartSeg,StEndSeg){
            local Far = StP[N,vector]
            local Near = StP[N-1,vector]
            local Dist = (Far-Near):length()
            StMaxZ = StDistances[N,number] = Dist + StDistances[N-1,number]
            if(N<StEndSeg){
                local NA = (StP[N+1,vector] - StP[N,vector]):normalized()
                local NB = (StP[N,vector] - StP[N-1,vector]):normalized()
                StA[N,angle] = -ang(0, bearing(vec(),ang(),NA+NB), 0)
            }
        }
        
        #Record End Point Angle
        StA[StEndSeg,angle] = -ang(0, bearing(vec(),ang(),StP[StEndSeg,vector]-StP[StEndSeg-1,vector]), 0)
        
        #printTable(StA)
        
        SingleTieZ = ceil(MyMinZ + TieSeparation/2)
        #print(SingleTieZ)
        
        local ZRange = StMaxZ - SingleTieZ - TieSeparation/2
        local NumTies = floor(ZRange/TieSeparation)
        #print(ZRange, TieSeparation, NumTies)
        if(NumTies<=0){ #Skip Single Tie Gen
            if((StMaxZ > TieSeparation) & (StStartSeg==1)){ #There should be only one tie
                timer("plotsingleties_one",100)
            }else{
                timer("plotsingleties_finish",100)
            }
        }elseif(NumTies==1){
            timer("plotsingleties_one",100)
        }else{
            StStep = ZRange/NumTies
            #print(NumTies + " Ties, avg separation "+StStep)
            timer("plotsingleties_loop",100)
        }
    }else{
        timer("plotsingleties_finish",100)
    }
}elseif(clk("plotsingleties_loop")){
    #0 for Not a Switch
    #1 for MN's MN normal
    #2 for MN's DV normal
    #3 for MN's Blended
    #4 for DV's MN normal
    #5 for DV's DV normal
    #6 for DV's Blended
    #7 for MN Phys MN
    #8 for MN Phys DV
    #9 for DV Phys MN
    #10 for DV Phys DV
    
    #while(SingleTieZ<StMaxZ){
    local HeightAdjust = TieTopHeight-BallastHeight
    while(perf()){
        
        local OnSeg = StStartSeg
        for(N=StStartSeg,StEndSeg){
            if(SingleTieZ>=StDistances[N,number]){
                OnSeg++
            }
        }
        local Far = StP[OnSeg,vector]
        local Near = StP[OnSeg-1,vector]
        local DistIn = SingleTieZ-StDistances[OnSeg-1,number]
        
        local DistNorm = DistIn/(Far-Near):length() #0 to 1 progress along segment
        local LeftAnchor = StEs[OnSeg-1,vector] + DistNorm*(StEs[OnSeg,vector] - StEs[OnSeg-1,vector])
        local RightAnchor = StFs[OnSeg-1,vector] + DistNorm*(StFs[OnSeg,vector] - StFs[OnSeg-1,vector])
        local RollAng = -elevation(LeftAnchor,ang(),RightAnchor)
        local Point = (Near + (DistIn)*ax(Near,Far)):setZ((LeftAnchor:z()+RightAnchor:z())/2 + HeightAdjust)
        local Angle = ang()
        
        if(InterpolateTies){
            local PrevAngle = StA[OnSeg-1,angle]
            local NextAngle = StA[OnSeg,angle]
            Angle = PrevAngle + DistNorm*angnorm(NextAngle - PrevAngle)
        }else{
            Angle = -ang(0,bearing(vec(),ang(),Far-Near),0)
        }
        Angle = Angle:rotateAroundAxis(Angle:forward(),RollAng)
        if(!SMDQC & (abs(RollAng)>1)){Point += vec(0,0,Scale)} #Adjust for height if you're not using SMD compile
        local SType = StSegTypes[OnSeg,number]

        STC++
        SingleTieCenters[STC,vector] = Point
        SingleTieAngles[STC,angle] = Angle
        
        SingleTieHeights[STC,number] = (Near + DistIn*ax(Near,Far)):z()
        
        #print(Point)
        #debugHolo(vec2(Point),vec(255,0,0),1)
        
        SingleTieZ += StStep #TieSeparation
        if(SingleTieZ>=StMaxZ){
            #print("Last Tie at: "+(SingleTieZ-StStep)+"/"+StMaxZ)
            break
        }
    }
    #print(SingleTieZ, StMaxZ, StStep)
    if(SingleTieZ>=StMaxZ){ #Done!
        timer("plotsingleties_finish",100)
    }else{
        timer("plotsingleties_loop",100)
    }
    
}elseif(clk("plotsingleties_one")){ #For short straight pieces that just need one single tie
    local HeightAdjust = TieTopHeight-BallastHeight
    
    local OnSeg = StStartSeg
    local Far = StP[OnSeg,vector]
    local Near = StP[OnSeg-1,vector]
    
    local LeftAnchor = 0.5*StEs[OnSeg-1,vector] + 0.5*StEs[OnSeg,vector]
    local RightAnchor = 0.5*StFs[OnSeg-1,vector] + 0.5*StFs[OnSeg,vector]
    
    local Point = (0.5*Near + 0.5*Far):setZ((LeftAnchor:z()+RightAnchor:z())/2 + HeightAdjust)
    
    STC++
    SingleTieCenters[STC,vector] = Point
    SingleTieAngles[STC,angle] = StA[OnSeg-1,angle]
    
    SingleTieHeights[STC,number] = (0.5*Near + 0.5*Far):z()
    #print("Plotted Single Tie, ",Point)
    timer("plotsingleties_finish",100)
}elseif(clk("plotsingleties_finish")){
    if(SwitchCompileStep==0){
        TieID = 1
        #printTable(SingleTieAngles)
        timer("buildsingleties",100)
    }elseif((SwitchCompileStep==1)|(SwitchCompileStep==4)){ #finished MN normal brushes - move on to DV normal
        SwitchCompileStep++
        timer(".makebrushes",100)
    }elseif((SwitchCompileStep==2)|(SwitchCompileStep==5)){ #finished DV normal brushes - move on to MN blended
        SwitchCompileStep++
        SegID = 1
        
        local MN = SwitchMainPiece[SelectedTrack,number]
        local DV = SwitchDivPiece[SelectedTrack,number]
        
        SWP_MN = Plots[MN,array]
        SWP_DV = Plots[DV,array]
        if(MakeBallast==2){
            timer("fuserails",100)
        }else{
            jprint("Building sewed ballast...")
            timer("makebrushes_mn",100)
        }
    }
    
}elseif(clk("makemarkerbrushes")){ #Finalize this entity
    local Hgt = -OriginHeight + BallastHeight/2
    BrushStrings:buildMarkerBrushes(Plots[SelectedTrack,array],Textures)
    
    EntBrushMins[EntID,number] = StartingBrushID #Set the starting and ending Brush IDs for this entity
    EntBrushMaxs[EntID,number] = maxBrushID()-1
    Entities[EntID,string] = TrackNames[SelectedTrack,string] #Set Entity name and class
    EntClasses[EntID,string] = "propper_model"
    EntVisGroups[EntID,number] = 0
    EntID++
    
    local Prop = Entities[EntID-1,string]
    
    #Skins
    Entities[EntID,string] = "skin"
    EntClasses[EntID,string] = "propper_skins"
    EntVisGroups[EntID,number] = 0
    EntTargets[EntID,string] = Prop
    EntSkins[EntID,array] = BallastSkins
    EntID++
    
    Entities[EntID,string] = "skin"
    EntClasses[EntID,string] = "propper_skins"
    EntVisGroups[EntID,number] = 0
    EntTargets[EntID,string] = Prop
    EntSkins[EntID,array] = (RidiculousTies==1) ? BallastTrackbedSkins : BallastTiesSkins
    EntID++
    
    if(RidiculousTies==1){
        Entities[EntID,string] = "skin"
        EntClasses[EntID,string] = "propper_skins"
        EntVisGroups[EntID,number] = 0
        EntTargets[EntID,string] = Prop
        EntSkins[EntID,array] = TiesSkins
        EntID++
    }
    
    if(RidiculousTies>1){
        Entities[EntID,string] = "skin"
        EntClasses[EntID,string] = "propper_skins"
        EntVisGroups[EntID,number] = 0
        EntTargets[EntID,string] = Prop
        EntSkins[EntID,array] = TieNoPlateSkins
        EntID++
    }
    if(RidiculousTies==3){
        Entities[EntID,string] = "skin"
        EntClasses[EntID,string] = "propper_skins"
        EntVisGroups[EntID,number] = 0
        EntTargets[EntID,string] = Prop
        EntSkins[EntID,array] = TiePlateSkins
        EntID++
    }
    
    BrushWriteStep = 0 #0 = Initialize Segment, 1 = Build Brush, 3 = Finish
    InternalBrushID = -1 #negative number for making phys meshes
    SegID = 1
    StartingBrushID = maxBrushID()
    if(StartingBrushID==0){StartingBrushID = 1}
    jprint("Reference Brushes Done! Building Physics Brushes...")
    
    timer("makebrush",100)
}elseif(clk("makemarkermeshes")){ #SMDQC is 1
    
    if(SwitchCompileStep==0){ #Normal Piece, add two at the ends
        buildMarkerMeshes(Plots[SelectedTrack,array],Textures)
    }else{ #Switch
        local MN = SwitchMainPiece[SelectedTrack,number]
        local DV = SwitchDivPiece[SelectedTrack,number]
        local PMN = Plots[MN,array]
        local PDV = Plots[DV,array]
        
        buildSingleMarkerMesh(vec2(PMN[0,vector]),Textures)
        buildSingleMarkerMesh(vec2(PMN[PMN:count(),vector]),Textures)
        buildSingleMarkerMesh(vec2(PDV[PDV:count(),vector]),Textures)
    }
    
    timer("smooth_init",100)
}elseif(clk("smooth_init")){
    #Begin Smoothing
    PolyGroupKeys = PolyGroups:keys()
    #printTable(PolyGroupKeys)
    NumPolyGroups = PolyGroupKeys:count()
    PolyGroupID = 1
    SMD_Text = smd_header(AnimateSwitches & (SwitchCompileStep>0)) #Initialize SMD file
    jprint("Beginning Smoothing...")
    timer("startsmooth_polygroup",100)
}elseif(clk("startsmooth_polygroup")){
    ActivePolyGroup = PolyGroups[PolyGroupKeys[PolyGroupID,string],table]
    SmoothPolyID = 1
    jprint("Processing PolyGroup: "+PolyGroupID+"/"+NumPolyGroups+", '"+PolyGroupKeys[PolyGroupID,string]+"', "+(ActivePolyGroup[0,number]-1)+" triangles.")
    SMD_Text += "\n//"+PolyGroupKeys[PolyGroupID,string]
    #printTable(ActivePolyGroup)
    local PolyCount = ActivePolyGroup[0,number]
    if(PolyCount>6000){
        SmoothSpeed = 1
    }elseif(PolyCount>4000){
        SmoothSpeed = 3
    }elseif(PolyCount>2000){
        SmoothSpeed = 5
    }else{
        SmoothSpeed = 7
    }
    
    timer("smoothcompare",100)
    
}elseif(clk("smoothcompare")){
    if(PolyGroupKeys[PolyGroupID,string]=="none"){ #Snap but don't smooth. Super Cheap, do a shit ton at once
        for(N=SmoothPolyID,min(ActivePolyGroup[0,number]-1,SmoothPolyID+SmoothSpeed)){
            local MyPoly = ActivePolyGroup[SmoothPolyID,table]
            for(M=1,3){
                MyPoly["Verts",array][M,vector] = round(MyPoly["Verts",array][M,vector],2)
            }
            MyPoly:texPoly(0)
            SMD_Text += smd_writepoly(MyPoly)
            SmoothPolyID = N+1
            
        }
    }elseif(PolyGroupKeys[PolyGroupID,string]:left(4)=="phys"){ #Physics Smoothing - can still do faster
        for(N=SmoothPolyID,min(ActivePolyGroup[0,number]-1,SmoothPolyID+3)){
            local MyPoly = ActivePolyGroup[SmoothPolyID,table]
            for(SmoothVertID=1,3){
                local Vertex = round(MyPoly["Verts",array][SmoothVertID,vector],2)
                MyPoly["Verts",array][SmoothVertID,vector] = Vertex #Snap to Grid
                local SmoothTable = Vertex:compareVerts(ActivePolyGroup)
                ActivePolyGroup:smoothVerts(SmoothTable)
            }
            MyPoly:texPoly(1)
            SMD_Text += smd_writepoly(MyPoly)
            SmoothPolyID = N+1
        }
    }else{ #Regular Smoothing, one polygon at a time
        local MyPoly = ActivePolyGroup[SmoothPolyID,table]
        for(SmoothVertID=1,3){
            local Vertex = round(MyPoly["Verts",array][SmoothVertID,vector],2)
            MyPoly["Verts",array][SmoothVertID,vector] = Vertex #Snap to Grid
            local SmoothTable = Vertex:compareVerts(ActivePolyGroup)
            ActivePolyGroup:smoothVerts(SmoothTable)
        }
        MyPoly:texPoly(0)
        SMD_Text += smd_writepoly(MyPoly)
        SmoothPolyID++
    }
    
    if(SmoothPolyID==ActivePolyGroup[0,number]){ #End of Poly Group
        PolyGroupID++
        if(PolyGroupID>NumPolyGroups){ #Done with this SMD! Cap it off and write it!
            SMD_Text += smd_end()
            timer("write_smd",100)
        }else{ #Next Poly group
            timer("startsmooth_polygroup",100)
        }
        hitSound()
    }else{
        timer("smoothcompare",100)
    }
    
}elseif(clk("write_smd")){
    if((fileCanWrite() | BufferWrite) & !FileExpecting){
        local Filename = (AutoVMFName ? TrackNames[SelectedTrack,string] : VMFName)+SMD_Tag #TO DO, rename this to match individual mesh name
        if(BufferWrite){
            filePush("johnhenry_out_smd/"+Filename+".txt",SMD_Text)
        }else{
            fileWrite("johnhenry_out_smd/"+Filename+".txt",SMD_Text)
        }
        jprintf("Wrote SMD.")
        smd_clear()
        switch(SMD_Tag){
            case "_ref", #End of regular ref mesh - do phys
                BrushWriteStep = 0 #0 = Initialize Segment, 1 = Build Brush, 3 = Finish
                InternalBrushID = -1 #negative number for making phys meshes
                SegID = 1
                SMD_Tag = "_phys"
                jprint("Reference Mesh Done! Building Physics Mesh...")
                timer("makebrush",100)
            break
            case "_phys", #End of regular phys mesh
                jprintf("Writing QC...")
                timer("write_qc",4000)
            break
            case "_mn_ref",
                SwitchCompileStep = 4
                jprint("Repeating for Diverging-thrown switch mesh...")
                timer(".makebrushes",100)
            break
            case "_dv_ref",
                SwitchCompileStep = 7
                timer(".makebrushes phys",100)
            break
            case "_mn_phys",
                jprintf("Writing QC...")
                timer("write_qc_mn",4000)
            break
            case "_dv_phys", #End of diverging phys mesh
                jprintf("Writing QC...")
                timer("write_qc_dv",4000)
            break
        }
    }else{
        cprint("Waiting for file to finish...")
        timer("write_smd",500)
    }
    
}elseif(clk("write_qc")){ #Regular Track Only
    if((fileCanWrite() | BufferWrite) & !FileExpecting){
        local SkinTable = table()
        switch(RidiculousTies){
            case 0, #Composite
                SkinTable = table(BallastSkins,BallastTiesSkins)
            break
            case 1, #Tie Plane
                SkinTable = table(BallastSkins,BallastTrackbedSkins,TiesSkins)
            break
            case 2, #2.5D
                SkinTable = table(BallastSkins,BallastTrackbedSkins,TiePlateSkins)
            break
            case 3, #3D
                SkinTable = table(BallastSkins,BallastTrackbedSkins,TiePlateSkins,TieNoPlateSkins)
            break
        }
        local Filename = (AutoVMFName ? TrackNames[SelectedTrack,string] : VMFName)
        local QC_Text = qc(Filename,Scale,SkinTable,array(),0)
        if(BufferWrite){
            filePush("johnhenry_out_smd/"+Filename+"_qc.txt",QC_Text)
        }else{
            fileWrite("johnhenry_out_smd/"+Filename+"_qc.txt",QC_Text)
        }
        
        jprintf("Done! File saved as e2files/johnhenry_out_smd/"+Filename+"_qc.txt.")
        
        soundPlay(0,1,"player/taunt_bumpkins_banjo_music_stop.wav")
        timer("endtaunt",1000)
    }else{
        cprint("Waiting for file to finish...")
        timer("write_qc",500)
    }
}elseif(clk("write_qc_mn")){ #Switch
    if((fileCanWrite() | BufferWrite) & !FileExpecting){
        local SkinTable = table()
        switch(RidiculousTies){
            case 0, #Composite
                SkinTable = table(BallastSkins,BallastTiesSkins,BallastTrackbedSkins,TiePlateSkins,TieNoPlateSkins)
            break
            case 1, #Tie Plane
                SkinTable = SkinTable = table(BallastSkins,BallastTrackbedSkins,TiesSkins,TiePlateSkins,TieNoPlateSkins)
            break
            case 2, #2.5D
            case 3, #3D
                SkinTable = table(BallastSkins,BallastTrackbedSkins,TiePlateSkins,TieNoPlateSkins)
            break
        }
        local Filename = (AutoVMFName ? TrackNames[SelectedTrack,string] : VMFName)+"_mn"
        local Atts = array(smd_attachment("frog1",FrogPos),smd_attachment("bladecenter1",BladeCenter))
        if(!WholeSwitchXover){Atts:pushString(smd_attachment("autopoint1",AutoPointDV))}
        local QC_Text = qc(Filename,Scale,SkinTable,Atts,AnimateSwitches)
        if(BufferWrite){
            filePush("johnhenry_out_smd/"+Filename+"_qc.txt",QC_Text)
        }else{
            fileWrite("johnhenry_out_smd/"+Filename+"_qc.txt",QC_Text)
        }
        jprintf("File saved as e2files/johnhenry_out_smd/"+Filename+"_qc.txt.")
        timer("write_anim_mn",AnimateSwitches ? 1000 : 100)
    }else{
        cprint("Waiting for file to finish...")
        timer("write_qc_mn",500)
    }
}elseif(clk("write_anim_mn")){
    if((fileCanWrite() | BufferWrite) & !FileExpecting){
        if(AnimateSwitches){
            local Filename = (AutoVMFName ? TrackNames[SelectedTrack,string] : VMFName)+"_mn"
            if(BufferWrite){
                filePush("johnhenry_out_smd/"+Filename+"_throw.txt",smd_anim(ThrowAxisMN*SwitchThrow))
            }else{
                fileWrite("johnhenry_out_smd/"+Filename+"_throw.txt",smd_anim(ThrowAxisMN*SwitchThrow))
            }
            jprintf("Saved Animation as johnhenry_out_smd/"+Filename+"_throw.txt.")    
        }
        SwitchCompileStep = 9
        timer(".makebrushes phys",100)
    }else{
        cprint("Waiting for file to finish...")
        timer("write_anim_mn",500)
    }
}elseif(clk("write_qc_dv")){ #Switch
    if((fileCanWrite() | BufferWrite) & !FileExpecting){
        local SkinTable = table()
        switch(RidiculousTies){
            case 0, #Composite
                SkinTable = table(BallastSkins,BallastTiesSkins,BallastTrackbedSkins,TiePlateSkins,TieNoPlateSkins)
            break
            case 1, #Tie Plane
                SkinTable = SkinTable = table(BallastSkins,BallastTrackbedSkins,TiesSkins,TiePlateSkins,TieNoPlateSkins)
            break
            case 2, #2.5D
            case 3, #3D
                SkinTable = table(BallastSkins,BallastTrackbedSkins,TiePlateSkins,TieNoPlateSkins)
            break
        }
        local Filename = (AutoVMFName ? TrackNames[SelectedTrack,string] : VMFName)+"_dv"
        local QC_Text = qc(Filename,Scale,SkinTable,array(smd_attachment("autopoint1",AutoPointMN),smd_attachment("frog1",FrogPos),smd_attachment("bladecenter1",BladeCenter)),AnimateSwitches)
        if(BufferWrite){
            filePush("johnhenry_out_smd/"+Filename+"_qc.txt",QC_Text)
        }else{
            fileWrite("johnhenry_out_smd/"+Filename+"_qc.txt",QC_Text)
        }
        
        jprintf("File saved as e2files/johnhenry_out_smd/"+Filename+"_qc.txt.")
        timer("write_anim_dv",AnimateSwitches ? 1000 : 100)
    }else{
        cprint("Waiting for file to finish...")
        timer("write_qc_dv",500)
    }
}elseif(clk("write_anim_dv")){
    if((fileCanWrite() | BufferWrite) & !FileExpecting){
        if(AnimateSwitches){
            local Filename = (AutoVMFName ? TrackNames[SelectedTrack,string] : VMFName)+"_dv"
            if(BufferWrite){
                filePush("johnhenry_out_smd/"+Filename+"_throw.txt",smd_anim(ThrowAxisDV*SwitchThrow))
            }else{
                fileWrite("johnhenry_out_smd/"+Filename+"_throw.txt",smd_anim(ThrowAxisDV*SwitchThrow))
            }
            
            jprintf("Saved Animation as johnhenry_out_smd/"+Filename+"_throw.txt.")    
        }
        
        soundPlay(0,1,"player/taunt_bumpkins_banjo_music_stop.wav")
        timer("endtaunt",1000)
    }else{
        cprint("Waiting for file to finish...")
        timer("write_anim_dv",500)
    }
}elseif(clk("compile")){ #Put together the completed brushes into entities and add into VMF text
    #What am I going to need in order to compile a list of entities:
    
    #An array of brush strings by Brush ID
    #A table of brush entity ownership by Ent ID -> array of all Brush IDs in that entity
    #An array of entity names by Ent ID
    #An array of entity classes by Ent ID
    
    local Exit = 0 #Flag for ending compile
    
    if(CompileStep==0){ #Initialize Compilation for Entity
        
        local EntClass = EntClasses[EntID,string]
        
        if(EntClass=="propper_model" | EntClass=="func_brush"){ #Brush entity, initialize brush addition
            BID = EntBrushMins[EntID,number] #Set the Starting Brush ID for this entity
            MaxBID = EntBrushMaxs[EntID,number] #Get the Ending Brush ID for this entity
            EntString = ""
            CompileStep = 1
            jprint("Starting Entity "+EntID+": "+Entities[EntID,string]+" (Brush IDs "+BID+" to "+MaxBID+")!")
        }else{
            CompileStep = 2 #Point Entity, skip to addition step
        }
        
    }elseif(CompileStep==1){ #Add the next Brush to Entity
        for(N=1,10){ #Do this 10 times:
            EntString += BrushStrings[BID,string] #Add selected brush string to entity contents

            if(BID==MaxBID){ #Move on to next step if all brushes are done for this entity
                CompileStep = 2
                break
            }else{
                BID++ #Otherwise move on to next brush
            }
        }
        
    }elseif(CompileStep==2){ #Add completed entity to VMF Text
        
        local EntName = Entities[EntID,string] #Get Entity Name
        local EntClass = EntClasses[EntID,string] #Get Entity Class
        local EntVG = EntVisGroups[EntID,number]
        if(EntClass=="propper_model"){ #Add Completed Entity to VMF Text
            MasterString = MasterString + propper_model(EntID,EntName,Scale,EntString,EntVG)
        }elseif(EntClass=="func_brush"){
            MasterString = MasterString + func_brush(EntID,EntName,EntString,EntVG)
        }elseif(EntClass=="propper_attachment"){
            local EntTarget = EntTargets[EntID,string]
            local EntPos = EntOrigins[EntID,vector]
            MasterString = MasterString + propper_attachment(EntID,EntName,EntTarget,EntPos,EntVG)
        }elseif(EntClass=="propper_skins"){
            local EntTarget = EntTargets[EntID,string]
            local EntSkin = EntSkins[EntID,array]
            MasterString = MasterString + propper_skins(EntID,EntTarget,EntSkin,EntVG)
        }
        
        jprint("Added entity "+EntID+", "+EntClass+" \""+EntName+"\" to VMF.")
        
        if(EntID==Entities:count()){ #Finish Compiling if all entities are done for this VMF
            CompileStep = 3
        }else{ #Otherwise move on to next entity
            EntID++
            CompileStep = 0
        }
        
    }elseif(CompileStep==3){ #Finish up the VMF text so you can save it
        MasterString = MasterString + endBlocks() #Attach end blocks to VMF string
        
        Exit = 1
    }
    if(Exit){ #Are we done?
        local Filename = (AutoVMFName ? TrackNames[SelectedTrack,string] : VMFName)
        jprintf("Done! File saved as e2files/johnhenry_out_vmf/"+Filename+".txt.")
        soundPlay(0,1,"player/taunt_bumpkins_banjo_music_stop.wav")
        if(BufferWrite){
            filePush("johnhenry_out_vmf/"+Filename+".txt",MasterString)
        }else{
            fileWrite("johnhenry_out_vmf/"+Filename+".txt",MasterString)
        }
        timer("endtaunt",1000)
    }else{ #Otherwise continue with next iteration
        timer("compile",100)
    }
    
    
}elseif(clk("endtaunt")){
    
    local Sounds = array(
        "vo/engineer_sentryplanting03.mp3",
        "vo/engineer_specialcompleted01.mp3",
        "vo/engineer_specialcompleted02.mp3",
        "vo/engineer_specialcompleted06.mp3",
        "vo/engineer_specialcompleted08.mp3",
        "vo/engineer_autocappedintelligence01.mp3"
    )
    
    local CompileTime = round(curtime()-CompileStartTime,2)
    jprintf("Total Compile Time: "+CompileTime+" seconds!")
    
    local Snd = Sounds[randint(1,Sounds:count()),string]
    vocalize(Snd)
    
    if(AutoVon){
        timer("vonreset",2000)
    }
    #print("STC "+STC)
    #printTable(SingleTieCenters)
    # printTable(EntVisGroups)
    
}elseif(clk("vonreset")){
    reset()
    exit()
}elseif(clk("visualize")){
    local TrackID = SelectedTrack
    local Type = TrackTypes[TrackID,string]
    local Points = Plots[TrackID,array]
    local Height = 0
    if(Type=="straight"){
        Height = StraightHeight[TrackID,number]
    }elseif(Type=="arc"){
        Height = ArcHeight[TrackID,number]
    }elseif(Type=="bezier"){
        Height = BezHeight[TrackID,number]
    }
    #local BasePoint = entity():pos() + vec(0,0,64)
    for(N=0,Points:count()){
        local Z = Points[N,vector]:z()
        holoCreate(N,E:toWorld(Points[N,vector]),vec(1),ang(),heightColor(Z,Height),"models/editor/axis_helper_thick.mdl")
        #holoAlpha(N,191)
        holoMaterial(N,"models/debug/debugwhite")
        holoParent(N,E)
    }
    jprint("Visualized Plot with Holos.")
    
    
}elseif(clk("draw")){
    local RopeWidth = 1 #(DivSegmentOverlap[DrawSeg,number]==0) ? 3 : 1
    local RopeWidth2 = RopeWidth
    local RopeMat = "cable/cable"
    local RopeMat2 = "cable/cable"
    #"cable/cable
    #cable/physbeam
    #cable/redlaser
    
    #Draw Parallel
    
    rope(RopeIndex,E,DA[DrawSeg-1,vector]/Scale,DrawAnchor,DA[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DB[DrawSeg-1,vector]/Scale,DrawAnchor,DB[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DC[DrawSeg-1,vector]/Scale,DrawAnchor,DC[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DD[DrawSeg-1,vector]/Scale,DrawAnchor,DD[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DE[DrawSeg-1,vector]/Scale,DrawAnchor,DE[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DF[DrawSeg-1,vector]/Scale,DrawAnchor,DF[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DG[DrawSeg-1,vector]/Scale,DrawAnchor,DG[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DH[DrawSeg-1,vector]/Scale,DrawAnchor,DH[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DI[DrawSeg-1,vector]/Scale,DrawAnchor,DI[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DJ[DrawSeg-1,vector]/Scale,DrawAnchor,DJ[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DK[DrawSeg-1,vector]/Scale,DrawAnchor,DK[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DL[DrawSeg-1,vector]/Scale,DrawAnchor,DL[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DM[DrawSeg-1,vector]/Scale,DrawAnchor,DM[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat,1)
    RopeIndex++
    rope(RopeIndex,E,DN[DrawSeg-1,vector]/Scale,DrawAnchor,DN[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat,1)
    RopeIndex++
    
    #Draw Cross Section
    
    #          K M      N L
    #          G I      J H
    #       E----------------F
    #   /   |                |   \
    # A-----C----------------D-----B
    if(!DrawCheap){
        rope(RopeIndex,E,DA[DrawSeg-1,vector]/Scale,DrawAnchor,DC[DrawSeg-1,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DA[DrawSeg-1,vector]/Scale,DrawAnchor,DE[DrawSeg-1,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DE[DrawSeg-1,vector]/Scale,DrawAnchor,DC[DrawSeg-1,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        
        rope(RopeIndex,E,DF[DrawSeg-1,vector]/Scale,DrawAnchor,DB[DrawSeg-1,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DF[DrawSeg-1,vector]/Scale,DrawAnchor,DD[DrawSeg-1,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DD[DrawSeg-1,vector]/Scale,DrawAnchor,DB[DrawSeg-1,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        
        rope(RopeIndex,E,DE[DrawSeg-1,vector]/Scale,DrawAnchor,DF[DrawSeg-1,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DC[DrawSeg-1,vector]/Scale,DrawAnchor,DD[DrawSeg-1,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        
        rope(RopeIndex,E,DG[DrawSeg-1,vector]/Scale,DrawAnchor,DK[DrawSeg-1,vector]/Scale,0,RopeWidth2,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DK[DrawSeg-1,vector]/Scale,DrawAnchor,DM[DrawSeg-1,vector]/Scale,0,RopeWidth2,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DM[DrawSeg-1,vector]/Scale,DrawAnchor,DI[DrawSeg-1,vector]/Scale,0,RopeWidth2,RopeMat2,1)
        RopeIndex++
        
        rope(RopeIndex,E,DJ[DrawSeg-1,vector]/Scale,DrawAnchor,DN[DrawSeg-1,vector]/Scale,0,RopeWidth2,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DN[DrawSeg-1,vector]/Scale,DrawAnchor,DL[DrawSeg-1,vector]/Scale,0,RopeWidth2,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DL[DrawSeg-1,vector]/Scale,DrawAnchor,DH[DrawSeg-1,vector]/Scale,0,RopeWidth2,RopeMat2,1)
        RopeIndex++
    }
    
    #print(DA[DrawSeg-1,vector])
    
    if(DrawSeg<DA:count()){
        DrawSeg++
        timer("draw",200)
    }else{
    
        rope(RopeIndex,E,DA[DrawSeg,vector]/Scale,DrawAnchor,DC[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DA[DrawSeg,vector]/Scale,DrawAnchor,DE[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DE[DrawSeg,vector]/Scale,DrawAnchor,DC[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        
        rope(RopeIndex,E,DF[DrawSeg,vector]/Scale,DrawAnchor,DB[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DF[DrawSeg,vector]/Scale,DrawAnchor,DD[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DD[DrawSeg,vector]/Scale,DrawAnchor,DB[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        
        rope(RopeIndex,E,DE[DrawSeg,vector]/Scale,DrawAnchor,DF[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DC[DrawSeg,vector]/Scale,DrawAnchor,DD[DrawSeg,vector]/Scale,0,RopeWidth,RopeMat2,1)
        RopeIndex++
        
        rope(RopeIndex,E,DG[DrawSeg,vector]/Scale,DrawAnchor,DK[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DK[DrawSeg,vector]/Scale,DrawAnchor,DM[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DM[DrawSeg,vector]/Scale,DrawAnchor,DI[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat2,1)
        RopeIndex++
        
        rope(RopeIndex,E,DJ[DrawSeg,vector]/Scale,DrawAnchor,DN[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DN[DrawSeg,vector]/Scale,DrawAnchor,DL[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat2,1)
        RopeIndex++
        rope(RopeIndex,E,DL[DrawSeg,vector]/Scale,DrawAnchor,DH[DrawSeg,vector]/Scale,0,RopeWidth2,RopeMat2,1)
        RopeIndex++
        jprint("Drawing Completed!")
    }
    
}elseif(clk("checkoverlap_mn")){ #Compare a main joint against all the div segments
    
    #          K M      N L
    #          G I      J H
    #       E----------------F
    #   /   |                |   \
    # A-----C----------------D-----B
    
    #2-1
    #| |
    #3-4
    
    local JointOverlaps = 0
    for(N=0,NumSegsDV-1){
        if(SwitchSplit[SelectedTrack,string]=="none"){
            local P1 = vec2(JLD_DV[N+1,vector])
            local P2 = vec2(JLC_DV[N+1,vector])
            local P3 = vec2(JLC_DV[N,vector])
            local P4 = vec2(JLD_DV[N,vector])
            
            if(vec2(JLC_MN[OLID,vector]):isInShadow3(P1,P2,P3,P4) | vec2(JLD_MN[OLID,vector]):isInShadow3(P3,P4,P1,P2)){ #Overlaps, Mark the joints
                JointOverlaps = 1
                Jlap_MN[OLID,number] = 1
                Jmap_MN[OLID,number] = OLID+1
                break
            }
        }else{
            local P1 = vec2(JLD_DV[N+1,vector])
            local P2 = vec2(JLC_DV[N+1,vector])
            local P3 = vec2(JLC_DV[N,vector])
            local P4 = vec2(JLD_DV[N,vector])
            
            if(vec2(JLC_MN[OLID,vector]):isInShadow3(P1,P2,P3,P4) | vec2(JLD_MN[OLID,vector]):isInShadow3(P3,P4,P1,P2)){ #Overlaps, Mark the joints
                JointOverlaps = 1
                Jlap_MN[OLID,number] = 1
                Jmap_MN[OLID,number] = N+1
                break
            }
        }
    }
    
    if(!JointOverlaps){
        Jlap_MN[OLID,number] = 0
        Jmap_MN[OLID,number] = -1
    }
    
    OLID++
    if(OLID>NumSegsMN){ #Done with last segment, move on to DV checks
        OLID = 0
        timer("checkoverlap_dv",100)
        
    }else{ #Next MN check
        timer("checkoverlap_mn",100)
    }  
}elseif(clk("checkoverlap_dv")){ #Compare a div joint against all the main segments
    local JointOverlaps = 0
    for(N=0,NumSegsMN-1){
        if(SwitchSplit[SelectedTrack,string]=="none"){
            local P1 = vec2(JLD_MN[N+1,vector])
            local P2 = vec2(JLC_MN[N+1,vector])
            local P3 = vec2(JLC_MN[N,vector])
            local P4 = vec2(JLD_MN[N,vector])
            
            if(vec2(JLC_DV[OLID,vector]):isInShadow3(P1,P2,P3,P4) | vec2(JLD_DV[OLID,vector]):isInShadow3(P3,P4,P1,P2)){ #Overlaps, Mark the joints
                JointOverlaps = 1
                Jlap_DV[OLID,number] = 1
                Jmap_DV[OLID,number] = OLID+1
                #print("Joint "+OLID+" intersects with Segment "+(N+1))
                break
            }
        }else{
            local P1 = vec2(JLD_MN[N+1,vector])
            local P2 = vec2(JLC_MN[N+1,vector])
            local P3 = vec2(JLC_MN[N,vector])
            local P4 = vec2(JLD_MN[N,vector])
            
            if(vec2(JLC_DV[OLID,vector]):isInShadow3(P1,P2,P3,P4) | vec2(JLD_DV[OLID,vector]):isInShadow3(P3,P4,P1,P2)){ #Overlaps, Mark the joints
                JointOverlaps = 1
                Jlap_DV[OLID,number] = 1
                Jmap_DV[OLID,number] = N+1
                #print("Joint "+OLID+" intersects with Segment "+(N+1))
                break
            }
        }
    }
    
    if(!JointOverlaps){
        Jlap_DV[OLID,number] = 0
        Jmap_DV[OLID,number] = -1
    }
    
    OLID++
    if(OLID>NumSegsDV){ #Done with last segment, proceed to segment overlap evaluation
        timer("segmentoverlap",100)
    }else{ #Next DV check
        timer("checkoverlap_dv",100)
    }  
}elseif(clk("segmentoverlap")){
    NumOverlapsMN = 0
    for(N=1,NumSegsMN){ #Calculate Segment Overlap State (Main)
        local Top = Jlap_MN[N,number] #"Top" Overlap
        local Bottom = Jlap_MN[N-1,number] #"Bottom" Overlap
        
        if(Top & Bottom){
            if(N==NumSegsMN){ #Override if last segment
                MainSegmentOverlap[N,number] = 1
            }else{
                MainSegmentOverlap[N,number] = 2
            }
            NumOverlapsMN++
        }elseif(Bottom){
            MainSegmentOverlap[N,number] = 1
            NumOverlapsMN++
        }else{
            MainSegmentOverlap[N,number] = 0
        }
    }
    NumOverlapsDV = 0
    for(N=1,NumSegsDV){ #Calculate Segment overlap state (Diverging)
        local Top = Jlap_DV[N,number] #"Top" Overlap
        local Bottom = Jlap_DV[N-1,number] #"Bottom" Overlap
        
        if(Top & Bottom){
            if(N==NumSegsDV){ #Override if last segment
                DivSegmentOverlap[N,number] = 1
            }else{
                DivSegmentOverlap[N,number] = 2
            }
            NumOverlapsDV++
        }elseif(Bottom){
            DivSegmentOverlap[N,number] = 1
            NumOverlapsDV++
        }else{
            DivSegmentOverlap[N,number] = 0
        }
    }
    
    #Copy all the overlapping segments' verts into new arrays
    Inner_MN = array()
    Outer_MN = array()
    Inner_DV = array()
    Outer_DV = array()
    
    #C---D
    
    if(MainLeft){ 
        for(N=0,NumSegsMN){
            Inner_MN[N,vector2] = vec2(JLD_MN[N,vector])
            Outer_MN[N,vector2] = vec2(JLC_MN[N,vector])
        }
        for(N=0,NumSegsDV){
            Inner_DV[N,vector2] = vec2(JLC_DV[N,vector])
            Outer_DV[N,vector2] = vec2(JLD_DV[N,vector])
        }
    }else{
        for(N=0,NumSegsMN){
            Inner_MN[N,vector2] = vec2(JLC_MN[N,vector])
            Outer_MN[N,vector2] = vec2(JLD_MN[N,vector])
        }
        for(N=0,NumSegsDV){
            Inner_DV[N,vector2] = vec2(JLD_DV[N,vector])
            Outer_DV[N,vector2] = vec2(JLC_DV[N,vector])
        }
    }
    
    Inner_Split = array()
    Outer_Split = array()
    SPLID = 0
    
    timer("findautopoints",100)
    
}elseif(clk("findautopoints")){
    
    local MN = SwitchMainPiece[SelectedTrack,number]
    local DV = SwitchDivPiece[SelectedTrack,number]
    
    local PMN = Plots[MN,array]
    local PDV = Plots[DV,array]
    
    local DMN = (PMN[NumOverlapsMN,vector] - PMN[NumOverlapsMN-1,vector]):normalized()
    local DDV = (PDV[NumOverlapsDV,vector] - PDV[NumOverlapsDV-1,vector]):normalized()
    
    AutoPointMN = round(PMN[NumOverlapsMN,vector] + 64*DMN)
    AutoPointDV = round(PDV[NumOverlapsDV,vector] + 64*DDV)
    
    AutoPointMN:setZ(-OriginHeight + RailTopHeight)
    AutoPointDV:setZ(-OriginHeight + RailTopHeight)
    
    #debugHolo(1,vec2(AutoPointMN),vec(255,0,0),0)
    #debugHolo(2,vec2(AutoPointDV),vec(0,255,0),0)
    
    cprint("Rewriting Ballast Brushes ("+SwitchSplit[SelectedTrack,string]+").")
    timer("split",100)
}elseif(clk("split")){ #The basic splits

    if(SplitMode=="main"){
        local HitSeg = Jmap_DV[SPLID,number]
        local InnerHitPoint = Outer_DV[SPLID,vector2] #Inner_DV[SPLID,vector2]:projectOntoLine(Inner_MN[HitSeg-1,vector2],Inner_MN[HitSeg,vector2])
        local OuterHitPoint = Inner_DV[SPLID,vector2]:projectOntoLine(Outer_MN[HitSeg-1,vector2],Outer_MN[HitSeg,vector2])
        local CenterPoint = round((InnerHitPoint+OuterHitPoint)/2)
        
        Inner_Split[SPLID,vector2] = CenterPoint
        Outer_Split[SPLID,vector2] = round(OuterHitPoint)
        Inner_DV[SPLID,vector2] = CenterPoint
        
        SPLID++
        if(Jlap_DV[SPLID,number]){ #If the next one also needs a split, split it
            timer("split",100)
        }else{ #Otherwise proceed to final triangle
            timer("makefinaltri",100)
        }
    }elseif(SplitMode=="diverging"){
        local HitSeg = Jmap_MN[SPLID,number]
        local InnerHitPoint = Outer_MN[SPLID,vector2] #Inner_MN[SPLID,vector2]:projectOntoLine(Inner_DV[HitSeg-1,vector2],Inner_DV[HitSeg,vector2])
        local OuterHitPoint = Inner_MN[SPLID,vector2]:projectOntoLine(Outer_DV[HitSeg-1,vector2],Outer_DV[HitSeg,vector2])
        local CenterPoint = round((InnerHitPoint+OuterHitPoint)/2)
        
        Inner_Split[SPLID,vector2] = CenterPoint
        Outer_Split[SPLID,vector2] = round(OuterHitPoint)
        Inner_MN[SPLID,vector2] = CenterPoint
        SPLID++
        if(Jlap_MN[SPLID,number]){ #If the next one also needs a split, split it
            timer("split",100)
        }else{ #Otherwise proceed to final triangle
            timer("makefinaltri",100)
        }
    }elseif(SplitMode=="none"){
        local CenterPoint = round((Inner_MN[SPLID,vector2]+Inner_DV[SPLID,vector2])/2)
        #Inner_MN[SPLID,vector2] = CenterPoint
        #Inner_DV[SPLID,vector2] = CenterPoint
        Inner_Split[SPLID,vector2] = CenterPoint
        
        SPLID++
        if(Jlap_DV[SPLID,number] & Jlap_MN[SPLID,number]){ #If the next one also needs a split, split it
            timer("split",100)
        }else{ #Otherwise proceed to final triangle
            timer("makefinaltri",100)
        }
    }
    
    
}elseif(clk("makefinaltri")){
    
    if(SplitMode=="main"){
        
        #Intersection
        
        local HitSeg = Jmap_DV[SPLID-1,number]

        local Line_MN = line(Inner_MN[HitSeg-1,vector2],Inner_MN[HitSeg,vector2]-Inner_MN[HitSeg-1,vector2])
        local Line_DV = line(Inner_DV[SPLID-1,vector2],Inner_DV[SPLID,vector2]-Inner_DV[SPLID-1,vector2])
        
        local Isect = round(intersection(Line_MN,Line_DV)[2,vector2])
        Inner_Split[SPLID,vector2] = Isect
        Outer_Split[SPLID,vector2] = Outer_MN[HitSeg,vector2]
        local HoldThis = Inner_DV[SPLID,vector2]
        Inner_DV[SPLID,vector2] = Isect
        
        #final Tri
        
        local Am = Outer_MN[HitSeg,vector2]
        local Bm = MainLeft ? Isect : Inner_MN[HitSeg,vector2]
        local Cm = MainLeft ? Inner_MN[HitSeg,vector2] : Isect
        
        local Ad = Outer_DV[SPLID,vector2]
        local Bd = MainLeft ? HoldThis : Isect
        local Cd = MainLeft ? Isect : HoldThis
        
        
        
        FinalTri_MN = array(Am,Bm,Cm)
        FinalTri_DV = array(Ad,Bd,Cd)
        
        #Copy Splits to MN
        Inner_MN = Inner_Split:clone()
        Outer_MN = Outer_Split:clone()
        
    }elseif(SplitMode=="div"){
        local HitSeg = Jmap_MN[SPLID-1,number]
        local Line_DV = line(Inner_DV[HitSeg-1,vector2],Inner_DV[HitSeg,vector2]-Inner_DV[HitSeg-1,vector2])
        local Line_MN = line(Inner_MN[SPLID-1,vector2],Inner_MN[SPLID,vector2]-Inner_MN[SPLID-1,vector2])
        
        local Isect = round(intersection(Line_MN,Line_DV)[2,vector2])
        Inner_Split[SPLID,vector2] = Isect
        Outer_Split[SPLID,vector2] = Outer_DV[HitSeg,vector2]
        local HoldThis = Inner_MN[SPLID,vector2]
        Inner_MN[SPLID,vector2] = Isect
        
        local Am = Outer_MN[SPLID,vector2]
        local Bm = MainLeft ? Isect : HoldThis
        local Cm = MainLeft ? HoldThis : Isect
        
        local Ad = Outer_DV[HitSeg,vector2]
        local Bd = MainLeft ? Isect : Inner_DV[HitSeg,vector2]
        local Cd = MainLeft ? Inner_DV[HitSeg,vector2] : Isect
        
        FinalTri_MN = array(Am,Bm,Cm)
        FinalTri_DV = array(Ad,Cd,Bd)
        
        #Copy Splits to DV
        Inner_DV = Inner_Split:clone()
        Outer_DV = Outer_Split:clone()
    }elseif(SplitMode=="none"){
        local Line_MN = line(Inner_MN[SPLID-1,vector2],Inner_MN[SPLID,vector2]-Inner_MN[SPLID-1,vector2])
        local Line_DV = line(Inner_DV[SPLID-1,vector2],Inner_DV[SPLID,vector2]-Inner_DV[SPLID-1,vector2])
        
        local Isect = round(intersection(Line_MN,Line_DV)[2,vector2])
        
        local HoldThisMN = Inner_MN[SPLID,vector2]
        Inner_MN[SPLID,vector2] = Isect
        local HoldThisDV = Inner_DV[SPLID,vector2]
        Inner_DV[SPLID,vector2] = Isect
        
        local Am = Outer_MN[SPLID,vector2]
        local Bm = MainLeft ? Isect : HoldThisMN
        local Cm = MainLeft ? HoldThisMN : Isect
        
        local Ad = Outer_DV[SPLID,vector2]
        local Bd = MainLeft ? Isect : HoldThisDV
        local Cd = MainLeft ? HoldThisDV : Isect
        
        FinalTri_MN = array(Am,Bm,Cm)
        FinalTri_DV = array(Ad,Cd,Bd)
        
        #Copy Splits to Inners
        Inner_MN = Inner_MN:merge(Inner_Split)
        Inner_DV = Inner_DV:merge(Inner_Split)
    }
    cprint("Analyzing Crossties...")
    timer("findTieZ",100)
}elseif(clk("findTieZ")){
    
    local MN = SwitchMainPiece[SelectedTrack,number]
    local DV = SwitchDivPiece[SelectedTrack,number]
    local JLMN = JointsLists[MN,table]
    local JLDV = JointsLists[DV,table]
    
    
    #          K M      N L
    #          G I      J H
    #       E----------------F
    #   /   |                |   \
    # A-----C----------------D-----B
    
    local JLM = JLMN["M",array]
    local JLN = JLMN["N",array]
    Tmap_LMN = array()
    Tmap_RMN = array()
    
    for(N=0,min(BezXovers[MN,number] ? BezSegments[MN,number]/2 : NumOverlapsMN, NumOverlapsMN)){
        local VM = vec2(JLM[N,vector])
        local VN = vec2(JLN[N,vector])
        
        Tmap_LMN[N,number] = round(findZ(CardinalPoint,CardinalDir,VM))
        Tmap_RMN[N,number] = round(findZ(CardinalPoint,CardinalDir,VN))
        
    }
    
    JLM = JLDV["M",array]
    JLN = JLDV["N",array]
    Tmap_LDV = array()
    Tmap_RDV = array()
    
    for(N=0,min(BezXovers[DV,number] ? BezSegments[DV,number]/2 : NumOverlapsDV, NumOverlapsDV)){
        local VM = vec2(JLM[N,vector])
        local VN = vec2(JLN[N,vector])
        
        Tmap_LDV[N,number] = round(findZ(CardinalPoint,CardinalDir,VM))
        Tmap_RDV[N,number] = round(findZ(CardinalPoint,CardinalDir,VN))
        
    }
    
    #print(NumOverlapsMN, NumOverlapsDV)
    
    TC = 0
    CardLine = line(CardinalPoint,CardinalDir)
    PerpDir = CardinalDir:rotate(-90)
    Inset = PerpDir*RailWidth/2
    timer("findplatecenters_lmn",100)
}elseif(clk("findplatecenters_lmn")){
    local Z = TieSeparation/2
    TP_LMN = array()
    local MaxZ = Tmap_LMN:max()
    local RS = 1
    local C = 1
    local Joints = JointsLists[SwitchMainPiece[SelectedTrack,number],table]["M",array]
    #print("Max Z LMN: ",MaxZ)
    while(Z<MaxZ){
        #J| 0-1-2-3-4
        #S| |1|2|3|4|
        
        #find the segment to project onto given Z
        for(N=RS,NumOverlapsMN){
            if(Z>Tmap_LMN[N,number]){
                RS++
            }else{
                break
            }
        }
        #You've got RS now
        #find the projection line
        local ProjPos = CardinalPoint + Z*CardinalDir
        local CrossLine = line(ProjPos,PerpDir)
        #find the segment line
        local JF = vec2(Joints[RS,vector])
        local JN = vec2(Joints[RS-1,vector])
        local RailLine = line(JN,JF-JN)
        
        #Project!
        TP_LMN[C,vector2] = intersection(CrossLine,RailLine)[2,vector2] - Inset
        #debugHolo(C,TP_LMN[C,vector2],vec(255,0,0))
        C++
        if(MainLeft){SegOfTieMN[C-1,number] = RS}
        
        Z += TieSeparation
    }
    #printTable(TP_LMN)
    timer("findplatecenters_rmn",100)
}elseif(clk("findplatecenters_rmn")){
    local Z = TieSeparation/2
    TP_RMN = array()
    local MaxZ = Tmap_RMN:max()
    local RS = 1
    local C = 1
    local Joints = JointsLists[SwitchMainPiece[SelectedTrack,number],table]["N",array]
    #print("Max Z RMN: ",MaxZ)
    while(Z<MaxZ){
        #J| 0-1-2-3-4
        #S| |1|2|3|4|
        
        #find the segment to project onto given Z
        for(N=RS,NumOverlapsMN){
            if(Z>Tmap_RMN[N,number]){
                RS++
            }else{
                break
            }
        }
        #You've got RS now
        #find the projection line
        local ProjPos = CardinalPoint + Z*CardinalDir
        local CrossLine = line(ProjPos,PerpDir)
        #find the segment line
        local JF = vec2(Joints[RS,vector])
        local JN = vec2(Joints[RS-1,vector])
        local RailLine = line(JN,JF-JN)
        
        #Project!
        TP_RMN[C,vector2] = intersection(CrossLine,RailLine)[2,vector2] + Inset
        #debugHolo(C+32,TP_RMN[C,vector2],vec(255,255,0))
        C++
        if(!MainLeft){SegOfTieMN[C-1,number] = RS}
        
        Z += TieSeparation
    }
    
    timer("findplatecenters_ldv",100)
}elseif(clk("findplatecenters_ldv")){
    local Z = TieSeparation/2
    TP_LDV = array()
    local MaxZ = Tmap_LDV:max()
    local RS = 1
    local C = 1
    local Joints = JointsLists[SwitchDivPiece[SelectedTrack,number],table]["M",array]
    #print("Max Z LDV: ",MaxZ)
    while(Z<MaxZ){
        #J| 0-1-2-3-4
        #S| |1|2|3|4|
        
        #find the segment to project onto given Z
        for(N=RS,NumOverlapsDV){
            if(Z>Tmap_LDV[N,number]){
                RS++
            }else{
                break
            }
        }
        #You've got RS now
        #find the projection line
        local ProjPos = CardinalPoint + Z*CardinalDir
        local CrossLine = line(ProjPos,PerpDir)
        #find the segment line
        local JF = vec2(Joints[RS,vector])
        local JN = vec2(Joints[RS-1,vector])
        local RailLine = line(JN,JF-JN)
        
        #Project!
        TP_LDV[C,vector2] = intersection(CrossLine,RailLine)[2,vector2] - Inset
        #debugHolo(C+64,TP_LDV[C,vector2],vec(0,255,0))
        C++
        if(!MainLeft){SegOfTieDV[C-1,number] = RS}
        
        Z += TieSeparation
    }
    timer("findplatecenters_rdv",100)
}elseif(clk("findplatecenters_rdv")){
    local Z = TieSeparation/2
    TP_RDV = array()
    local MaxZ = Tmap_RDV:max()
    local RS = 1
    local C = 1
    local Joints = JointsLists[SwitchDivPiece[SelectedTrack,number],table]["N",array]
    #print("Max Z RDV: ",MaxZ)
    while(Z<MaxZ){
        #J| 0-1-2-3-4
        #S| |1|2|3|4|
        
        #find the segment to project onto given Z
        for(N=RS,NumOverlapsDV){
            if(Z>Tmap_RDV[N,number]){
                RS++
            }else{
                break
            }
        }
        #You've got RS now
        #find the projection line
        local ProjPos = CardinalPoint + Z*CardinalDir
        local CrossLine = line(ProjPos,PerpDir)
        #find the segment line
        local JF = vec2(Joints[RS,vector])
        local JN = vec2(Joints[RS-1,vector])
        local RailLine = line(JN,JF-JN)
        
        #Project!
        TP_RDV[C,vector2] = intersection(CrossLine,RailLine)[2,vector2] + Inset
        #debugHolo(C+96,TP_RDV[C,vector2],vec(0,0,255))
        C++
        if(MainLeft){SegOfTieDV[C-1,number] = RS}
        
        Z += TieSeparation
    }
    #print(TP_LMN:count(),TP_RMN:count(),TP_LDV:count(),TP_RDV:count())
    
    timer("find fusetierange",100)
}elseif(clk("find fusetierange")){
    
    local MaxTie = min(TP_LMN:count(),TP_RMN:count(),TP_LDV:count(),TP_RDV:count())
    #print(MaxTie)
    
    #Find the last single (non-chopped) tie
    LastSingleTie = 1
    for(N=1,MaxTie){
        local P1 = TP_LMN[N,vector2]
        local P2 = TP_LDV[N,vector2]
        if(P1:distance(P2)>2){
            LastSingleTie = N-1
            break
        }
    }
    local RemDist = TieWidth-TiePlateCenter*2
    #Find last fused tie
    LastFusedTie = 1
    local Broke = 0
    for(N=LastSingleTie+1,MaxTie){
        local Start = MainLeft ? TP_LDV[N,vector2] : TP_LMN[N,vector2]
        local End = MainLeft ? TP_RMN[N,vector2] : TP_RDV[N,vector2]
        if((Start:distance(End)>RemDist)&((End-Start):dot(PerpDir)<0)){
            LastFusedTie = N-1
            Broke = 1
            break
        }
    }
    
    local MN = SwitchMainPiece[SelectedTrack,number]
    local DV = SwitchDivPiece[SelectedTrack,number]
    
    if(!Broke & (BezXovers[MN,number] | BezXovers[DV,number])){ #Switch ties go all the way to the end, but it's a crossover and you don't want to leave a huge gap
        LastFusedTie = MaxTie
    }elseif(!Broke){ #Switch ties go all the way to the end and it's a turnout or something - ok to leave a gap
        LastFusedTie = MaxTie-1
    }
    #print("Switch Tie Range: ",LastSingleTie+" to "+LastFusedTie+", out of "+MaxTie+", Crossover "+WholeSwitchXover)
    SingleTieCenters = array()
    SingleTieAngles = array()
    timer("plotsingleties1",100)
}elseif(clk("plotsingleties1")){ #Plot the single ties before the rails start to diverge appreciably
    
    CardinalAng = -heading(vec(),ang(),vec(CardinalDir))
    local THT = -OriginHeight+TieTopHeight
    for(N=1,LastSingleTie){
        SingleTieCenters[N,vector] = vec((TP_LMN[N,vector2]+TP_RDV[N,vector2])/2,THT)
        SingleTieAngles[N,angle] = CardinalAng
        STC++
    }
    #printTable(SingleTieCenters)
    TieID = LastSingleTie+1
    
    PlatePointGroups = table()
    BridgePointGroups = table()
    PlateTexCenters = array()
    BridgeTexCenters = array()
    SideStates = array()
    
    PlateID = 1
    BridgeID = 1
    
    timer("sort_ties",100)
}elseif(clk("sort_ties")){
    
    local F = CardinalDir
    local R = PerpDir
    local PW = TiePlateWidth
    local Extend = (TieWidth/2)-TiePlateCenter

    #Get the plate centers
    
    local PLMN = TP_LMN[TieID,vector2] #1
    local PRMN = TP_RMN[TieID,vector2] #2
    local PLDV = TP_LDV[TieID,vector2] #3
    local PRDV = TP_RDV[TieID,vector2] #4
    
    local Centers = array(PLMN,PRMN,PLDV,PRDV)
    
    #Find "W" coordinates of all plate centers
    
    local A = (PLMN-CardinalPoint):dot(PerpDir)
    local B = (PRMN-CardinalPoint):dot(PerpDir)
    local C = (PLDV-CardinalPoint):dot(PerpDir)
    local D = (PRDV-CardinalPoint):dot(PerpDir)
    
    local Wlist = array(A,B,C,D)
    
    #Sort by W
    local Map = array()
    
    local Order = 1
    if(A>B){Order++}
    if(A>C){Order++}
    if(A>D){Order++}
    Map[Order,number] = 1
    
    Order = 1
    if(B>A){Order++}
    if(B>C){Order++}
    if(B>D){Order++}
    Map[Order,number] = 2
    
    Order = 1
    if(C>B){Order++}
    if(C>A){Order++}
    if(C>D){Order++}
    Map[Order,number] = 3
    
    Order = 1
    if(D>B){Order++}
    if(D>C){Order++}
    if(D>A){Order++}
    Map[Order,number] = 4
    
    
    #Find Overlaps
    local O_12 = (Wlist[Map[2,number],number]-Wlist[Map[1,number],number])<=(PW+4)
    local O_23 = (Wlist[Map[3,number],number]-Wlist[Map[2,number],number])<=(PW+4)
    local O_34 = (Wlist[Map[4,number],number]-Wlist[Map[3,number],number])<=(PW+4)
    
    local P1 = vec2()
    local P2 = vec2()
    local P3 = vec2()
    local P4 = vec2()
    local PC1 = Centers[Map[1,number],vector2]
    local PC2 = Centers[Map[2,number],vector2]
    local PC3 = Centers[Map[3,number],vector2]
    local PC4 = Centers[Map[4,number],vector2]
    
    #2--1
    #3--4
    
    #if(TieID==LastSingleTie+1){print(O_12,O_23,O_34)}
    
    #1st Plate
    
    P1 = vround((O_12 ? (PC1+PC2)/2 : PC1 + R*PW/2)+F*TieThickness/2)
    P2 = vround(PC1 + F*TieThickness/2 - R*Extend)
    P3 = vround(PC1 - F*TieThickness/2 - R*Extend)
    P4 = vround((O_12 ? (PC1+PC2)/2 : PC1 + R*PW/2)-F*TieThickness/2)
    
    PlatePointGroups[PlateID,array] = array(P1,P2,P3,P4)
    PlateTexCenters[PlateID,vector2] = PC1+(((Map[1,number]==1)|(Map[1,number]==3)) ? R*TiePlateCenter : -R*TiePlateCenter)
    SideStates[PlateID,number] = -1
    PlateID++
    
    #2nd Plate
    
    P1 = vround((O_23 ? (PC2+PC3)/2 : PC2 + R*PW/2)+F*TieThickness/2)
    P2 = vround((O_12 ? (PC1+PC2)/2 : PC2 - R*PW/2)+F*TieThickness/2)
    P3 = vround((O_12 ? (PC1+PC2)/2 : PC2 - R*PW/2)-F*TieThickness/2)
    P4 = vround((O_23 ? (PC2+PC3)/2 : PC2 + R*PW/2)-F*TieThickness/2)
    
    PlatePointGroups[PlateID,array] = array(P1,P2,P3,P4)
    PlateTexCenters[PlateID,vector2] = PC2+(((Map[2,number]==1)|(Map[2,number]==3)) ? R*TiePlateCenter : -R*TiePlateCenter)
    SideStates[PlateID,number] = 0
    PlateID++
    
    #3rd Plate
    
    P1 = vround((O_34 ? (PC3+PC4)/2 : PC3 + R*PW/2)+F*TieThickness/2)
    P2 = vround((O_23 ? (PC2+PC3)/2 : PC3 - R*PW/2)+F*TieThickness/2)
    P3 = vround((O_23 ? (PC2+PC3)/2 : PC3 - R*PW/2)-F*TieThickness/2)
    P4 = vround((O_34 ? (PC3+PC4)/2 : PC3 + R*PW/2)-F*TieThickness/2)
    
    PlatePointGroups[PlateID,array] = array(P1,P2,P3,P4)
    PlateTexCenters[PlateID,vector2] = PC3+(((Map[3,number]==1)|(Map[3,number]==3)) ? R*TiePlateCenter : -R*TiePlateCenter)
    SideStates[PlateID,number] = 0
    #debugHolo(PlateID,PlateTexCenters[PlateID,vector2],vec(255,0,0))
    PlateID++
    
    #4th Plate
    
    P1 = vround(PC4 + F*TieThickness/2 + R*Extend)
    P2 = vround((O_34 ? (PC3+PC4)/2 : PC4 - R*PW/2)+F*TieThickness/2)
    P3 = vround((O_34 ? (PC3+PC4)/2 : PC4 - R*PW/2)-F*TieThickness/2)
    P4 = vround(PC4 - F*TieThickness/2 + R*Extend)
    
    PlatePointGroups[PlateID,array] = array(P1,P2,P3,P4)
    PlateTexCenters[PlateID,vector2] = PC4+(((Map[4,number]==1)|(Map[4,number]==3)) ? R*TiePlateCenter : -R*TiePlateCenter)
    SideStates[PlateID,number] = 1
    PlateID++
    
    
    #Bridge Ties
    local PR = array()
    local PL = array()
    
    #Bridge 12
    if(!O_12){
        PR = PlatePointGroups[PlateID-3,array]
        PL = PlatePointGroups[PlateID-4,array]
        P1 = PR[2,vector2]
        P2 = PL[1,vector2]
        P3 = PL[4,vector2]
        P4 = PR[3,vector2]
        BridgePointGroups[BridgeID,array] = array(P1,P2,P3,P4)
        BridgeTexCenters[BridgeID,vector2] = (P1+P2+P3+P4)/4
        BridgeID++
    }
    
    #Bridge 23
    if(!O_23){
        PR = PlatePointGroups[PlateID-2,array]
        PL = PlatePointGroups[PlateID-3,array]
        P1 = PR[2,vector2]
        P2 = PL[1,vector2]
        P3 = PL[4,vector2]
        P4 = PR[3,vector2]
        BridgePointGroups[BridgeID,array] = array(P1,P2,P3,P4)
        BridgeTexCenters[BridgeID,vector2] = (P1+P2+P3+P4)/4
        BridgeID++
    }
    
    #Bridge 34
    if(!O_34){
        PR = PlatePointGroups[PlateID-1,array]
        PL = PlatePointGroups[PlateID-2,array]
        P1 = PR[2,vector2]
        P2 = PL[1,vector2]
        P3 = PL[4,vector2]
        P4 = PR[3,vector2]
        BridgePointGroups[BridgeID,array] = array(P1,P2,P3,P4)
        BridgeTexCenters[BridgeID,vector2] = (P1+P2+P3+P4)/4
        BridgeID++
    }
    
    TieID++
    if(TieID>LastFusedTie){ #Last Switch Tie
        LeftMaxSeg = (MainLeft ? SegOfTieMN : SegOfTieDV)[LastFusedTie,number]
        RightMaxSeg = (!MainLeft ? SegOfTieMN : SegOfTieDV)[LastFusedTie,number]
        #You've got LeftMaxSeg and RightMaxSeg which are the segments where the last ties live.
        local MN = SwitchMainPiece[SelectedTrack,number]
        local DV = SwitchDivPiece[SelectedTrack,number]
        local PMN = Plots[MN,array]
        local PDV = Plots[DV,array]
        
        local NearMN = vec2(PMN[(MainLeft ? LeftMaxSeg : RightMaxSeg)-1,vector])
        local FarMN = vec2(PMN[(MainLeft ? LeftMaxSeg : RightMaxSeg),vector])
        local NearDV = vec2(PDV[(!MainLeft ? LeftMaxSeg : RightMaxSeg)-1,vector])
        local FarDV = vec2(PDV[(!MainLeft ? LeftMaxSeg : RightMaxSeg),vector])
        
        MN_MinZ = ((MainLeft ? PlatePointGroups[PlateID-4,array][2,vector2] : PlatePointGroups[PlateID-1,array][1,vector2]) - NearMN):dot(ax2(NearMN,FarMN)) - TieThickness/2 + TieSeparation/2
        MN_MinZ_Seg = MainLeft ? LeftMaxSeg : RightMaxSeg
        DV_MinZ = ((!MainLeft ? PlatePointGroups[PlateID-4,array][2,vector2] : PlatePointGroups[PlateID-1,array][1,vector2]) - NearDV):dot(ax2(NearDV,FarDV)) - TieThickness/2 + TieSeparation/2
        DV_MinZ_Seg = !MainLeft ? LeftMaxSeg : RightMaxSeg
        #debugHolo(1,PlatePointGroups[PlateID-1,array][1,vector2],vec(255,0,0))
        #MN_MinZ = ((MainLeft ? PC1 : PC4) - NearMN):dot(ax2(NearMN,FarMN))
        #DV_MinZ = ((MainLeft ? PC4 : PC1) - NearDV):dot(ax2(NearDV,FarDV))
        #print(NearMN,FarMN)
        
        cprint("Analyzing rails...")
        timer("???",100)
    }else{
        timer("sort_ties",100)
    }
    
#}elseif(clk("plotsingletiesmn")){ #OBSOLETE - formerly: Plot the single ties between the end of the switch ties and the start of the non-fused ballast segments
    
    #local MN = SwitchMainPiece[SelectedTrack,number]
    #local PMN = Plots[MN,array]
    #local StartSeg = MainLeft ? LeftMaxSeg : RightMaxSeg
    #local EndSeg = NumOverlapsMN
    #local Distances = array()
    #local MaxZ = 0
    
    #for(N=StartSeg,EndSeg){
    #    local Far = PMN[N,vector]
    #    local Near = PMN[N-1,vector]
    #    local Dist = (Far-Near):length()
    #    MaxZ = Distances[N,number] = Dist + Distances[N-1,number]
    #}
    
    #local Z = ceil(MN_MinZ + TieSeparation - TieThickness/2)
    
    #while(Z<MaxZ){
        
    #    local OnSeg = StartSeg
    #    for(N=StartSeg,EndSeg){
    #        if(Z>=Distances[N,number]){
    #            OnSeg++
    #        }
    #    }
    #    local Far = vec2(PMN[OnSeg,vector])
    #    local Near = vec2(PMN[OnSeg-1,vector])
    #    local Point = Near + (Z-Distances[OnSeg-1,number])*ax2(Near,Far)
    #    local Angle = -heading(vec(),ang(),vec(Far-Near))
        
        #STC++
        #SingleTieCenters[STC,vector] = vec(Point,-OriginHeight+TieTopHeight)
        #SingleTieAngles[STC,angle] = Angle
        
        #debugHolo(STC,Point,vec(255,0,0))
        
    #    Z += TieSeparation
    #}
    
    #timer("plotsingletiesdv",100)
#}elseif(clk("plotsingletiesdv")){
    
    #local DV = SwitchDivPiece[SelectedTrack,number]
    #local PDV = Plots[DV,array]
    
    #local StartSeg = !MainLeft ? LeftMaxSeg : RightMaxSeg
    #local EndSeg = NumOverlapsDV
    #local Distances = array()
    #local MaxZ = 0
    
    #for(N=StartSeg,EndSeg){
    #    local Far = PDV[N,vector]
    #    local Near = PDV[N-1,vector]
    #    local Dist = (Far-Near):length()
    #    MaxZ = Distances[N,number] = Dist + Distances[N-1,number]
    #}
    #local Z = ceil(DV_MinZ + TieSeparation - TieThickness/2)
    #while(Z<MaxZ){
        
    #    local OnSeg = StartSeg
    #    for(N=StartSeg,EndSeg){
    #        if(Z>=Distances[N,number]){
    #            OnSeg++
    #        }
    #    }
    #    local Far = vec2(PDV[OnSeg,vector])
    #    local Near = vec2(PDV[OnSeg-1,vector])
    #    local Point = Near + (Z-Distances[OnSeg-1,number])*ax2(Near,Far)
    #    local Angle = -heading(vec(),ang(),vec(Far-Near))
        
        #STC++
        #SingleTieCenters[STC,vector] = vec(Point,-OriginHeight+TieTopHeight)
        #SingleTieAngles[STC,angle] = Angle
        
        #debugHolo(STC,Point,vec(0,0,255))
        
    #    Z += TieSeparation
    #}
    #cprint("Analyzing Rails...")
    #timer("???",100)
}elseif(clk("???")){
    
    
    timer("findmergejoint",100)
    
    
}elseif(clk("findmergejoint")){ #Find the segments where the two tracks begin to diverge
    local MN = SwitchMainPiece[SelectedTrack,number]
    local DV = SwitchDivPiece[SelectedTrack,number]
    
    #pick a joint along the piece you didn't split, that's where the switch points will end
    local SplitMode = SwitchSplit[SelectedTrack,string]
    #Find the last collinear points
    local PointsMN = Plots[MN,array]
    local PointsDV = Plots[DV,array]
    
    #if(SplitMode=="main"){
    #    for(N=0,NumOverlapsMN-1){
    #        local DVSeg = Jmap_MN[N,number]
    #        local Far = vec2(PointsDV[DVSeg,vector])
    #        local Near = vec2(PointsDV[DVSeg-1,vector])
    #        if(vec2(PointsMN[N,vector]):collinear(Near,Far)){
    #            MergeJoint = N
    #        }else{
    #            break
    #        }
    #    }
    #    StockToChopMN = Jmap_DV[MergeJoint,number]
    #    StockToChopDV = MergeJoint+1
    #}else{
    #    for(N=0,NumOverlapsDV-1){
    #        local MNSeg = Jmap_DV[N,number]
    #        local Far = vec2(PointsMN[MNSeg,vector])
    #        local Near = vec2(PointsMN[MNSeg-1,vector])
    #        if(vec2(PointsDV[N,vector]):collinear(Near,Far)){
    #            MergeJoint = N
    #        }else{
    #            break
    #        }
    #    }
    #    StockToChopMN = MergeJoint+1
    #    StockToChopDV = Jmap_MN[MergeJoint,number]
    #}
    
    #Fuck Merge Joints let's do this intelligently
    #Assumes straights have only one segment
    local Card1 = CardinalPoint
    local Card2 = Card1+CardinalDir
    
    #Main
    for(N=0,NumOverlapsMN-1){
        local PointSample = vec2(PointsMN[N,vector])
        if(PointSample:collinear(Card1,Card2)){
            StockToChopMN = N+1
        }else{
            break
        }
    }
    #Diverging
    for(N=0,NumOverlapsDV-1){
        local PointSample = vec2(PointsDV[N,vector])
        if(PointSample:collinear(Card1,Card2)){
            StockToChopDV = N+1
        }else{
            break
        }
    }
    
    if(MainLeft){
        TopPointsMN = JointsLists[MN,table]["L",array]
        TopPointsDV = JointsLists[DV,table]["K",array]
    }else{
        TopPointsMN = JointsLists[MN,table]["K",array]
        TopPointsDV = JointsLists[DV,table]["L",array]
    }
    
    RailSegID = 1
    #print(MergeJointMN,MergeJointDV)
    timer("findrailisect_mn",100)
    
}elseif(clk("findrailisect_mn")){ #Check a main rail segment against all applicable DV rail segments
    local MN = SwitchMainPiece[SelectedTrack,number]
    local DV = SwitchDivPiece[SelectedTrack,number]
    
    
    local Far = vec2(TopPointsMN[RailSegID,vector])
    local Near = vec2(TopPointsMN[RailSegID-1,vector])
    local Found = 0
    local Inter = vec2()
    for(N=1,NumOverlapsDV){
        local Far2 = vec2(TopPointsDV[N,vector])
        local Near2 = vec2(TopPointsDV[N-1,vector])
        
        #if((RailSegID==1) & (N==2)){
        #    holoCreate(1,E:toWorld(vec(Far)))
        #    holoCreate(2,E:toWorld(vec(Near)))
        #    holoCreate(3,E:toWorld(vec(Far2)))
        #    holoCreate(4,E:toWorld(vec(Near2)))
        #    holoColor(1,vec(255,0,0))
        #    holoColor(2,vec(255,0,0))
        #    holoColor(3,vec(0,0,255))
        #    holoColor(4,vec(0,0,255))
        #}
        
        local IR = lineSegIsect(Far,Near,Far2,Near2)
        if(!IR[1,number]){
            Found = 1
            Inter = IR[2,vector2]
            
            RIMN = RailSegID
            RIDV = N
            break
        }
        
    }
    if(Found){
        I_Top = round(Inter)
        local FarMN = vec2(JointsLists[MN,table][MainLeft ? "N" : "M",array][RIMN,vector])
        local NearMN = vec2(JointsLists[MN,table][MainLeft ? "N" : "M",array][RIMN-1,vector])
        local FarDV = vec2(JointsLists[DV,table][MainLeft ? "M" : "N",array][RIDV,vector])
        local NearDV = vec2(JointsLists[DV,table][MainLeft ? "M" : "N",array][RIDV-1,vector])
        
        local L1 = line(FarMN,NearMN-FarMN)
        local L2 = line(FarDV,NearDV-FarDV)
        
        I_Bottom = round(intersection(L1,L2)[2,vector2])
        
        ClosureDirMN = ax2(FarMN,NearMN)
        ClosureDirDV = ax2(FarDV,NearDV)
        
        ClosurePointInnerMN = round(I_Bottom + RailWidth*ClosureDirMN*2)
        ClosurePointInnerDV = round(I_Bottom + RailWidth*ClosureDirDV*2)
        ClosureCornerMN = ClosurePointInnerMN + vec2(JointsLists[MN,table][MainLeft ? "L" : "K",array][RIMN,vector]) - FarMN
        ClosureCornerDV = ClosurePointInnerDV + vec2(JointsLists[DV,table][!MainLeft ? "L" : "K",array][RIDV,vector]) - FarDV
        
        L1 = line(Inter,ClosureDirMN)
        L2 = line(Inter,ClosureDirDV)
        local L3 = line(ClosurePointInnerMN,ClosureDirDV)
        local L4 = line(ClosurePointInnerDV,ClosureDirMN)
        
        ClosurePointOuterMN = round(intersection(L1,L3)[2,vector2])
        ClosurePointOuterDV = round(intersection(L2,L4)[2,vector2])
        
        #debugHolo(ClosurePointInnerMN,vec(255,0,0),0)
        #debugHolo(ClosurePointOuterMN,vec(0,255,0),0)
        #debugHolo(ClosureCornerMN,vec(0,0,255),0)
        
        FrogPos = round(vec(I_Bottom,-OriginHeight + RailTopHeight+1))
        
        cprint("Found Rail Intersects.")
        timer("presplitrails",100)
    }else{
        RailSegID++
        if(RailSegID>NumOverlapsMN){
            vocalize("vo/engineer_dominationengineer01.mp3")
            cprint("ERROR: Cannot find rail intersection! Double check your switch's \"left\" value is correct.")
        }else{
            timer("findrailisect_mn",100)
        }
    }
    
}elseif(clk("presplitrails")){
    #MAIN STOCK SPLIT
    
    local MN = SwitchMainPiece[SelectedTrack,number]
    local DV = SwitchDivPiece[SelectedTrack,number]
    local JLMN = JointsLists[MN,table]
    local JLDV = JointsLists[DV,table]
    
    #          K M      N L
    #          G I      J H
    #       E----------------F
    #   /   |                |   \
    # A-----C----------------D-----B
    
    
    #We have StockToChopMN and StockToChopDV which represent the first diverging segments of each path
    #Get joint lists in their proper places
    local Outer_MN = JLMN[MainLeft ? "K" : "L",array]
    local Inner_MN = JLMN[MainLeft ? "M" : "N",array]
    local Outer_DV = JLDV[MainLeft ? "K" : "L",array]
    local Inner_DV = JLDV[MainLeft ? "M" : "N",array]
    
    #Thank October Daye for some of the variable names
    local Root_Inner = vec2(Inner_MN[StockToChopMN-1,vector])
    local Root_Outer = vec2(Outer_MN[StockToChopMN-1,vector])
    local Oak_Inner = vec2(Inner_DV[StockToChopDV-1,vector])
    local Oak_Outer = vec2(Outer_DV[StockToChopDV-1,vector])
    
    local Branch_Inner = vec2(Inner_MN[StockToChopMN,vector])
    local Branch_Outer = vec2(Outer_MN[StockToChopMN,vector])
    local Ash_Inner = vec2(Inner_DV[StockToChopDV,vector])
    local Ash_Outer = vec2(Outer_DV[StockToChopDV,vector])
    
    local Goodbye_Inner = vec2(Inner_MN[StockToChopMN+1,vector])
    local Goodbye_Outer = vec2(Outer_MN[StockToChopMN+1,vector])
    local Iron_Inner = vec2(Inner_DV[StockToChopDV+1,vector])
    local Iron_Outer = vec2(Outer_DV[StockToChopDV+1,vector])
    
    #First we need to find the Incident segments:
    local IncidentMN = StockToChopMN
    local IncidentDV = StockToChopDV
    local CanExpandMN = StockToChopMN<Outer_MN:count()
    local CanExpandDV = StockToChopDV<Outer_DV:count()
    
    #Test intersections to adjust Incidents
    local Isect = lineSegIsect(Goodbye_Inner, Branch_Inner, Iron_Outer, Ash_Outer) #MN2 DV2
    if(!Isect[1,number] & CanExpandMN & CanExpandDV){ #Incidents are both +1
        #print("Case 1.")
        IncidentMN++
        IncidentDV++
    }else{
        local Isect = lineSegIsect(Branch_Inner, Root_Inner, Iron_Outer, Ash_Outer) #MN1 DV2
        if(!Isect[1,number] & CanExpandDV){ #Incident DV +1
            #print("Case 2.")
            IncidentDV++
        }else{
            local Isect = lineSegIsect(Goodbye_Inner, Branch_Inner, Ash_Outer, Oak_Outer) #MN2 DV1
            if(!Isect[1,number] & CanExpandMN){ #Incident MN +1
                #print("Case 3.")
                IncidentMN++
            }
        }
    }
    
    ClosureIndexDV = IncidentDV
    StockIndexMN = IncidentMN
    
    #DIIVERGING STOCK SPLIT
    
    #          K M      N L
    #          G I      J H
    #       E----------------F
    #   /   |                |   \
    # A-----C----------------D-----B
    
    
    #We have StockToChopMN and StockToChopDV which represent the first diverging segments of each path
    #Get joint lists in their proper places
    local Outer_MN = JLMN[!MainLeft ? "K" : "L",array]
    local Inner_MN = JLMN[!MainLeft ? "M" : "N",array]
    local Outer_DV = JLDV[!MainLeft ? "K" : "L",array]
    local Inner_DV = JLDV[!MainLeft ? "M" : "N",array]
    
    #Thank October Daye for some of the variable names
    local Root_Inner = vec2(Inner_MN[StockToChopMN-1,vector])
    local Root_Outer = vec2(Outer_MN[StockToChopMN-1,vector])
    local Oak_Inner = vec2(Inner_DV[StockToChopDV-1,vector])
    local Oak_Outer = vec2(Outer_DV[StockToChopDV-1,vector])
    
    local Branch_Inner = vec2(Inner_MN[StockToChopMN,vector])
    local Branch_Outer = vec2(Outer_MN[StockToChopMN,vector])
    local Ash_Inner = vec2(Inner_DV[StockToChopDV,vector])
    local Ash_Outer = vec2(Outer_DV[StockToChopDV,vector])
    
    local Goodbye_Inner = vec2(Inner_MN[StockToChopMN+1,vector])
    local Goodbye_Outer = vec2(Outer_MN[StockToChopMN+1,vector])
    local Iron_Inner = vec2(Inner_DV[StockToChopDV+1,vector])
    local Iron_Outer = vec2(Outer_DV[StockToChopDV+1,vector])
    
    #First we need to find the Incident segments:
    local IncidentMN = StockToChopMN
    local IncidentDV = StockToChopDV
    local CanExpandMN = StockToChopMN<Outer_MN:count()
    local CanExpandDV = StockToChopDV<Outer_DV:count()
    
    #Test intersections to adjust Incidents
    local Isect = lineSegIsect(Goodbye_Outer, Branch_Outer, Iron_Inner, Ash_Inner) #MN2 DV2
    if(!Isect[1,number] & CanExpandMN & CanExpandDV){ #Incidents are both +1
        IncidentMN++
        IncidentDV++
    }else{
        local Isect = lineSegIsect(Branch_Outer, Root_Outer, Iron_Inner, Ash_Inner) #MN1 DV2
        if(!Isect[1,number] & CanExpandDV){ #Incident DV +1
            IncidentDV++
        }else{
            local Isect = lineSegIsect(Goodbye_Outer, Branch_Outer, Ash_Inner, Oak_Inner) #MN2 DV1
            if(!Isect[1,number] & CanExpandMN){ #Incident MN +1
                IncidentMN++
            }
        }
    }
    
    ClosureIndexMN = IncidentMN
    StockIndexDV = IncidentDV
    
    timer("splitrails",100)
}elseif(clk("splitrails")){
    
    #MAIN STOCK SPLIT
    
    local MN = SwitchMainPiece[SelectedTrack,number]
    local DV = SwitchDivPiece[SelectedTrack,number]
    local JLMN = JointsLists[MN,table]
    local JLDV = JointsLists[DV,table]
    
    #          K M      N L
    #          G I      J H
    #       E----------------F
    #   /   |                |   \
    # A-----C----------------D-----B
    
    
    #We have StockToChopMN and StockToChopDV which represent the first diverging segments of each path
    #Get joint lists in their proper places
    local Outer_MN = JLMN[MainLeft ? "K" : "L",array]
    local Inner_MN = JLMN[MainLeft ? "M" : "N",array]
    local Outer_DV = JLDV[MainLeft ? "K" : "L",array]
    local Inner_DV = JLDV[MainLeft ? "M" : "N",array]
    
    #Thank October Daye for some of the variable names
    local Root_Inner = vec2(Inner_MN[StockToChopMN-1,vector])
    local Root_Outer = vec2(Outer_MN[StockToChopMN-1,vector])
    local Oak_Inner = vec2(Inner_DV[StockToChopDV-1,vector])
    local Oak_Outer = vec2(Outer_DV[StockToChopDV-1,vector])
    
    local Branch_Inner = vec2(Inner_MN[StockToChopMN,vector])
    local Branch_Outer = vec2(Outer_MN[StockToChopMN,vector])
    local Ash_Inner = vec2(Inner_DV[StockToChopDV,vector])
    local Ash_Outer = vec2(Outer_DV[StockToChopDV,vector])
    
    local Goodbye_Inner = vec2(Inner_MN[StockToChopMN+1,vector])
    local Goodbye_Outer = vec2(Outer_MN[StockToChopMN+1,vector])
    local Iron_Inner = vec2(Inner_DV[StockToChopDV+1,vector])
    local Iron_Outer = vec2(Outer_DV[StockToChopDV+1,vector])
    
    #First we need to find the Incident segments:
    local IncidentMN = max(StockIndexMN,ClosureIndexMN)
    local IncidentDV = max(StockIndexDV,ClosureIndexDV)
    local CanExpandMN = StockToChopMN<Outer_MN:count()
    local CanExpandDV = StockToChopDV<Outer_DV:count()
    
    #Test intersections to adjust Incidents
    local Contact_Inner = vec2()
    local Isect = lineSegIsect(Goodbye_Inner, Branch_Inner, Iron_Outer, Ash_Outer) #MN2 DV2
    if(!Isect[1,number] & CanExpandMN & CanExpandDV){ #Incidents are both +1
        Contact_Inner = Isect[2,vector2]
    }else{
        local Isect = lineSegIsect(Branch_Inner, Root_Inner, Iron_Outer, Ash_Outer) #MN1 DV2
        if(!Isect[1,number] & CanExpandDV){ #Incident DV +1
            Contact_Inner = Isect[2,vector2]
        }else{
            local Isect = lineSegIsect(Goodbye_Inner, Branch_Inner, Ash_Outer, Oak_Outer) #MN2 DV1
            if(!Isect[1,number] & CanExpandMN){ #Incident MN +1
                Contact_Inner = Isect[2,vector2]
            }else{
                #print("Case 4.")
                local Isect = lineSegIsect(Branch_Inner, Root_Inner, Ash_Outer, Oak_Outer) #MN1 DV1
                Contact_Inner = Isect[2,vector2] #Doesn't care about whether the segments actually overlap, last resort but also nicest case
            }
        }
    }
    #We got the Contact point as a bonus!
    Contact_Inner = round(Contact_Inner)
    local Contact_Outer = Contact_Inner + Branch_Outer - Branch_Inner
    
    #Find the Merge Points - Easy 
    local Merge_Inner = round(lineSegIsect(Branch_Inner, Root_Inner, Ash_Inner, Oak_Inner)[2,vector2])
    local Merge_Outer = Merge_Inner + Root_Outer - Root_Inner
    
    #Array time
    Rail1MN = array()
    Rail2MN = array()
    Rail3MN = array()
    
    if((Merge_Inner != Root_Inner)){
        Rail1MN = MainLeft ? array(Merge_Inner, Merge_Outer, Root_Outer, Root_Inner) : array(Merge_Outer, Merge_Inner, Root_Inner, Root_Outer)
        #debugHoloArray(Rail1MN,vec(),vec(0,255,0))
    }
    Rail2MN = MainLeft ? array(Contact_Inner, Contact_Outer, Merge_Outer, Merge_Inner) : array(Contact_Outer, Contact_Inner, Merge_Inner, Merge_Outer)
    
    local ThePoint_Inner = (IncidentMN>StockToChopMN) ? Goodbye_Inner : Branch_Inner #formerly used CanExpandMN
    local ThePoint_Outer = (IncidentMN>StockToChopMN) ? Goodbye_Outer : Branch_Outer
    
    if(Contact_Inner != ThePoint_Inner){
        Rail3MN = MainLeft ? array(ThePoint_Inner, ThePoint_Outer, Contact_Outer, Contact_Inner) : array(ThePoint_Outer, ThePoint_Inner, Contact_Inner, Contact_Outer)
        Patch1MN = Rail3MN:clone()
    }
    
    #Set Variables
    
    SWPointsFarMN = Contact_Inner
    SWPointsNearMN = Merge_Inner
    
    ContactPointInnerDV = vec(2*Contact_Inner - Contact_Outer)
    ContactPointOuterDV = vec(Contact_Inner)
    
    #DIIVERGING STOCK SPLIT
    
    #          K M      N L
    #          G I      J H
    #       E----------------F
    #   /   |                |   \
    # A-----C----------------D-----B
    
    
    #We have StockToChopMN and StockToChopDV which represent the first diverging segments of each path
    #Get joint lists in their proper places
    local Outer_MN = JLMN[!MainLeft ? "K" : "L",array]
    local Inner_MN = JLMN[!MainLeft ? "M" : "N",array]
    local Outer_DV = JLDV[!MainLeft ? "K" : "L",array]
    local Inner_DV = JLDV[!MainLeft ? "M" : "N",array]
    
    #Thank October Daye for some of the variable names
    local Root_Inner = vec2(Inner_MN[StockToChopMN-1,vector])
    local Root_Outer = vec2(Outer_MN[StockToChopMN-1,vector])
    local Oak_Inner = vec2(Inner_DV[StockToChopDV-1,vector])
    local Oak_Outer = vec2(Outer_DV[StockToChopDV-1,vector])
    
    local Branch_Inner = vec2(Inner_MN[StockToChopMN,vector])
    local Branch_Outer = vec2(Outer_MN[StockToChopMN,vector])
    local Ash_Inner = vec2(Inner_DV[StockToChopDV,vector])
    local Ash_Outer = vec2(Outer_DV[StockToChopDV,vector])
    
    local Goodbye_Inner = vec2(Inner_MN[StockToChopMN+1,vector])
    local Goodbye_Outer = vec2(Outer_MN[StockToChopMN+1,vector])
    local Iron_Inner = vec2(Inner_DV[StockToChopDV+1,vector])
    local Iron_Outer = vec2(Outer_DV[StockToChopDV+1,vector])
    
    #First we need to find the Incident segments:
    local IncidentMN = max(StockIndexMN,ClosureIndexMN)
    local IncidentDV = max(StockIndexDV,ClosureIndexDV)
    local CanExpandMN = StockToChopMN<Outer_MN:count()
    local CanExpandDV = StockToChopDV<Outer_DV:count()
    
    #Test intersections to adjust Incidents
    local Contact_Inner = vec2()
    local Isect = lineSegIsect(Goodbye_Outer, Branch_Outer, Iron_Inner, Ash_Inner) #MN2 DV2
    if(!Isect[1,number] & CanExpandMN & CanExpandDV){ #Incidents are both +1
        Contact_Inner = Isect[2,vector2]
    }else{
        local Isect = lineSegIsect(Branch_Outer, Root_Outer, Iron_Inner, Ash_Inner) #MN1 DV2
        if(!Isect[1,number] & CanExpandDV){ #Incident DV +1
            Contact_Inner = Isect[2,vector2]
        }else{
            local Isect = lineSegIsect(Goodbye_Outer, Branch_Outer, Ash_Inner, Oak_Inner) #MN2 DV1
            if(!Isect[1,number] & CanExpandMN){ #Incident MN +1
                Contact_Inner = Isect[2,vector2]
            }else{
                local Isect = lineSegIsect(Branch_Outer, Root_Outer, Ash_Inner, Oak_Inner) #MN1 DV1
                Contact_Inner = Isect[2,vector2] #Doesn't care about whether the segments actually overlap, last resort but also nicest case
            }
        }
    }
    #We got the Contact point as a bonus!
    Contact_Inner = round(Contact_Inner)
    local Contact_Outer = Contact_Inner + Ash_Outer - Ash_Inner
    
    #Find the Merge Points - Easy 
    local Merge_Inner = round(lineSegIsect(Branch_Inner, Root_Inner, Ash_Inner, Oak_Inner)[2,vector2])
    local Merge_Outer = Merge_Inner + Root_Outer - Root_Inner
    
    #Array time
    Rail1DV = array()
    Rail2DV = array()
    Rail3DV = array()
    
    if((Merge_Inner != Root_Inner)){
        Rail1DV = !MainLeft ? array(Merge_Inner, Merge_Outer, Root_Outer, Root_Inner) : array(Merge_Outer, Merge_Inner, Root_Inner, Root_Outer)
        #debugHoloArray(Rail1DV,vec(),vec(255,0,0))
    }
    Rail2DV = !MainLeft ? array(Contact_Inner, Contact_Outer, Merge_Outer, Merge_Inner) : array(Contact_Outer, Contact_Inner, Merge_Inner, Merge_Outer)
    
    local ThePoint_Inner = (IncidentDV>StockToChopDV) ? Iron_Inner : Ash_Inner #Formerly used CanExpandDV)
    local ThePoint_Outer = (IncidentDV>StockToChopDV) ? Iron_Outer : Ash_Outer
    if(Contact_Inner != ThePoint_Inner){
        Rail3DV = !MainLeft ? array(ThePoint_Inner, ThePoint_Outer, Contact_Outer, Contact_Inner) : array(ThePoint_Outer, ThePoint_Inner, Contact_Inner, Contact_Outer)
        Patch1DV = Rail3DV:clone()
    }
    
    SWPointsFarDV = Contact_Inner
    SWPointsNearDV = Merge_Inner
    
    ContactPointInnerMN = vec(2*Contact_Inner - Contact_Outer)
    ContactPointOuterMN = vec(Contact_Inner)
    
    #debugHoloArray(Rail2DV,Red,Yellow)
    timer("resolveclosurerails",100)
    
}elseif(clk("resolveclosurerails")){
    
    local MN = SwitchMainPiece[SelectedTrack,number]
    local DV = SwitchDivPiece[SelectedTrack,number]
    local PMN = Plots[MN,array]
    local PDV = Plots[DV,array]
    local JLMN = JointsLists[MN,table]
    local JLDV = JointsLists[DV,table]
    
    #Closure Rails start at ClosureIndex+1 and end at RIMN/DV
    
    #print(ClosureIndexMN, RIMN, "/", ClosureIndexDV, RIDV)
    local NumClosureSegments = max(RIMN-ClosureIndexMN, RIDV-ClosureIndexDV,1)
    
    #          K M      N L
    #          G I      J H
    #       E----------------F
    #   /   |                |   \
    # A-----C----------------D-----B
    
    local Outer_MN = JLMN[!MainLeft ? "K" : "L",array]
    local Inner_MN = JLMN[!MainLeft ? "M" : "N",array]
    
    local Outer_DV = JLDV[MainLeft ? "K" : "L",array]
    local Inner_DV = JLDV[MainLeft ? "M" : "N",array]
    
    ThrowAxisMN = vec2(Inner_MN[1,vector] - Outer_MN[1,vector]):normalized()
    ThrowAxisDV = vec2(Inner_DV[1,vector] - Outer_DV[1,vector]):normalized()
    
    #Starting at: Contact Point
    #Ending at: Closure Point
    #In Between: all the vanilla verts.
    
    
    #Main Closure Rail
    local ClosureRewriteInnerMN = array()
    local ClosureRewriteOuterMN = array()
    
    local Path = array(ContactPointInnerMN)
    local C = 2
    for(N=ClosureIndexMN,RIMN-1){
        Path[C,vector] = Inner_MN[N,vector]
        C++
    }
    Path[C,vector] = vec(ClosurePointInnerMN)
    
    ClosureRewriteInnerMN[1,vector] = ContactPointInnerMN
    ClosureRewriteOuterMN[1,vector] = ContactPointOuterMN
    
    wrapOnPathInit(Path)
    for(N=1,NumClosureSegments-1){
        local P = round(wrapOnPathFrac(N/NumClosureSegments))
        ClosureRewriteInnerMN[N+1,vector] = P
        ClosureRewriteOuterMN[N+1,vector] = P + Outer_MN[ClosureIndexMN,vector] - Inner_MN[ClosureIndexMN,vector]
    }
    
    ClosureRewriteInnerMN[NumClosureSegments+1,vector] = vec(ClosurePointInnerMN)
    ClosureRewriteOuterMN[NumClosureSegments+1,vector] = vec(ClosureCornerMN)
    
    #Group Points
    ClosurePointGroupsMN = table()
    ClosureThrowsMN = array()
    for(N=1,NumClosureSegments){
        if(MainLeft){
            ClosurePointGroupsMN[N,array] = array(
                vec2(ClosureRewriteOuterMN[N+1,vector]),
                vec2(ClosureRewriteInnerMN[N+1,vector]),
                vec2(ClosureRewriteInnerMN[N,vector]),
                vec2(ClosureRewriteOuterMN[N,vector])
            )
        }else{
            ClosurePointGroupsMN[N,array] = array(
                vec2(ClosureRewriteInnerMN[N+1,vector]),
                vec2(ClosureRewriteOuterMN[N+1,vector]),
                vec2(ClosureRewriteOuterMN[N,vector]),
                vec2(ClosureRewriteInnerMN[N,vector])
            )
        }
        if(N==1){
            ClosureThrowsMN[N,number] = SwitchThrow
        }elseif(N==2){
            ClosureThrowsMN[N,number] = SwitchThrow/2
        }else{
            ClosureThrowsMN[N,number] = 0
        }
    }
    
    #Diverging Closure Rail
    local ClosureRewriteInnerDV = array()
    local ClosureRewriteOuterDV = array()
    
    local Path = array(ContactPointInnerDV)
    local C = 2
    for(N=ClosureIndexDV,RIDV-1){
        Path[C,vector] = Inner_DV[N,vector]
        C++
    }
    Path[C,vector] = vec(ClosurePointInnerDV)
    
    ClosureRewriteInnerDV[1,vector] = ContactPointInnerDV
    ClosureRewriteOuterDV[1,vector] = ContactPointOuterDV
    
    wrapOnPathInit(Path)
    for(N=1,NumClosureSegments-1){
        local P = round(wrapOnPathFrac(N/NumClosureSegments))
        ClosureRewriteInnerDV[N+1,vector] = P
        ClosureRewriteOuterDV[N+1,vector] = P + Outer_DV[ClosureIndexDV,vector] - Inner_DV[ClosureIndexDV,vector]
    }
    
    ClosureRewriteInnerDV[NumClosureSegments+1,vector] = vec(ClosurePointInnerDV)
    ClosureRewriteOuterDV[NumClosureSegments+1,vector] = vec(ClosureCornerDV)
    
    #Group Points
    ClosurePointGroupsDV = table()
    ClosureThrowsDV = array()
    for(N=1,NumClosureSegments){
        if(!MainLeft){
            ClosurePointGroupsDV[N,array] = array(
                vec2(ClosureRewriteOuterDV[N+1,vector]),
                vec2(ClosureRewriteInnerDV[N+1,vector]),
                vec2(ClosureRewriteInnerDV[N,vector]),
                vec2(ClosureRewriteOuterDV[N,vector])
            )
        }else{
            ClosurePointGroupsDV[N,array] = array(
                vec2(ClosureRewriteInnerDV[N+1,vector]),
                vec2(ClosureRewriteOuterDV[N+1,vector]),
                vec2(ClosureRewriteOuterDV[N,vector]),
                vec2(ClosureRewriteInnerDV[N,vector])
            )
        }
        if(N==1){
            ClosureThrowsDV[1,number] = SwitchThrow
        }elseif(N==2){
            ClosureThrowsDV[2,number] = SwitchThrow/2
        }else{
            ClosureThrowsDV[N,number] = 0
        }
    }
    
    #Debug
    #local Debug = array()
    #foreach(K,V:vector=ClosureRewriteOuterMN){
    #    Debug[K,vector2] = vec2(V)
    #}
    #printTable(Debug)
    #debugHoloArray(Debug,Red,Yellow)
    
    #debugHoloArray(ClosurePointGroupsMN[3,array],Red,Yellow)
    #debugHoloArray(ClosurePointGroupsDV[3,array],Green,Blue)
    
    timer("solvecheckrails",100)
    cprint("Plotting Check Rails...")
    
}elseif(clk("solvecheckrails")){
    
    local MN = SwitchMainPiece[SelectedTrack,number]
    local DV = SwitchDivPiece[SelectedTrack,number]
    local PMN = Plots[MN,array]
    local PDV = Plots[DV,array]
    
    CheckPointGroups = table()
    
    local NearMN = vec2(PMN[RIMN-1,vector])
    local FarMN = vec2(PMN[RIMN,vector])
    local NearDV = vec2(PDV[RIDV-1,vector])
    local FarDV = vec2(PDV[RIDV,vector])
    
    local TrackGauge = TrackFace_Ang0["rail_inner",vector2]:x()*2
    
    #          K M      N L
    #          G I      J H
    #       E----------------F
    #   /   |                |   \
    # A-----C----------------D-----B
    
    local LF = MainLeft ? FarMN : FarDV
    local LN = MainLeft ? NearMN : NearDV
    local RF = !MainLeft ? FarMN : FarDV
    local RN = !MainLeft ? NearMN : NearDV
    
    local DirL = ax2(LN,LF)
    local DirR = ax2(RN,RF)
    
    local TransL = DirL:rotate(90)
    local TransR = DirR:rotate(-90)
    
    local C1 = round(I_Bottom + CheckLength*DirL/2 + TransL*(TrackGauge-RailWidth*1.5))
    local C2 = round(I_Bottom + CheckLength*DirL/2 + TransL*(TrackGauge-RailWidth*0.5))
    local C3 = round(I_Bottom - CheckLength*DirL/2 + TransL*(TrackGauge-RailWidth*0.5))
    local C4 = round(I_Bottom - CheckLength*DirL/2 + TransL*(TrackGauge-RailWidth*1.5))
    
    CheckPointGroups[1,array] = array(C1,C2,C3,C4)
    
    local C5 = round(I_Bottom + CheckLength*DirR/2 + TransR*(TrackGauge-RailWidth*0.5))
    local C6 = round(I_Bottom + CheckLength*DirR/2 + TransR*(TrackGauge-RailWidth*1.5))
    local C7 = round(I_Bottom - CheckLength*DirR/2 + TransR*(TrackGauge-RailWidth*1.5))
    local C8 = round(I_Bottom - CheckLength*DirR/2 + TransR*(TrackGauge-RailWidth*0.5))
    
    CheckPointGroups[2,array] = array(C5,C6,C7,C8)
    
    local C9 = round(C1 + 8*DirL - 1*TransL)
    local C10 = round(C2 + 8*DirL - 1*TransL)
    
    CheckPointGroups[3,array] = array(C9,C10,C2,C1)
    
    local C11 = round(C3 - 8*DirL - 1*TransL)
    local C12 = round(C4 - 8*DirL - 1*TransL)
    
    CheckPointGroups[4,array] = array(C4,C3,C11,C12)
    
    local C13 = round(C5 + 8*DirR - 1*TransR)
    local C14 = round(C6 + 8*DirR - 1*TransR)
    
    CheckPointGroups[5,array] = array(C13,C14,C6,C5)
    
    local C15 = round(C7 - 8*DirR - 1*TransR)
    local C16 = round(C8 - 8*DirR - 1*TransR)
    
    CheckPointGroups[6,array] = array(C8,C7,C15,C16)
    
    #debugHolo(1,C13,vec(255,0,0))
    #debugHolo(2,C14,vec(255,255,0))
    #debugHolo(3,C6,vec(0,255,0))
    #debugHolo(4,C5,vec(0,0,255))
    
    #debugHolo(5,C8,vec(255,0,0))
    #debugHolo(6,C7,vec(255,255,0))
    #debugHolo(7,C15,vec(0,255,0))
    #debugHolo(8,C16,vec(0,0,255))
    
    Do = array()
    
    Do[1,number] = 1
    Do[2,number] = 1
    Do[3,number] = 1
    Do[4,number] = 1
    Do[5,number] = 1
    Do[6,number] = 1
    
    local Sounds = array(
        "vo/engineer_mvm_say_ready01.mp3",
        "vo/engineer_yes03.mp3",
        "vo/engineer_yes02.mp3"
    )
    vocalize(Sounds[randint(1,Sounds:count()),string])
    soundPlay(0,2,"player/taunt_bumpkins_banjo_music_stop.wav")
    soundPitch(0,75)
    cprint("Done!")
    if(AutoCompile & (FinalCompileID==SelectedTrack)){
        timer(".select "+AutoCompileID,500)
        timer(".go",1000)
    }elseif(AutoVon){
        VonID++
        timer("loadvon",100)
    }
    
}elseif(chatClk(O) | clkName():index(1)=="."){
    LS = chatClk() ? O:lastSaid() : clkName()
    Sentence = LS:explode(" ")
    local CMD = Sentence[1,string]
    switch(CMD){
        case ".newpiece", #Initialize a new track piece
            local Type = Sentence[2,string]
            if((Type=="arc")|(Type=="banked_arc")|(Type=="straight")|(Type=="bezier")|(Type=="switch")){ #if a valid track type...
                local TrackPieceCount = TrackNames:count() #Get next TrackID
                local Name = Sentence[3,string] #Get Name
                TrackNames[TrackPieceCount+1,string] = Name #Assign Track Type and Name
                TrackTypes[TrackPieceCount+1,string] = Type
                FullyDefined[TrackPieceCount+1,number] = 0 #Set defined=0 since you didn't define anything yet
                Plotted[TrackPieceCount+1,number] = 0 #No plot has been generated yet
                jprint("Track Piece added: "+Type+" named \""+Name+"\" ("+(TrackPieceCount+1)+").")
                timer(".select "+(TrackPieceCount+1):toString(),100)
                
            }else{
                jprint("Invalid track type! Accepted types are: \"straight\", \"arc\", \"bezier\", and \"switch\".")
            }
            
            hideChat(1)
            break
        case ".listpieces", #Print all track pieces
            
            for(N=1,TrackNames:count()){
                cprint(N:toString()+": "+TrackNames[N,string]+" ("+TrackTypes[N,string]+") " + (FullyDefined[N,number] ? "Defined" : "Undefined"))
            }
            hideChat(1)
            break
        case ".select", #Select a track piece to edit
            local Found = 0
            local ToSelect = Sentence[2,string]
            local TrackID = 0
            if(ToSelect:toNumber()!=0){ #Select By Number
                TrackID = ToSelect:toNumber()
                if(TrackID<=TrackNames:count()){
                    SelectedTrack = TrackID
                    Found = 1
                    jprint("Selected Track Piece "+TrackID:toString()+", \""+TrackNames[TrackID,string]+"\" ("+TrackTypes[TrackID,string]+")")
                }else{
                    jprint("That number is not defined!")
                }
            }else{ #Select by Name
                foreach(K,V:string=TrackNames){
                    if(V==ToSelect){
                        TrackID = K
                        SelectedTrack = TrackID
                        jprint("Selected Track Piece "+TrackID:toString()+", \""+TrackNames[TrackID,string]+"\" ("+TrackTypes[TrackID,string]+")")
                        Found = 1
                        #break
                    }
                }
                if(!Found){
                    jprint("There is no track piece with that name! ("+ToSelect+")")
                }
            }
            if(Found){
                local Type = TrackTypes[TrackID,string]
                switch(Type){ #Display Info
                    case "straight",
                        #@persist [StraightStartPos StraightDir StraightLength]:array 
                        #@persist [StraightStartPosDefined StraightDirDefined StraightLengthDefined]:array
                        cprint("Start Point (startpos): "+(StraightStartPosDefined[TrackID,number] ? StraightStartPos[TrackID,vector2]:toString() : "Undefined"))
                        cprint("Direction (dir): "+(StraightDirDefined[TrackID,number] ? StraightDir[TrackID,number]:toString() : "Undefined"))
                        cprint("Length (length): "+(StraightLengthDefined[TrackID,number] ? StraightLength[TrackID,number]:toString() : "Undefined"))
                        cprint("Height (height): "+(StraightHeightDefined[TrackID,number] ? StraightHeight[TrackID,number]:toString() : "Undefined"))
                        cprint("Segments (segments): "+(StraightSegmentsDefined[TrackID,number] ? StraightSegments[TrackID,number]:toString() : "Undefined"))
                        
                        break
                    case "arc",
                        #@persist [ArcStartPos ArcStartDir ArcEndDir ArcStartLength ArcRadius ArcEndLength]:array
                        #@persist [ArcStartPosDefined ArcStartDirDefined ArcEndDirDefined ArcStartLengthDefined ArcRadiusDefined ArcEndLengthDefined]:array
                        cprint("Start Point (startpos): "+(ArcStartPosDefined[TrackID,number] ? ArcStartPos[TrackID,vector2]:toString() : "Undefined"))
                        cprint("Start Direction (startdir): "+(ArcStartDirDefined[TrackID,number] ? ArcStartDir[TrackID,number]:toString() : "Undefined"))
                        cprint("End Point (endpos): "+(ArcEndPosDefined[TrackID,number] ? ArcEndPos[TrackID,vector2]:toString() : "Undefined"))
                        cprint("End Direction (enddir): "+(ArcEndDirDefined[TrackID,number] ? ArcEndDir[TrackID,number]:toString() : "Undefined"))
                        cprint("Arc Radius (radius): "+(ArcRadiusDefined[TrackID,number] ? ArcRadius[TrackID,number]:toString() : "Undefined"))
                        cprint("Height (height): "+(ArcHeightDefined[TrackID,number] ? ArcHeight[TrackID,number]:toString() : "Undefined"))
                        cprint("Segments (segments): "+(ArcSegmentsDefined[TrackID,number] ? ArcSegments[TrackID,number]:toString() : "Undefined"))
                        
                        break
                    case "banked_arc",
                        #@persist [ArcStartPos ArcStartDir ArcEndDir ArcStartLength ArcRadius ArcEndLength]:array
                        #@persist [ArcStartPosDefined ArcStartDirDefined ArcEndDirDefined ArcStartLengthDefined ArcRadiusDefined ArcEndLengthDefined]:array
                        cprint("Start Point (startpos): "+(BankedArcStartPosDefined[TrackID,number] ? BankedArcStartPos[TrackID,vector2]:toString() : "Undefined"))
                        cprint("Start Direction (startdir): "+(BankedArcStartDirDefined[TrackID,number] ? BankedArcStartDir[TrackID,number]:toString() : "Undefined"))
                        cprint("End Point (endpos): "+(BankedArcEndPosDefined[TrackID,number] ? BankedArcEndPos[TrackID,vector2]:toString() : "Undefined"))
                        cprint("End Direction (enddir): "+(BankedArcEndDirDefined[TrackID,number] ? BankedArcEndDir[TrackID,number]:toString() : "Undefined"))
                        cprint("Arc Radius (radius): "+(BankedArcRadiusDefined[TrackID,number] ? BankedArcRadius[TrackID,number]:toString() : "Undefined"))
                        cprint("Height (height): "+(BankedArcHeightDefined[TrackID,number] ? BankedArcHeight[TrackID,number]:toString() : "Undefined"))
                        cprint("Segments (segments): "+(BankedArcSegmentsDefined[TrackID,number] ? BankedArcSegments[TrackID,number]:toString() : "Undefined"))
                        cprint("Blend In (blendin): "+(BankedArcBlendInDefined[TrackID,number] ? BankedArcBlendIn[TrackID,vector2]:toString() : "Undefined"))
                        cprint("Blend Out (blendout): "+(BankedArcBlendOutDefined[TrackID,number] ? BankedArcBlendOut[TrackID,vector2]:toString() : "Undefined"))
                        
                        
                        break
                    case "bezier",
                        #@persist [BezStartPos BezStartDir BezEndPos BezEndDir BezStartCPLength BezEndCPLength]:array
                        #@persist [BezStartPosDefined BezStartDirDefined BezEndPosDefined BezEndDirDefined BezStartCPLengthDefined BezEndCPLengthDefined]:array
                        cprint("Start Point (startpos): "+(BezStartPosDefined[TrackID,number] ? BezStartPos[TrackID,vector2]:toString() : "Undefined"))
                        cprint("Start Direction (startdir): "+(BezStartDirDefined[TrackID,number] ? BezStartDir[TrackID,number]:toString() : "Undefined"))
                        cprint("End Point (endpos): "+(BezEndPosDefined[TrackID,number] ? BezEndPos[TrackID,vector2]:toString() : "Undefined"))
                        cprint("End Direction (enddir): "+(BezEndDirDefined[TrackID,number] ? BezEndDir[TrackID,number]:toString() : "Undefined"))
                        cprint("Start CP Distance (startcp): "+(BezStartCPLengthDefined[TrackID,number] ? BezStartCPLength[TrackID,number]:toString() : "Undefined"))
                        cprint("End CP Distance (endcp): "+(BezEndCPLengthDefined[TrackID,number] ? BezEndCPLength[TrackID,number]:toString() : "Undefined"))
                        cprint("Height (height): "+(BezHeightDefined[TrackID,number] ? BezHeight[TrackID,number]:toString() : "Undefined"))
                        cprint("Segments (segments): "+(BezSegmentsDefined[TrackID,number] ? BezSegments[TrackID,number]:toString() : "Undefined"))
                        
                        break
                    case "switch",
                        cprint("Main Piece (mainpiece): "+(SwitchMainPieceDefined[TrackID,number] ? "Piece No. "+SwitchMainPiece[TrackID,number]:toString() : "Undefined"))
                        cprint("Diverging Piece (divpiece): "+(SwitchDivPieceDefined[TrackID,number] ? "Piece No. "+SwitchDivPiece[TrackID,number]:toString() : "Undefined"))
                        cprint("Piece to split (split): "+(SwitchSplitDefined[TrackID,number] ? +SwitchSplit[TrackID,string] : "Undefined"))
                        break
                    default,
                        break
                }
            }
            hideChat(1)
            break
        case ".rename", #Change the name of an existing track piece
            local TrackID = 0
            if(Sentence[2,string]==""){
                TrackID = SelectedTrack
            }else{
                TrackID = Sentence[2,string]:toNumber()
            }
            local Arg = Sentence[3,string]
            if(Arg!=""){
                TrackNames[TrackID,string] = Arg
                jprint("Renamed track piece No. "+TrackID+" to \""+Arg+"\"!")
            }else{
                jprint("Cannot rename track piece without a new name!")
            }
            hideChat(1)
            break
        case ".define",
            local Var = Sentence[2,string]
            local Arg1 = Sentence[3,string]
            local Arg2 = Sentence[4,string]
            
            local TrackID = SelectedTrack
            local Type = TrackTypes[TrackID,string]
            if(Var==""){ #Show Variables to define
                jprint("List of Variables for Piece "+TrackID+", \""+TrackNames[TrackID,string]+"\" ("+Type+"):")
                switch(Type){
                    case "straight",
                        cprint("startpos, dir, length, height, segments")
                        break
                    case "arc",
                        cprint("startpos, startdir, endpos, enddir, radius, height, segments")
                        break
                    case "banked_arc",
                        cprint("startpos, startdir, endpos, enddir, radius, height, segments blendin blendout")
                        break
                    case "bezier",
                        cprint("startpos, startdir, endpos, enddir, startcp, endcp, height, segments, cp (optional - does both)")
                        break
                    case "switch",
                        cprint("mainpiece, divpiece")
                        break
                    default,
                        break
                }
            }else{ #Set a Variable!
                switch(Type){
                    case "straight",
                        switch(Var){
                            case "startpos",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint("Start Point (startpos): "+(StraightStartPosDefined[TrackID,number] ? StraightStartPos[TrackID,vector2]:toString() : "Undefined"))
                                }elseif((Arg1!="")&(Arg2!="")){ #Set value
                                    local Vector2 = round(vec2(Arg1:toNumber(),Arg2:toNumber()))
                                    StraightStartPos[TrackID,vector2] = Vector2*Scale #Set the Vector. Easy peasy
                                    StraightStartPosDefined[TrackID,number] = 1
                                    jprint("Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Start Point to "+Vector2:toString()+".")
                                }
                                break
                            case "dir",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint("Direction (dir): "+(StraightDirDefined[TrackID,number] ? StraightDir[TrackID,number]:toString() : "Undefined"))
                                }elseif(Arg1!=""){ #Set value
                                    local Direction = int(Arg1:toNumber()) #Get Direction number
                                    local Good = 1
                                    if(abs(Direction<=16)){
                                        switch(abs(Direction)){
                                            case 3,
                                                Good = 0
                                                break
                                            case 5,
                                                Good = 0
                                                break
                                            case 11,
                                                Good = 0
                                                break
                                            case 13,
                                                Good = 0
                                                break
                                            default,
                                                
                                                break
                                        }
                                    }else{
                                        Good = 0
                                    }
                                    if(Good){
                                        StraightDir[TrackID,number] = Arg1:toNumber()
                                        StraightDirDefined[TrackID,number] = 1
                                        jprint("Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Direction to "+Direction+".")
                                    }else{
                                        jprint("Invalid direction! Acceptable direction codes are all integers from 0-16 except 3, 5, 11, and 13 (Negative numbers allowed).")
                                    }
                                }
                                break
                            case "length",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint("Length (length): "+(StraightLengthDefined[TrackID,number] ? StraightLength[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Length = round(Arg1:toNumber())
                                    if(Length>0){
                                        StraightLength[TrackID,number] = Length*Scale #Set Length. Easy pease
                                        StraightLengthDefined[TrackID,number] = 1
                                        jprint("Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Length to "+Length+".")
                                    }else{
                                        jprint("Invalid Length: cannot be less or equal to zero!")
                                    }
                                }
                                break
                            case "height",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint("Height (height): "+(StraightHeightDefined[TrackID,number] ? StraightHeight[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Height = round(Arg1:toNumber())
                                    StraightHeight[TrackID,number] = Height*Scale
                                    StraightHeightDefined[TrackID,number] = 1
                                    jprint("Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Height to "+Height+".")
                                    
                                }
                                break
                            case "segments",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint("Segments (segments): "+(StraightSegmentsDefined[TrackID,number] ? StraightSegments[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Segments = round(Arg1:toNumber())
                                    if(Segments>0){
                                        StraightSegments[TrackID,number] = Segments
                                        StraightSegmentsDefined[TrackID,number] = 1
                                        jprint("Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Segments to "+Segments+".")
                                    }else{
                                        jprint("How the hell are you supposed to make a track piece with less than 1 segment? Like come on that doesn't even make any sense.")
                                    }
                                }
                                break
                            default,
                                jprint(" That variable is not valid!")
                                break
                        }
                        FullyDefined[TrackID,number] = StraightStartPosDefined[TrackID,number] & StraightDirDefined[TrackID,number] & StraightLengthDefined[TrackID,number] & StraightHeightDefined[TrackID,number] & StraightSegmentsDefined[TrackID,number] #Check to see if every variable is defined.
                        if(FullyDefined[TrackID,number]){cprint("Fully Defined!")}
                        break
                    case "arc",
                        switch(Var){
                            case "startpos",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint(" Start Point (startpos): "+(ArcStartPosDefined[TrackID,number] ? ArcStartPos[TrackID,vector2]:toString() : "Undefined"))
                                }elseif((Arg1!="")&(Arg2!="")){ #Set value
                                    local Vector2 = round(vec2(Arg1:toNumber(),Arg2:toNumber()))
                                    ArcStartPos[TrackID,vector2] = Vector2*Scale #Set the Vector. Easy peasy
                                    ArcStartPosDefined[TrackID,number] = 1
                                    jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Start Point to "+Vector2:toString()+".")
                                }
                                break
                            case "startdir",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint(" Start Direction (startdir): "+(ArcStartDirDefined[TrackID,number] ? ArcStartDir[TrackID,number]:toString() : "Undefined"))
                                }elseif(Arg1!=""){ #Set value
                                    local Direction = int(Arg1:toNumber()) #Get Direction number
                                    local Good = 1
                                    if(abs(Direction<=16)){
                                        switch(abs(Direction)){
                                            case 3,
                                                Good = 0
                                                break
                                            case 5,
                                                Good = 0
                                                break
                                            case 11,
                                                Good = 0
                                                break
                                            case 13,
                                                Good = 0
                                                break
                                            default,
                                                
                                                break
                                        }
                                    }else{
                                        Good = 0
                                    }
                                    if(Good){
                                        ArcStartDir[TrackID,number] = Arg1:toNumber()
                                        ArcStartDirDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Start Direction to "+Direction+".")
                                    }else{
                                        jprint(" Invalid direction! Acceptable direction codes are all integers from 0-16 except 3, 5, 11, and 13 (Negative numbers allowed).")
                                    }
                                }
                                break
                            case "endpos",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint(" End Point (endpos): "+(ArcEndPosDefined[TrackID,number] ? ArcEndPos[TrackID,vector2]:toString() : "Undefined"))
                                }elseif((Arg1!="")&(Arg2!="")){ #Set value
                                    local Vector2 = round(vec2(Arg1:toNumber(),Arg2:toNumber()))
                                    ArcEndPos[TrackID,vector2] = Vector2*Scale #Set the Vector. Easy peasy
                                    ArcEndPosDefined[TrackID,number] = 1
                                    jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" End Point to "+Vector2:toString()+".")
                                }
                                break
                            case "enddir",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint(" End Direction (enddir): "+(ArcEndDirDefined[TrackID,number] ? ArcEndDir[TrackID,number]:toString() : "Undefined"))
                                }elseif(Arg1!=""){ #Set value
                                    local Direction = int(Arg1:toNumber()) #Get Direction number
                                    local Good = 1
                                    if(abs(Direction<=16)){
                                        switch(abs(Direction)){
                                            case 3,
                                                Good = 0
                                                break
                                            case 5,
                                                Good = 0
                                                break
                                            case 11,
                                                Good = 0
                                                break
                                            case 13,
                                                Good = 0
                                                break
                                            default,
                                                
                                                break
                                        }
                                    }else{
                                        Good = 0
                                    }
                                    if(Good){
                                        ArcEndDir[TrackID,number] = Arg1:toNumber()
                                        ArcEndDirDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" End Direction to "+Direction+".")
                                    }else{
                                        jprint(" Invalid direction! Acceptable direction codes are all integers from 0-16 except 3, 5, 11, and 13 (Negative numbers allowed).")
                                    }
                                }
                                break
                            case "radius",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint(" Arc Radius (radius): "+(ArcRadiusDefined[TrackID,number] ? ArcRadius[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Radius = round(Arg1:toNumber())
                                    if(Radius>0){
                                        ArcRadius[TrackID,number] = Radius*Scale #Set Length. Easy pease
                                        ArcRadiusDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Arc Radius to "+Radius+".")
                                    }else{
                                        jprint(" Invalid Length: cannot be less or equal to zero!")
                                    }
                                }
                                break
                            case "height",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint("Height (height): "+(ArcHeightDefined[TrackID,number] ? ArcHeight[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Height = round(Arg1:toNumber())
                                    ArcHeight[TrackID,number] = Height*Scale
                                    ArcHeightDefined[TrackID,number] = 1
                                    jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Height to "+Height+".")
                                }
                                break
                            case "segments",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint("Segments (segments): "+(ArcSegmentsDefined[TrackID,number] ? ArcSegments[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Segments = round(Arg1:toNumber())
                                    if(Segments>0){
                                        ArcSegments[TrackID,number] = Segments
                                        ArcSegmentsDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Segments to "+Segments+".")
                                    }else{
                                        jprint(" How the hell are you supposed to make a track piece with less than 1 segment? Like come on that doesn't even make any sense.")
                                    }
                                }
                                break
                            default,
                                jprint(" That variable is not valid!")
                                break
                        }
                        FullyDefined[TrackID,number] = ArcStartPosDefined[TrackID,number] & ArcStartDirDefined[TrackID,number] & ArcEndPosDefined[TrackID,number] & ArcEndDirDefined[TrackID,number] & ArcRadiusDefined[TrackID,number] & ArcSegmentsDefined[TrackID,number] & ArcHeightDefined[TrackID,number]
                        if(FullyDefined[TrackID,number]){cprint("Fully Defined!")}
                        break
                    case "banked_arc",
                        switch(Var){
                            case "startpos",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint(" Start Point (startpos): "+(BankedArcStartPosDefined[TrackID,number] ? BankedArcStartPos[TrackID,vector2]:toString() : "Undefined"))
                                }elseif((Arg1!="")&(Arg2!="")){ #Set value
                                    local Vector2 = round(vec2(Arg1:toNumber(),Arg2:toNumber()))
                                    BankedArcStartPos[TrackID,vector2] = Vector2*Scale #Set the Vector. Easy peasy
                                    BankedArcStartPosDefined[TrackID,number] = 1
                                    jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Start Point to "+Vector2:toString()+".")
                                }
                                break
                            case "startdir",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint(" Start Direction (startdir): "+(BankedArcStartDirDefined[TrackID,number] ? BankedArcStartDir[TrackID,number]:toString() : "Undefined"))
                                }elseif(Arg1!=""){ #Set value
                                    local Direction = int(Arg1:toNumber()) #Get Direction number
                                    local Good = 1
                                    if(abs(Direction<=16)){
                                        switch(abs(Direction)){
                                            case 3,
                                                Good = 0
                                                break
                                            case 5,
                                                Good = 0
                                                break
                                            case 11,
                                                Good = 0
                                                break
                                            case 13,
                                                Good = 0
                                                break
                                            default,
                                                
                                                break
                                        }
                                    }else{
                                        Good = 0
                                    }
                                    if(Good){
                                        BankedArcStartDir[TrackID,number] = Arg1:toNumber()
                                        BankedArcStartDirDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Start Direction to "+Direction+".")
                                    }else{
                                        jprint(" Invalid direction! Acceptable direction codes are all integers from 0-16 except 3, 5, 11, and 13 (Negative numbers allowed).")
                                    }
                                }
                                break
                            case "endpos",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint(" End Point (endpos): "+(BankedArcEndPosDefined[TrackID,number] ? BankedArcEndPos[TrackID,vector2]:toString() : "Undefined"))
                                }elseif((Arg1!="")&(Arg2!="")){ #Set value
                                    local Vector2 = round(vec2(Arg1:toNumber(),Arg2:toNumber()))
                                    BankedArcEndPos[TrackID,vector2] = Vector2*Scale #Set the Vector. Easy peasy
                                    BankedArcEndPosDefined[TrackID,number] = 1
                                    jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" End Point to "+Vector2:toString()+".")
                                }
                                break
                            case "enddir",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint(" End Direction (enddir): "+(BankedArcEndDirDefined[TrackID,number] ? BankedArcEndDir[TrackID,number]:toString() : "Undefined"))
                                }elseif(Arg1!=""){ #Set value
                                    local Direction = int(Arg1:toNumber()) #Get Direction number
                                    local Good = 1
                                    if(abs(Direction<=16)){
                                        switch(abs(Direction)){
                                            case 3,
                                                Good = 0
                                                break
                                            case 5,
                                                Good = 0
                                                break
                                            case 11,
                                                Good = 0
                                                break
                                            case 13,
                                                Good = 0
                                                break
                                            default,
                                                
                                                break
                                        }
                                    }else{
                                        Good = 0
                                    }
                                    if(Good){
                                        BankedArcEndDir[TrackID,number] = Arg1:toNumber()
                                        BankedArcEndDirDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" End Direction to "+Direction+".")
                                    }else{
                                        jprint(" Invalid direction! Acceptable direction codes are all integers from 0-16 except 3, 5, 11, and 13 (Negative numbers allowed).")
                                    }
                                }
                                break
                            case "radius",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint(" Arc Radius (radius): "+(BankedArcRadiusDefined[TrackID,number] ? BankedArcRadius[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Radius = round(Arg1:toNumber())
                                    if(Radius>0){
                                        BankedArcRadius[TrackID,number] = Radius*Scale #Set Length. Easy pease
                                        BankedArcRadiusDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Arc Radius to "+Radius+".")
                                    }else{
                                        jprint(" Invalid Length: cannot be less or equal to zero!")
                                    }
                                }
                                break
                            case "height",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint("Height (height): "+(BankedArcHeightDefined[TrackID,number] ? BankedArcHeight[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Height = round(Arg1:toNumber())
                                    BankedArcHeight[TrackID,number] = Height*Scale
                                    BankedArcHeightDefined[TrackID,number] = 1
                                    jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Height to "+Height+".")
                                }
                                break
                            case "segments",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint("Segments (segments): "+(BankedArcSegmentsDefined[TrackID,number] ? BankedArcSegments[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Segments = round(Arg1:toNumber())
                                    if(Segments>0){
                                        BankedArcSegments[TrackID,number] = Segments
                                        BankedArcSegmentsDefined[TrackID,number] = 1
                                        jprint("Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Segments to "+Segments+".")
                                    }else{
                                        jprint("How the hell are you supposed to make a track piece with less than 1 segment? Like come on that doesn't even make any sense.")
                                    }
                                }
                                break
                            case "blendin",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint("Blend In (blendin): "+(BankedArcBlendInDefined[TrackID,number] ? BankedArcBlendIn[TrackID,vector2]:toString() : "Undefined"))
                                }elseif((Arg1!="")&(Arg2!="")){ #Set value
                                    local Vector2 = round(vec2(Arg1:toNumber(),Arg2:toNumber()))
                                    BankedArcBlendIn[TrackID,vector2] = Vector2 #Set the Vector. Easy peasy
                                    BankedArcBlendInDefined[TrackID,number] = 1
                                    jprint("Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Blend In to Joints "+Vector2:x():toString()+" to "+Vector2:y():toString()+" (From Start).")
                                }
                                break
                            case "blendout",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint("Blend Out (blendout): "+(BankedArcBlendOutDefined[TrackID,number] ? BankedArcBlendOut[TrackID,vector2]:toString() : "Undefined"))
                                }elseif((Arg1!="")&(Arg2!="")){ #Set value
                                    local Vector2 = round(vec2(Arg1:toNumber(),Arg2:toNumber()))
                                    BankedArcBlendOut[TrackID,vector2] = Vector2 #Set the Vector. Easy peasy
                                    BankedArcBlendOutDefined[TrackID,number] = 1
                                    jprint("Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Blend Out to Joints "+Vector2:x():toString()+" to "+Vector2:y():toString()+" (From End).")
                                }
                                break
                            default,
                                jprint("That variable is not valid!")
                                break
                        }
                        FullyDefined[TrackID,number] = BankedArcStartPosDefined[TrackID,number] & BankedArcStartDirDefined[TrackID,number] & BankedArcEndPosDefined[TrackID,number] & BankedArcEndDirDefined[TrackID,number] & BankedArcRadiusDefined[TrackID,number] & BankedArcSegmentsDefined[TrackID,number] & BankedArcHeightDefined[TrackID,number] & BankedArcBlendInDefined[TrackID,number] & BankedArcBlendOutDefined[TrackID,number]
                        if(FullyDefined[TrackID,number]){cprint("Fully Defined!")}
                        break
               
                    case "bezier",
                        switch(Var){
                            case "startpos",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint(" Start Point (startpos): "+(BezStartPosDefined[TrackID,number] ? BezStartPos[TrackID,vector2]:toString() : "Undefined"))
                                }elseif((Arg1!="")&(Arg2!="")){ #Set value
                                    local Vector2 = round(vec2(Arg1:toNumber(),Arg2:toNumber()))
                                    BezStartPos[TrackID,vector2] = Vector2*Scale #Set the Vector. Easy peasy
                                    BezStartPosDefined[TrackID,number] = 1
                                    jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Start Point to "+Vector2:toString()+".")
                                }
                                break
                            case "startdir",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint(" Start Direction (startdir): "+(BezStartDirDefined[TrackID,number] ? BezStartDir[TrackID,number]:toString() : "Undefined"))
                                }elseif(Arg1!=""){ #Set value
                                    local Direction = int(Arg1:toNumber()) #Get Direction number
                                    local Good = 1
                                    if(abs(Direction<=16)){
                                        switch(abs(Direction)){
                                            case 3,
                                                Good = 0
                                                break
                                            case 5,
                                                Good = 0
                                                break
                                            case 11,
                                                Good = 0
                                                break
                                            case 13,
                                                Good = 0
                                                break
                                            default,
                                                
                                                break
                                        }
                                    }else{
                                        Good = 0
                                    }
                                    if(Good){
                                        BezStartDir[TrackID,number] = Arg1:toNumber()
                                        BezStartDirDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Start Direction to "+Direction+".")
                                    }else{
                                        jprint(" Invalid direction! Acceptable direction codes are all integers from 0-16 except 3, 5, 11, and 13 (Negative numbers allowed).")
                                    }
                                }
                                break
                            case "endpos",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint(" End Point (endpos): "+(BezEndPosDefined[TrackID,number] ? BezEndPos[TrackID,vector2]:toString() : "Undefined"))
                                }elseif((Arg1!="")&(Arg2!="")){ #Set value
                                    local Vector2 = round(vec2(Arg1:toNumber(),Arg2:toNumber()))
                                    BezEndPos[TrackID,vector2] = Vector2*Scale #Set the Vector. Easy peasy
                                    BezEndPosDefined[TrackID,number] = 1
                                    jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" End Point to "+Vector2:toString()+".")
                                }
                                break
                            case "enddir",
                                if(Arg1==""){ #Show value (If one exists)
                                    jprint(" End Direction (enddir): "+(BezEndDirDefined[TrackID,number] ? BezEndDir[TrackID,number]:toString() : "Undefined"))
                                }elseif(Arg1!=""){ #Set value
                                    local Direction = int(Arg1:toNumber()) #Get Direction number
                                    local Good = 1
                                    if(abs(Direction<=16)){
                                        switch(abs(Direction)){
                                            case 3,
                                                Good = 0
                                                break
                                            case 5,
                                                Good = 0
                                                break
                                            case 11,
                                                Good = 0
                                                break
                                            case 13,
                                                Good = 0
                                                break
                                            default,
                                                
                                                break
                                        }
                                    }else{
                                        Good = 0
                                    }
                                    if(Good){
                                        BezEndDir[TrackID,number] = Arg1:toNumber()
                                        BezEndDirDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" End Direction to "+Direction+".")
                                    }else{
                                        jprint(" Invalid direction! Acceptable direction codes are all integers from 0-16 except 3, 5, 11, and 13 (Negative numbers allowed).")
                                    }
                                }
                                break
                            case "startcp",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint(" Start CP Length (startcp): "+(BezStartCPLengthDefined[TrackID,number] ? BezStartCPLength[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Length = round(Arg1:toNumber())
                                    if(Length>0){
                                        BezStartCPLength[TrackID,number] = Length*Scale #Set Length. Easy pease
                                        BezStartCPLengthDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Start CP Length to "+Length+".")
                                    }else{
                                        jprint(" Invalid Length: cannot be less or equal to zero!")
                                    }
                                }
                                break
                            case "endcp",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint(" End CP Length (endcp): "+(BezEndCPLengthDefined[TrackID,number] ? BezEndCPLength[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Length = round(Arg1:toNumber())
                                    if(Length>0){
                                        BezEndCPLength[TrackID,number] = Length*Scale #Set Length. Easy pease
                                        BezEndCPLengthDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" End CP Length to "+Length+".")
                                    }else{
                                        jprint(" Invalid Length: cannot be less or equal to zero!")
                                    }
                                }
                                break
                            case "cp",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint(" Start CP Length (startcp): "+(BezStartCPLengthDefined[TrackID,number] ? BezStartCPLength[TrackID,number]:toString() : "Undefined"))
                                    jprint(" End CP Length (startcp): "+(BezEndCPLengthDefined[TrackID,number] ? BezEndCPLength[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Length = round(Arg1:toNumber())
                                    if(Length>0){
                                        BezStartCPLength[TrackID,number] = Length*Scale #Set Length. Easy pease
                                        BezStartCPLengthDefined[TrackID,number] = 1
                                        BezEndCPLength[TrackID,number] = Length*Scale #Set Length. Easy pease
                                        BezEndCPLengthDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Start and End CP Lengths to "+Length+".")
                                    }else{
                                        jprint(" Invalid Length: cannot be less or equal to zero!")
                                    }
                                }
                                break
                            case "height",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint(" Height (height): "+(BezHeightDefined[TrackID,number] ? BezHeight[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Height = round(Arg1:toNumber())
                                    BezHeight[TrackID,number] = Height*Scale
                                    BezHeightDefined[TrackID,number] = 1
                                    jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Height to "+Height+".")
                                }
                                break
                            case "segments",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint(" Segments (segments): "+(BezSegmentsDefined[TrackID,number] ? BezSegments[TrackID,number]:toString() : "Undefined"))
                                }else{ #Set Value
                                    local Segments = round(Arg1:toNumber())
                                    if(Segments>0){
                                        BezSegments[TrackID,number] = Segments
                                        BezSegmentsDefined[TrackID,number] = 1
                                        jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Segments to "+Segments+".")
                                    }else{
                                        jprint(" How the hell are you supposed to make a track piece with less than 1 segment? Like come on that doesn't even make any sense.")
                                    }
                                }
                                break
                            case "xover",
                                if(Arg1==""){ #Show Value (if one exists)
                                    jprint(" Crossover (xover): "+BezXovers[TrackID,number]:toString())
                                }else{ #Set Value
                                    local Xover = Arg1:toNumber()
                                    BezXovers[TrackID,number] = Xover
                                    jprint(" Set Piece "+TrackID+" \""+TrackNames[TrackID,string]+"\" Crossover to "+Xover+".")
                                }
                            default,
                                jprint(" That variable is not valid!")
                                break
                        }
                        FullyDefined[TrackID,number] = BezStartPosDefined[TrackID,number] & BezStartDirDefined[TrackID,number] & BezEndPosDefined[TrackID,number] & BezEndDirDefined[TrackID,number] & BezStartCPLengthDefined[TrackID,number] & BezEndCPLengthDefined[TrackID,number] & BezSegmentsDefined[TrackID,number] & BezHeightDefined[TrackID,number]
                        if(FullyDefined[TrackID,number]){cprint("Fully Defined!")}
                        break
                        
                    case "switch",
                        switch(Var){
                            case "mainpiece",
                                if(Arg1==""){
                                    jprint("Main Piece (mainpiece): "+(SwitchMainPieceDefined[TrackID,number] ? "Piece No. "+SwitchMainPiece[TrackID,number]:toString() : "Undefined"))
                                    #jprint("Diverging Piece (div): "+(SwitchDivPieceDefined[TrackID,number] ? "Piece No. "+SwitchDivPiece[TrackID,number]:toString() : "Undefined"))
                                }else{
                                    local Found = 0
                                    local ToSelect = Arg1
                                    local TID = 0
                                    if(ToSelect:toNumber()!=0){ #Select By Number
                                        TID = ToSelect:toNumber()
                                        if(TID<=TrackNames:count()){
                                            Found = 1
                                            jprint("Main Piece set to "+TID:toString()+", \""+TrackNames[TID,string]+"\" ("+TrackTypes[TID,string]+")")
                                            SwitchMainPiece[TrackID,number] = TID
                                            SwitchMainPieceDefined[TrackID,number] = 1
                                        }else{
                                            jprint("That number is not defined!")
                                        }
                                    }else{ #Select by Name
                                        foreach(K,V:string=TrackNames){
                                            if(V==ToSelect){
                                                TID = K
                                                jprint("Main Piece set to "+TID:toString()+", \""+TrackNames[TID,string]+"\" ("+TrackTypes[TID,string]+")")
                                                SwitchMainPiece[TrackID,number] = TID
                                                SwitchMainPieceDefined[TrackID,number] = 1
                                                Found = 1
                                                #break
                                            }
                                        }
                                        if(!Found){
                                            jprint("There is no track piece with that name! ("+ToSelect+")")
                                        }
                                    }
                                    if(TrackTypes[SwitchDivPiece[TrackID,number],string]=="switch"){
                                        jprint("WARNING! You can't use switches to make other switches!")
                                    }
                                }
                            break
                        case "divpiece",
                                if(Arg1==""){
                                    jprint("Diverging Piece (divpiece): "+(SwitchDivPieceDefined[TrackID,number] ? "Piece No. "+SwitchDivPiece[TrackID,number]:toString() : "Undefined"))
                                }else{
                                    local Found = 0
                                    local ToSelect = Arg1
                                    local TID = 0
                                    if(ToSelect:toNumber()!=0){ #Select By Number
                                        TID = ToSelect:toNumber()
                                        if(TID<=TrackNames:count()){
                                            Found = 1
                                            jprint("Diverging Piece set to "+TID:toString()+", \""+TrackNames[TID,string]+"\" ("+TrackTypes[TID,string]+")")
                                            SwitchDivPiece[TrackID,number] = TID
                                            SwitchDivPieceDefined[TrackID,number] = 1
                                        }else{
                                            jprint("That number is not defined!")
                                        }
                                    }else{ #Select by Name
                                        foreach(K,V:string=TrackNames){
                                            if(V==ToSelect){
                                                TrackID = K
                                                jprint("Diverging Piece set to "+TID:toString()+", \""+TrackNames[TID,string]+"\" ("+TrackTypes[TID,string]+")")
                                                SwitchDivPiece[TrackID,number] = TID
                                                SwitchDivPieceDefined[TrackID,number] = 1
                                                Found = 1
                                                #break
                                            }
                                        }
                                        if(!Found){
                                            jprint("There is no track piece with that name! ("+ToSelect+")")
                                        }
                                    }
                                    if(TrackTypes[SwitchDivPiece[TrackID,number],string]=="switch"){
                                        jprint("WARNING! You can't use switches to make other switches!")
                                    }
                                }
                            break
                        case "split",
                            if(Arg1==""){
                                cprint("Piece to split (split): "+(SwitchSplitDefined[TrackID,number] ? +SwitchSplit[TrackID,string] : "Undefined"))
                            }else{
                                if(Arg1:find("m")){
                                    SwitchSplit[TrackID,string] = "main"
                                    SwitchSplitDefined[TrackID,number] = 1
                                    jprint("Set piece with bigger segments to \"main\". The main piece will be split up as necessary.")
                                }elseif(Arg1:find("d")){
                                    SwitchSplit[TrackID,string] = "diverging"
                                    SwitchSplitDefined[TrackID,number] = 1
                                    jprint("Set piece with bigger segments to \"diverging\". The diverging piece will be split up as necessary.")
                                }else{
                                    SwitchSplit[TrackID,string] = "none"
                                    SwitchSplitDefined[TrackID,number] = 1
                                    jprint("Set piece with bigger segments to \"none\". Segments will be joined on a 1:1 ratio.")
                                }
                            }
                            break
                        }
                        
                        FullyDefined[TrackID,number] = SwitchMainPieceDefined[TrackID,number] & SwitchDivPieceDefined[TrackID,number] & SwitchSplitDefined[TrackID,number]
                        if(FullyDefined[TrackID,number]){cprint("Fully Defined!")}
                        
                        break
                    default,
                        break
                }
            }
            
            hideChat(1)
            break
        case ".plot",
            local TrackID = 0
            if(Sentence[2,string]==""){
                TrackID = SelectedTrack
            }else{
                TrackID = Sentence[2,string]:toNumber()
            }
            #printTable(FullyDefined)
            local TrackType = TrackTypes[TrackID,string]
            if(FullyDefined[TrackID,number]){
                
                switch(TrackType){
                    case "straight",
                        local StartPos = StraightStartPos[TrackID,vector2]
                        local Dir = StraightDir[TrackID,number]
                        local Length = StraightLength[TrackID,number]
                        local Height = StraightHeight[TrackID,number]
                        local Segs = StraightSegments[TrackID,number]
                        
                        #Calculate Total Displacement
                        local D2 = tp3dir(Dir)
                        local Displacement = vec(D2*Length,Height)
                        
                        
                        #Plot Points (easy peasy)
                        local Points = array()
                        local StartPoint = vec(StartPos,0)
                        Points[0,vector] = StartPoint #Point 0 is Start Point
                        
                        for(N=1,Segs){
                            Points[N,vector] = round(StartPoint + (N/Segs)*Displacement) #Each Successive point is a proper fraction of the total displacement, defined by number of segs
                        }
                        #Calculate Total Grade
                        local Grade = round(100*Height/(Displacement:length()),2) #Rise over Run x 100%
                        
                        
                        #Trace Directions
                        local Trace = array()
                        for(N=0,Segs){
                            Trace[N,vector] = vec(0,0,Dir)
                        }
                        
                        Traces[TrackID,array] = Trace
                        Plots[TrackID,array] = Points
                        Plotted[TrackID,number] = 1
                        jprint(" Plotted straight piece ("+TrackID+") from "+Points[0,vector]+" to "+Points[Segs,vector]+" (displacement "+Displacement+"). Average Grade: "+Grade+"%.")
                        if(AutoName){
                            
                            #straights/s(Length)_(Dir)_(Grade)_(Dims)
                            
                            #Init
                            local NewName = "trakpak3_"+GaugeName+"/straights/s"
                            
                            #Length
                            NewName += pad4(Length/Scale)+"_"
                            
                            #Direction
                            if(Dir==0){
                                NewName += "0fw_"
                            }elseif(Dir>0){
                                NewName += Dir+"lt_"
                            }else{
                                NewName += abs(Dir)+"rt_"
                            }
                            
                            #Percent Grade
                            local GR = round(Grade,2)
                            local GS = toString(GR):replace(".","")
                            NewName += GS+"pg_"
                            
                            #Dimensions
                            local DF = pad4s((Displacement:y()/Scale))
                            local DL = pad4s((Displacement:x()/Scale))
                            local DH = pad3s((Height)/Scale)
                            if(Height>0){
                                DH += "up"
                            }elseif(Height<0){
                                DH += "dn"
                            }
                            NewName += DF+"x"+DL+"x"+DH
                            
                            #Double Rail Precision
                            if(SMDQC & DoubleRailPrecision){NewName += "_drp"}
                            
                            #Rename
                            timer(".rename "+TrackID+" "+NewName,50)
                            
                        }
                        timer(".trackjoints "+TrackID,100)
                        
                        break
                    case "arc",
                    case "banked_arc",
                        local Banked = TrackType=="banked_arc"
                        
                        local StartPos = (Banked ? BankedArcStartPos : ArcStartPos)[TrackID,vector2]
                        local StartDir = (Banked ? BankedArcStartDir : ArcStartDir)[TrackID,number]
                        local EndPos = (Banked ? BankedArcEndPos : ArcEndPos)[TrackID,vector2]
                        local EndDir = (Banked ? BankedArcEndDir : ArcEndDir)[TrackID,number]
                        local Radius = (Banked ? BankedArcRadius : ArcRadius)[TrackID,number]
                        local Height = (Banked ? BankedArcHeight : ArcHeight)[TrackID,number]
                        local Segs = (Banked ? BankedArcSegments : ArcSegments)[TrackID,number]
                        
                        #Figure out if it's a left or right curve
                        
                        local DV1 = tp3dir(StartDir)
                        local DV2 = tp3dir(EndDir)
                        
                        #Find "Dir:right()" so to speak - Multiply by 4, Rotate by -90 degrees, round, divide by 4 again
                        local DR1 = round((DV1*4):rotate(-90))/4
                        #Dot Product to find general left/right curvature
                        local CurveRight = (DR1:dot(DV2)) > 0
                        
                        local Curvature = sign(EndDir-StartDir) #+1 left, -1 right
                        
                        if(Banked){BankedArcGoesLeft[TrackID,number] = !CurveRight}
                        
                        local Center = vec2()
                        local Error = 0
                        
                        if(CurveRight){ #Curve goes right
                            local SPI = StartPos + Radius*DR1:normalized() #Find a point for center line 1
                            local DR2 = round((DV2*4):rotate(-90))/4
                            local EPI = EndPos + Radius*DR2:normalized() #Find a point for center line 2
                            
                            #print(SPI,DV1)
                            #print(EPI,DV2)
                            
                            #Calculate Center Lines
                            local CL1 = line(SPI,DV1)
                            local CL2 = line(EPI,DV2)
                            
                            local CenterARRAY = intersection(CL1,CL2)
                            #print("right ",CL1,CL2,CenterARRAY)
                            if(CenterARRAY[1,number]==0){ #If no error then
                                Center = CenterARRAY[2,vector2]
                            }else{
                                Error = 1
                            }
                        }else{ #Curve goes left
                            local SPI = StartPos - Radius*DR1:normalized() #Find a point for center line 1
                            local DR2 = round((DV2*4):rotate(-90))/4
                            local EPI = EndPos - Radius*DR2:normalized() #Find a point for center line 2
                            
                            #Calculate Center Lines
                            local CL1 = line(SPI,DV1)
                            local CL2 = line(EPI,DV2)
                            
                            local CenterARRAY = intersection(CL1,CL2)
                            #print("left ",CL1,CL2,CenterARRAY)
                            if(CenterARRAY[1,number]==0){ #If no error then
                                Center = CenterARRAY[2,vector2]
                            }else{
                                Error = 1
                            }
                        }
                        
                        if(!Error){ #You really shouldn't get an error because that only happens if the two directions are parallel...
                            
                            #Calculate the start and end angles for the arc
                            local Ang1 = atan(DV1:y(),DV1:x()) + (CurveRight ? 90 : -90)
                            local Ang2 = atan(DV2:y(),DV2:x()) + (CurveRight ? 90 : -90)
                            local Swing = Ang2-Ang1
                            
                            #Calculate the start/end point on the circle
                            local StartSwing = Center + Radius*vec2(cos(Ang1),sin(Ang1))
                            local EndSwing = Center + Radius*vec2(cos(Ang2),sin(Ang2))
                            
                            local FinalIndex = 0
                            local Points = array()
                            
                            local HasStartSeg = 0
                            local HasEndSeg = 0
                            
                            if(round(StartSwing)==StartPos){ #No Start Segment Needed
                                for(N=0,Segs){
                                    local AngX = Ang1 + Swing*(N/Segs)
                                    Points[N,vector] = vec(Center + Radius*vec2(cos(AngX),sin(AngX)),0)
                                }
                                FinalIndex = Segs
                            }elseif(((StartSwing-StartPos):dot(DV1))>0){ #Need Start Segment
                                HasStartSeg = 1
                                HasLead[SelectedTrack,number] = 1
                                Points[0,vector] = vec(StartPos,0)
                                
                                #print(Segs+1)
                                for(N=1,Segs+1){
                                    local AngX = Ang1 + Swing*((N-1)/(Segs))
                                    Points[N,vector] = vec(Center + Radius*vec2(cos(AngX),sin(AngX)),0)
                                }
                                FinalIndex = Segs+1
                            }else{ #Radius too large
                                Error = 1
                            }
                            if(!Error){
                                if(round(EndSwing)==EndPos){ #No End Segment Needed
                                    #Do Nothing
                                }elseif(((EndPos-EndSwing):dot(DV2))>0){ #Need End Segment
                                    HasEndSeg = 1
                                    FinalIndex += 1
                                    Points[FinalIndex,vector] = vec(EndPos,0)
                                }else{ #Radius too large
                                    Error = 1
                                }
                                if(!Error){
                                    #Calculate Segment Lengths
                                    local Lengths = array()
                                    local TotalLength = 0
                                    #print("A")
                                    for(N=1,Points:count()){
                                        local L = Points[N,vector]:distance(Points[N-1,vector])
                                        Lengths[N,number] = L
                                        TotalLength += L
                                    }
                                    
                                    #Trace Directions
                                    local Trace = array()
                                    Trace[0,vector] = vec(0,0,StartDir) #First Trace is always StartDir
                                    if(HasStartSeg){ #If you have a start segment, 2nd trace is also StartDir
                                        Trace[1,vector] = vec(0,0,StartDir)
                                    }
                                    #print("FI "+FinalIndex)
                                    for(N=1+HasStartSeg,FinalIndex-1-HasEndSeg){
                                        Trace[N,vector] = vec(getTangent(Points[N-1,vector],Points[N,vector],Points[N+1,vector]),0)
                                    }
                                    if(HasEndSeg){
                                        Trace[FinalIndex-1,vector] = vec(0,0,EndDir)
                                    }
                                    Trace[FinalIndex,vector] = vec(0,0,EndDir)
                                    #print("Final Index: "+FinalIndex)
                                    #printTable(Trace)
                                    #Adjust Heights
                                    local H = 0
                                    #print("B")
                                    for(N=1,Points:count()-1){
                                        local Point = Points[N,vector]
                                        local X = Point:x()
                                        local Y = Point:y()
                                        local L = Lengths[N,number]
                                        #dH/dL = H/L -> dH = HdL/L
                                        local DH = Height*L/TotalLength
                                        local Z = H + DH
                                        H = Z
                                        Points[N,vector] = vec(X,Y,Z)
                                    }
                                    #print("C")
                                    local Point = Points[Points:count(),vector] #Set height of last point just in case the calculation introduced error
                                    local X = Point:x()
                                    local Y = Point:y()
                                    local Z = Height
                                    #print("D")
                                    Points[Points:count(),vector] = vec(X,Y,Z)
                                    
                                    local Grade = round(100*(Height/TotalLength),2) #Avg Grade Calculation
                                    Traces[TrackID,array] = Trace
                                    Plots[TrackID,array] = Points
                                    Plotted[TrackID,number] = 1
                                    #print("E")
                                    jprint(" Plotted "+(Banked ? "banked_arc" : "arc")+" piece ("+TrackID+") from "+Points[0,vector]+" to "+Points[Points:count(),vector]+". Average Grade: "+Grade+"%.")
                                    
                                    if(AutoName){
                                        #arcs/r(Radius)/a(StartDir)_(EndDir)_(Curvature)_(Grade)_(Dims)
                                        #banked/r(Radius)/ab(StartDir)_(EndDir)_(Curvature)_(Grade)_(StartBanked)(EndBanked)_(Dims)
                                        
                                        #Init
                                        local NewName = "trakpak3_"+GaugeName+"/"+(Banked ? "banked" : "arcs")+"/"
                                        
                                        #Radius
                                        NewName += "r"+pad4(Radius/Scale)+"/"+(Banked ? "ab" : "a")
                                        
                                        #Direction
                                        if(StartDir==0){
                                            NewName += "0fw_"
                                        }elseif(StartDir>0){
                                            NewName += StartDir+"lt_"
                                        }else{
                                            NewName += abs(StartDir)+"rt_"
                                        }
                                        if(EndDir==0){
                                            NewName += "0fw_"
                                        }elseif(EndDir>0){
                                            NewName += EndDir+"lt_"
                                        }else{
                                            NewName += abs(EndDir)+"rt_"
                                        }
                                        
                                        #Curvature
                                        NewName += (Curvature>0 ? "left" : "right")+"_"
                                        
                                        #Percent Grade
                                        local GR = round(Grade,2)
                                        local GS = toString(GR):replace(".","")
                                        NewName += GS+"pg_"
                                        
                                        
                                        if(Banked){
                                            #Bank Height + Segments
                                            
                                            NewName += BankHeight+"h_"+Segs+"s_"
                                            
                                            #Banking Indicator
                                            
                                            local InSmoothing = BankedArcBlendIn[TrackID,vector2]
                                            local OutSmoothing = BankedArcBlendOut[TrackID,vector2]
                                            
                                            local StartBanked = InSmoothing==vec2() #start joint, end joint (from start)
                                            local EndBanked = OutSmoothing==vec2() #start joint, end joint (from end)
                                            
                                            NewName += InSmoothing:x() + (StartBanked ? "b" : "f") + InSmoothing:y()+"_"
                                            NewName += OutSmoothing:y() + (EndBanked ? "b" : "f") + OutSmoothing:x()+"_"
                                            #NewName += (StartBanked ? "b" : "f")+(EndBanked ? "b_" : "f_")
                                        }
                                        
                                        #Dimensions
                                        local DF = pad4s(((EndPos-StartPos):y()/Scale))
                                        local DL = pad4s(((EndPos-StartPos):x()/Scale))
                                        local DH = pad3s((Height)/Scale)
                                        if(Height>0){
                                            DH += "up"
                                        }elseif(Height<0){
                                            DH += "dn"
                                        }
                                        NewName += DF+"x"+DL+"x"+DH
                                        
                                        #Double Rail Precision
                                        if(SMDQC & DoubleRailPrecision){NewName += "_drp"}
                                        
                                        #Rename
                                        timer(".rename "+TrackID+" "+NewName,50)
                                        
                                    }
                                    timer(".trackjoints "+TrackID,100)
                                }
                            }
                            if(Error){
                                jprint(" Curve radius is too large! Move endpoints out or reduce curve radius!")
                            }
                            
                            
                            
                        }else{
                            jprint(" Something's Fucky!")
                        }
                        
                        break
                    case "bezier",
                        local StartPos = BezStartPos[TrackID,vector2]
                        local EndPos = BezEndPos[TrackID,vector2]
                        local StartDir = BezStartDir[TrackID,number]
                        local EndDir = BezEndDir[TrackID,number]
                        local StartCPLength = BezStartCPLength[TrackID,number]
                        local EndCPLength = BezEndCPLength[TrackID,number]
                        local Height = BezHeight[TrackID,number]
                        local Segs = BezSegments[TrackID,number]
                        
                        local IsBend = (EndDir==StartDir)
                        local Curvature = 0
                        
                        #Get Start and End Directions
                        local DV1 = tp3dir(StartDir)
                        local DV2 = tp3dir(EndDir)
                        
                        if(IsBend){
                            Curvature = sign(DV1:cross(EndPos-StartPos)) #+1 for left, -1 for right
                        }else{
                            Curvature = sign(EndDir-StartDir) #+1 for left, -1 for right
                        }
                        
                        #Calculate control points
                        local CP1 = StartPos + StartCPLength*DV1
                        local CP2 = EndPos - EndCPLength*DV2
                        
                        #print(CP1,CP2)
                        #debugHolo(1,CP1,vec(255,0,0),0)
                        #debugHolo(2,CP2,vec(255,0,0),0)
                        
                        #Plot points on 2D plane
                        local Points = array()
                        
                        for(N=0,Segs){
                            local AB = mid2(StartPos,CP1,N/Segs)
                            local BC = mid2(CP1,CP2,N/Segs)
                            local CD = mid2(CP2,EndPos,N/Segs)
                            local ABC = mid2(AB,BC,N/Segs)
                            local BCD = mid2(BC,CD,N/Segs)
                            Points[N,vector] = vec(mid2(ABC,BCD,N/Segs),0)
                            #debugHolo(N,vec2(Points[N,vector]),vec(255,0,0),0)
                        }
                        
                        #Calculate Segment Lengths
                        local Lengths = array()
                        local TotalLength = 0
                        for(N=1,Points:count()){
                            local L = Points[N,vector]:distance(Points[N-1,vector])
                            Lengths[N,number] = L
                            TotalLength += L
                        }
                        #Trace Directions
                        local Trace = array()
                        Trace[0,vector] = vec(0,0,StartDir)
                        for(N=1,Segs-1){
                            Trace[N,vector] = vec(getTangent(Points[N-1,vector],Points[N,vector],Points[N+1,vector]),0)
                            #print(Trace[N,vector])
                        }
                        Trace[Segs,vector] = vec(0,0,EndDir)
                        
                        #Calculate radii from DT rotated Intersections
                        TightestPoint = 0
                        local Radius = 65536
                        
                        for(N=1,Segs-1){
                            #Rotate the axes
                            local DRC = vec2(Trace[N,vector]):rotate(-90)
                            local DRP = vec2(Trace[N-1,vector]):rotate(-90)
                            #print(DRC,DRP)
                            #Make Lines
                            local CLC = line(vec2(Points[N,vector]),DRC)
                            local CLP = line(vec2(Points[N-1,vector]),DRP)
                            
                            local ISCT = intersection(CLC,CLP)
                            #printTable(ISCT)
                            if(!ISCT[1,number]){ #Not Parallel
                                local NewRadius = vec2(Points[N,vector]):distance(ISCT[2,vector2])
                                if(NewRadius < Radius){
                                    Radius = NewRadius
                                    TightestPoint = N
                                    #Pinch = ISCT[2,vector2]
                                    #Pinch2 = vec2(Points[N,vector])
                                }
                            }else{ #Parallel
                                #Do Nothing
                            }
                        }
                        Radius /= Scale
                        #debugHolo(1,Pinch,vec(255,0,0),0)
                        #debugHolo(2,Pinch2,vec(255,255,0),0)
                        
                        #Adjust Heights
                        local H = 0
                        #print("B")
                        for(N=1,Points:count()-1){
                            local Point = Points[N,vector]
                            local X = Point:x()
                            local Y = Point:y()
                            local L = Lengths[N,number]
                            #dH/dL = H/L -> dH = HdL/L
                            local DH = Height*L/TotalLength
                            local Z = H + DH
                            H = Z
                            Points[N,vector] = vec(X,Y,Z)
                        }
                        #print("C")
                        local Point = Points[Points:count(),vector] #Set height of last point just in case the calculation introduced error
                        local X = Point:x()
                        local Y = Point:y()
                        local Z = Height
                        #print("D")
                        Points[Points:count(),vector] = vec(X,Y,Z)
                        
                        local Grade = round(100*(Height/TotalLength),2) #Avg Grade Calculation
                        Plots[TrackID,array] = Points
                        Plotted[TrackID,number] = 1
                        Traces[TrackID,array] = Trace
                        #print("E")
                        BezMinRadius[TrackID,number] = Radius
                        jprint(" Plotted bezier piece ("+TrackID+") from "+Points[0,vector]+" to "+Points[Points:count(),vector]+" (Min Curve Radius "+round(Radius,2)+"). Average Grade: "+Grade+"%.")
                        if(AutoName){
                            
                            #bends/b(StartDir)_(Curvature)_minr(MinR)_(Grade)_(Dims)
                            #dynamics/d(StartDir)_(EndDir)_(Curvature)_minr(MinR)_(Grade)_(Dims)
                            
                            #Init
                            local NewName = "trakpak3_"+GaugeName+"/"+(IsBend ? "bends/b" : "dynamics/d")
                            
                            #Direction
                            if(StartDir==0){
                                NewName += "0fw_"
                            }elseif(StartDir>0){
                                NewName += StartDir+"lt_"
                            }else{
                                NewName += abs(StartDir)+"rt_"
                            }
                            if(!IsBend){
                                if(EndDir==0){
                                    NewName += "0fw_"
                                }elseif(EndDir>0){
                                    NewName += EndDir+"lt_"
                                }else{
                                    NewName += abs(EndDir)+"rt_"
                                }
                            }
                            
                            #Curvature
                            NewName += (Curvature>0 ? "left" : "right")+"_"
                            
                            #Radius
                            local MinR = (Radius):minsnap(array(0,512,1024,1536,2048,3072,4096,6144,8192,12288,16384))
                            NewName += "minr"+pad4(MinR)+"_"
                            
                            
                            #Percent Grade
                            local GR = round(Grade,2)
                            local GS = toString(GR):replace(".","")
                            NewName += GS+"pg_"
                            
                            #Dimensions
                            local DF = pad4s(((EndPos-StartPos):y()/Scale))
                            local DL = pad4s(((EndPos-StartPos):x()/Scale))
                            local DH = pad3s((Height)/Scale)
                            if(Height>0){
                                DH += "up"
                            }elseif(Height<0){
                                DH += "dn"
                            }
                            NewName += DF+"x"+DL+"x"+DH
                            
                            #Double Rail Precision
                            if(SMDQC & DoubleRailPrecision){NewName += "_drp"}
                            
                            #Rename
                            timer(".rename "+TrackID+" "+NewName,50)
                            
                        }
                        timer(".trackjoints "+TrackID,100)
                        
                        break
                    case "switch",
                        
                        #Get Info
                        local AllGood = 1
                        
                        local MN = SwitchMainPiece[TrackID,number]
                        local DV = SwitchDivPiece[TrackID,number]
                        
                        local PlottedMN = Plotted[MN,number]
                        local PlottedDV = Plotted[DV,number]
                        
                        local FlatMN = 0
                        local FlatDV = 0
                        
                        local StartPMN = vec2()
                        local StartPDV = vec2()
                        local EndPMN = vec2()
                        local EndPDV = vec2()
                        local StartDMN = 0
                        local StartDDV = 0
                        local EndDMN = 0
                        local EndDDV = 0
                        
                        local TypeMN = TrackTypes[MN,string]
                        local TypeDV = TrackTypes[DV,string]
                        
                        #print(TypeMN,TypeDV)
                        
                        switch(TypeMN){
                            case "straight",
                                StartPMN = StraightStartPos[MN,vector2]
                                StartDMN = StraightDir[MN,number]
                                EndDMN = StraightDir[MN,number]
                                EndPMN = StartPMN + tp3dir(StartDMN)*StraightLength[MN,number]
                                FlatMN = StraightHeight[MN,number]==0
                                break
                            case "arc",
                                StartPMN = ArcStartPos[MN,vector2]
                                EndPMN = ArcEndPos[MN,vector2]
                                StartDMN = ArcStartDir[MN,number]
                                EndDMN = ArcEndDir[MN,number]
                                FlatMN = ArcHeight[MN,number]==0
                                break
                            case "bezier",
                                StartPMN = BezStartPos[MN,vector2]
                                EndPMN = BezEndPos[MN,vector2]
                                StartDMN = BezStartDir[MN,number]
                                EndDMN = BezEndDir[MN,number]
                                FlatMN = BezHeight[MN,number]==0
                                break
                            default,
                                jprint("Main Piece is unacceptable track type! ("+TypeMN+")")
                                AllGood = 0
                                break
                        }
                        switch(TypeDV){ #DV piece cannot be a straight
                            case "arc",
                                StartPDV = ArcStartPos[DV,vector2]
                                EndPDV = ArcEndPos[DV,vector2]
                                StartDDV = ArcStartDir[DV,number]
                                EndDDV = ArcEndDir[DV,number]
                                FlatDV = ArcHeight[DV,number]==0
                                break
                            case "bezier",
                                StartPDV = BezStartPos[DV,vector2]
                                EndPDV = BezEndPos[DV,vector2]
                                StartDDV = BezStartDir[DV,number]
                                EndDDV = BezEndDir[DV,number]
                                FlatDV = BezHeight[DV,number]==0
                                break
                            default,
                                jprint("Diverging Piece is unacceptable track type! ("+TypeDV+")")
                                AllGood = 0
                                break
                        }
                        
                        
                        #Check Plots
                        if(!(PlottedMN & PlottedDV)){
                            jprint("One or both pieces is not yet plotted!")
                            AllGood = 0
                        }
                        #Check StartPos
                        if(StartPMN != StartPDV){
                            jprint("Pieces must share a common start point!")
                            AllGood = 0
                        }else{
                            CardinalPoint = StartPMN
                        }
                        #Check StartDir
                        if(StartDMN != StartDDV){
                            jprint("Pieces must share a common start direction!")
                            AllGood = 0
                        }else{
                            CardinalDir = tp3dir(StartDMN):normalized()
                        }
                        #Check Flat
                        if(!(FlatMN & FlatDV)){
                            jprint("Pieces must both be flat (Height 0)!")
                            AllGood = 0
                        }
                        
                        if(AllGood){ #Everything is ok so you can perform the analysis. Assume Trackjoints has been completed.
                            #The Algorithm for making switches:
                            #1 - Compare the minimum point-to-point distance (not including leads) and find which piece has bigger segments - manually specified
                            #2 - Identify all segments which intersect and mark them somehow (start at the joint and move out) - done
                            #3 - For all vertices in the smaller piece, split the larger brush horizontally (relative to dir of larger piece). Record the new verts, and specify which is the "inner" one
                            #4 - Find the midpoint of each vertex on the intersecting brushes (except for the last one) and snap them together
                            #5 - For the last pair (which should not intersect), split the segment to triangulate so a new vertex appears at the intersection point
                            #6 - Use the functions to make brushes given the groups of points, using the texture alignments of the base curves
                            #7 - Compile all the non-marked brushes normally, then compile the new brushes, add them together
                            local PMN = Plots[MN,array]
                            local PDV = Plots[DV,array]
                            NumSegsMN = PMN:count()
                            NumSegsDV = PDV:count()
                            
                            MainSegmentOverlap = array()
                            DivSegmentOverlap = array()
                            
                            Jlap_MN = array()
                            Jmap_MN = array()
                            Jlap_DV = array()
                            Jmap_DV = array()
                            
                            OLID = 0
                            
                            JLC_MN = JointsLists[MN,table]["C",array]
                            JLD_MN = JointsLists[MN,table]["D",array]
                            JLC_DV = JointsLists[DV,table]["C",array]
                            JLD_DV = JointsLists[DV,table]["D",array]
                            
                            #Find MainLeft
                            local DirMN = vec2(PMN[PMN:count(),vector])-CardinalPoint
                            local DirDV = vec2(PDV[PDV:count(),vector])-CardinalPoint
                            local ThetaMN = angnorm(atan(DirMN:y(),DirMN:x()))
                            local ThetaDV = angnorm(atan(DirDV:y(),DirDV:x()))
                            
                            local ThetaDiff = angnorm(ThetaMN-ThetaDV)
                            
                            
                            SplitMode = SwitchSplit[TrackID,string]
                            
                            if(ThetaDiff==0){
                                cprint("ERROR: Can't resolve left/right-handededness of the switch! Both end points are collinear with start!")
                                vocalize("vo/engineer_autodejectedtie01.mp3")
                            }else{
                                SwitchMainLeft[TrackID,number] = MainLeft = ThetaDiff>0
                                #cprint("Main Path Goes: "+(MainLeft ? "Left. " : "Right. ")+"Checking Overlaps...")
                                
                                #swi - Switches
                                    #str_arc
                                        #ang0fw_0fw_1rt_r2048_1024x0000_1280x0096_mn (_dv)
                                    #str_bez
                                        #ang0fw_0fw_0fw_minr3072_2048x0000_2048x0192_mn (_dv)
                                    #arc_arc
                                        #ang0fw_ang1lt_ang1rt_r1536_r1536_1024x0096_1024x0096_mn (_dv)
                                    #arc_bez
                                        #(etc)
                                    #bez_bez
                                        #(etc)
                                    #xover
                                
                                if(AutoName){
                                    
                                    #Init
                                    local NewName = "trakpak3_"+GaugeName+"/switches/"
                                    
                                    #Categorize Combination
                                    if((TypeMN=="straight") & (TypeDV=="arc")){
                                        #switches/turnouts/r(Radius)/t(StartDir)_(EndDir)_(Curvature)_(Dims)
                                        NewName += "turnouts/r"+ArcRadius[DV,number]/Scale+"/t"
                                        
                                        #Directions
                                        if(StartDMN==0){
                                            NewName += "0fw_"
                                        }elseif(StartDMN>0){
                                            NewName += StartDMN+"lt_"
                                        }else{
                                            NewName += abs(StartDMN)+"rt_"
                                        }
                                        if(EndDDV==0){
                                            NewName += "0fw_"
                                        }elseif(EndDDV>0){
                                            NewName += EndDDV+"lt_"
                                        }else{
                                            NewName += abs(EndDDV)+"rt_"
                                        }
                                        
                                        #Curvature
                                        local Curvature = sign(EndDDV - StartDDV)
                                        NewName += (Curvature>0 ? "left" : "right")+"_"
                                        
                                    }elseif((TypeMN=="straight") & (TypeDV=="bezier")){ #Sidings, Xovers, and str_bez
                                        
                                        local Parallel = (StartDDV==EndDDV)
                                        local Xover = BezXovers[DV,number]
                                        if(Parallel & Xover){
                                            #switches/xovers/x(StartDir)_(Curvature)_minr(MinR)_(Dims)
                                            NewName += "xovers/x"
                                            
                                            #Directions
                                            if(StartDMN==0){
                                                NewName += "0fw_"
                                            }elseif(StartDMN>0){
                                                NewName += StartDMN+"lt_"
                                            }else{
                                                NewName += abs(StartDMN)+"rt_"
                                            }
                                            
                                            #Curvature
                                            local Curvature = sign(tp3dir(StartDMN):cross(EndPDV-StartPDV)) #+1 for left, -1 for right
                                            NewName += (Curvature>0 ? "left" : "right")+"_"
                                            
                                            #Radius
                                            local MinR = BezMinRadius[DV,number]:minsnap(array(0,512,1024,1536,2048,3072,4096,6144,8192,12288,16384))
                                            NewName += "minr"+pad4(MinR)+"_"
                                            
                                        }elseif(Parallel){
                                            #switches/sidings/p(StartDir)_(Curvature)_minr(MinR)_(Dims)
                                            NewName += "sidings/p"
                                            
                                            #Directions
                                            if(StartDMN==0){
                                                NewName += "0fw_"
                                            }elseif(StartDMN>0){
                                                NewName += StartDMN+"lt_"
                                            }else{
                                                NewName += abs(StartDMN)+"rt_"
                                            }
                                            
                                            #Curvature
                                            local Curvature = sign(tp3dir(StartDMN):cross(EndPDV-StartPDV)) #+1 for left, -1 for right
                                            NewName += (Curvature>0 ? "left" : "right")+"_"
                                            
                                            #Radius
                                            local MinR = BezMinRadius[DV,number]:minsnap(array(0,512,1024,1536,2048,3072,4096,6144,8192,12288,16384))
                                            NewName += "minr"+pad4(MinR)+"_"
                                            
                                        }else{
                                            #switches/str_bez/m(StartDir)_(EndDir)_(Curvature)_minr(MinR)_(Dims)
                                            NewName+="str_bez/m"
                                            
                                            #Directions
                                            if(StartDMN==0){
                                                NewName += "0fw_"
                                            }elseif(StartDMN>0){
                                                NewName += StartDMN+"lt_"
                                            }else{
                                                NewName += abs(StartDMN)+"rt_"
                                            }
                                            if(EndDDV==0){
                                                NewName += "0fw_"
                                            }elseif(EndDDV>0){
                                                NewName += EndDDV+"lt_"
                                            }else{
                                                NewName += abs(EndDDV)+"rt_"
                                            }
                                            
                                            #Curvature
                                            local Curvature = sign(tp3dir(StartDMN):cross(EndPDV-StartPDV)) #+1 for left, -1 for right
                                            NewName += (Curvature>0 ? "left" : "right")+"_"
                                            
                                            #Radius
                                            local MinR = BezMinRadius[DV,number]:minsnap(array(0,512,1024,1536,2048,3072,4096,6144,8192,12288,16384))
                                            NewName += "minr"+pad4(MinR)+"_"
                                        }
                                        
                                    }elseif((TypeMN=="arc") & (TypeDV=="arc")){ #Wyes and arc_arc
                                        if((ArcRadius[MN,number]==ArcRadius[DV,number]) & (StartDMN==0) & (EndDMN == -EndDDV)){
                                            #switches/wyes/w(StartDir)_(EndDirMN)_(EndDirDV)_r(Radius)_(Dims)
                                            NewName += "wyes/w"
                                            
                                            #Directions
                                            if(StartDMN==0){
                                                NewName += "0fw_" #it's always gonna be this one in this case
                                            }elseif(StartDMN>0){
                                                NewName += StartDMN+"lt_"
                                            }else{
                                                NewName += abs(StartDMN)+"rt_"
                                            }
                                            if(EndDMN==0){
                                                NewName += "0fw_"
                                            }elseif(EndDMN>0){
                                                NewName += EndDMN+"lt_"
                                            }else{
                                                NewName += abs(EndDMN)+"rt_"
                                            }
                                            if(EndDDV==0){
                                                NewName += "0fw_"
                                            }elseif(EndDDV>0){
                                                NewName += EndDDV+"lt_"
                                            }else{
                                                NewName += abs(EndDDV)+"rt_"
                                            }
                                            
                                            #Radius
                                            NewName += "r"+(ArcRadius[MN,number]/Scale)+"_"
                                        }else{
                                            #switches/arc_arc/m(StartDir)_(EndDirMN)_(EndDirDV)_r(RadiusMN)_r(RadiusDV)_(CurvatureMN)_(CurvatureDV)_(Dims)
                                            NewName += "arc_arc/m"
                                            
                                            #Directions
                                            if(StartDMN==0){
                                                NewName += "0fw_"
                                            }elseif(StartDMN>0){
                                                NewName += StartDMN+"lt_"
                                            }else{
                                                NewName += abs(StartDMN)+"rt_"
                                            }
                                            if(EndDMN==0){
                                                NewName += "0fw_"
                                            }elseif(EndDMN>0){
                                                NewName += EndDMN+"lt_"
                                            }else{
                                                NewName += abs(EndDMN)+"rt_"
                                            }
                                            if(EndDDV==0){
                                                NewName += "0fw_"
                                            }elseif(EndDDV>0){
                                                NewName += EndDDV+"lt_"
                                            }else{
                                                NewName += abs(EndDDV)+"rt_"
                                            }
                                            
                                            #Radius
                                            NewName += "r"+(ArcRadius[MN,number]/Scale)+"_r"+(ArcRadius[DV,number]/Scale)+"_"
                                            
                                            #Curvature
                                            NewName += (EndDMN>0 ? "left" : "right")+"_"+(EndDDV>0 ? "left" : "right")+"_"
                                            
                                        }
                                        
                                        
                                        
                                    }elseif((TypeMN=="arc") & (TypeDV=="bezier")){ #arc_bez
                                        #switches/arc_bez/m(StartDir)_(EndDirMN)_(EndDirDV)_r(RadiusMN)_minr(MinRDV)_(CurvatureMN)_(CurvatureDV)_(Dims)
                                        NewName += "arc_bez/m"
                                        #Directions
                                        if(StartDMN==0){
                                            NewName += "0fw_"
                                        }elseif(StartDMN>0){
                                            NewName += StartDMN+"lt_"
                                        }else{
                                            NewName += abs(StartDMN)+"rt_"
                                        }
                                        if(EndDMN==0){
                                            NewName += "0fw_"
                                        }elseif(EndDMN>0){
                                            NewName += EndDMN+"lt_"
                                        }else{
                                            NewName += abs(EndDMN)+"rt_"
                                        }
                                        if(EndDDV==0){
                                            NewName += "0fw_"
                                        }elseif(EndDDV>0){
                                            NewName += EndDDV+"lt_"
                                        }else{
                                            NewName += abs(EndDDV)+"rt_"
                                        }
                                        
                                        #Radius
                                        NewName += "r"+(ArcRadius[MN,number]/Scale)+"_"
                                        local MinR = BezMinRadius[DV,number]:minsnap(array(0,512,1024,1536,2048,3072,4096,6144,8192,12288,16384))
                                        NewName += "minr"+pad4(MinR)+"_"
                                        
                                        local CMN = sign(EndDMN-StartDMN)
                                        local CDV = sign(tp3dir(EndDDV):cross(EndPDV-StartPDV)) #+1 for left, -1 for right
                                        NewName += (CMN>0 ? "left" : "right")+"_"+(CDV>0 ? "left" : "right")+"_"
                                        
                                    }elseif((TypeMN=="bezier") & (TypeDV=="arc")){ #bez_arc
                                        #switches/bez_arc/m(StartDir)_(EndDirMN)_(EndDirDV)_minr(MinRMN)_r(RadiusDV)_(CurvatureMN)_(CurvatureDV)_(Dims)
                                        NewName += "bez_arc/m"
                                        
                                        #Directions
                                        if(StartDMN==0){
                                            NewName += "0fw_"
                                        }elseif(StartDMN>0){
                                            NewName += StartDMN+"lt_"
                                        }else{
                                            NewName += abs(StartDMN)+"rt_"
                                        }
                                        if(EndDMN==0){
                                            NewName += "0fw_"
                                        }elseif(EndDMN>0){
                                            NewName += EndDMN+"lt_"
                                        }else{
                                            NewName += abs(EndDMN)+"rt_"
                                        }
                                        if(EndDDV==0){
                                            NewName += "0fw_"
                                        }elseif(EndDDV>0){
                                            NewName += EndDDV+"lt_"
                                        }else{
                                            NewName += abs(EndDDV)+"rt_"
                                        }
                                        
                                        #Radius
                                        local MinR = BezMinRadius[MN,number]:minsnap(array(0,512,1024,1536,2048,3072,4096,6144,8192,12288,16384))
                                        NewName += "minr"+pad4(MinR)+"_"
                                        NewName += "r"+ArcRadius[DV,number]+"_"
                                        
                                        #Curvature
                                        local CDV = sign(EndDDV-StartDDV)
                                        local CMN = sign(tp3dir(EndDMN):cross(EndPMN-StartPMN)) #+1 for left, -1 for right
                                        NewName += (CMN>0 ? "left" : "right")+"_"+(CDV>0 ? "left" : "right")+"_"
                                        
                                    }elseif((TypeMN=="bezier") & (TypeDV=="bezier")){ #bez_bez
                                        #switches/bez_bez/m(StartDir)_(EndDirMN)_(EndDirDV)_minr(MinRMN)_minr(MinRDV)_(CurvatureMN)_(CurvatureDV)_(Dims)
                                        NewName += "bez_bez/m"
                                        
                                        #Directions
                                        if(StartDMN==0){
                                            NewName += "0fw_"
                                        }elseif(StartDMN>0){
                                            NewName += StartDMN+"lt_"
                                        }else{
                                            NewName += abs(StartDMN)+"rt_"
                                        }
                                        if(EndDMN==0){
                                            NewName += "0fw_"
                                        }elseif(EndDMN>0){
                                            NewName += EndDMN+"lt_"
                                        }else{
                                            NewName += abs(EndDMN)+"rt_"
                                        }
                                        if(EndDDV==0){
                                            NewName += "0fw_"
                                        }elseif(EndDDV>0){
                                            NewName += EndDDV+"lt_"
                                        }else{
                                            NewName += abs(EndDDV)+"rt_"
                                        }
                                        
                                        #Radius
                                        local MinR = BezMinRadius[MN,number]:minsnap(array(0,512,1024,1536,2048,3072,4096,6144,8192,12288,16384))
                                        NewName += "minr"+pad4(MinR)+"_"
                                        local MinR = BezMinRadius[DV,number]:minsnap(array(0,512,1024,1536,2048,3072,4096,6144,8192,12288,16384))
                                        NewName += "minr"+pad4(MinR)+"_"
                                        
                                        #Curvature
                                        local CMN = sign(tp3dir(EndDMN):cross(EndPMN-StartPMN)) #+1 for left, -1 for right
                                        local CDV = sign(tp3dir(EndDDV):cross(EndPDV-StartPDV)) #+1 for left, -1 for right
                                        NewName += (CMN>0 ? "left" : "right")+"_"+(CDV>0 ? "left" : "right")+"_"
                                        
                                    }
                                    
                                    #Dimensions
                                    local DF = pad4s(((EndPMN-StartPMN):y())/Scale)
                                    local DL = pad4s(((EndPMN-StartPMN):x())/Scale)
                                    NewName += DF+"x"+DL+"_"
                                    
                                    local DF = pad4s(((EndPDV-StartPDV):y())/Scale)
                                    local DL = pad4s(((EndPDV-StartPDV):x())/Scale)
                                    NewName += DF+"x"+DL
                                    
                                    #Double Rail Precision
                                    if(SMDQC & DoubleRailPrecision){NewName += "_drp"}
                                    
                                    #Rename
                                    timer(".rename "+TrackID+" "+NewName,50)
                                    
                                }
                                
                                timer("checkoverlap_mn",200)
                            }
                            
                            
                        }
                        
                        break
                }
            }else{
                jprint(" Track piece is not yet fully defined!")
            }
            
            
            hideChat(1)
            break
        case ".mirror",
            
            local TrackID = 0
            if(Sentence[2,string]==""){
                TrackID = SelectedTrack
            }else{
                TrackID = Sentence[2,string]:toNumber()
            }
            local Type = TrackTypes[TrackID,string]
            switch(Type){
                case "straight",
                    StraightStartPos[TrackID,vector2] = StraightStartPos[TrackID,vector2]*vec2(-1,1)
                    StraightDir[TrackID,number] = StraightDir[TrackID,number]*-1
                    timer(".plot "+TrackID,100)
                    break
                case "arc",
                    ArcStartPos[TrackID,vector2] = ArcStartPos[TrackID,vector2]*vec2(-1,1)
                    ArcEndPos[TrackID,vector2] = ArcEndPos[TrackID,vector2]*vec2(-1,1)
                    ArcStartDir[TrackID,number] = ArcStartDir[TrackID,number]*-1
                    ArcEndDir[TrackID,number] = ArcEndDir[TrackID,number]*-1
                    timer(".plot "+TrackID,100)
                    break
                case "banked_arc",
                    BankedArcStartPos[TrackID,vector2] = BankedArcStartPos[TrackID,vector2]*vec2(-1,1)
                    BankedArcEndPos[TrackID,vector2] = BankedArcEndPos[TrackID,vector2]*vec2(-1,1)
                    BankedArcStartDir[TrackID,number] = BankedArcStartDir[TrackID,number]*-1
                    BankedArcEndDir[TrackID,number] = BankedArcEndDir[TrackID,number]*-1
                    timer(".plot "+TrackID,100)
                    break
                case "bezier",
                    BezStartPos[TrackID,vector2] = BezStartPos[TrackID,vector2]*vec2(-1,1)
                    BezEndPos[TrackID,vector2] = BezEndPos[TrackID,vector2]*vec2(-1,1)
                    BezStartDir[TrackID,number] = BezStartDir[TrackID,number]*-1
                    BezEndDir[TrackID,number] = BezEndDir[TrackID,number]*-1
                    timer(".plot "+TrackID,100)
                    break
                case "switch",
                    local MN = SwitchMainPiece[TrackID,number]
                    local DV = SwitchDivPiece[TrackID,number]
                    timer(".mirror "+MN,100)
                    timer(".mirror "+DV,300)
                    break
                default,
                    
                    break
            }
            
            hideChat(1)
            break
            
        case ".vis",
            local TrackID = SelectedTrack
            if(Plotted[TrackID,number]){
                holoDeleteAll()
                timer("visualize",100)
            }else{
                jprint(" No Plot to visualize for this track piece!")
            }
            hideChat(1)
            break
        case ".marktightest",
            
            holoColor(TightestPoint,vec(255,0,255))
            
            hideChat(1)
            break
        case ".trackjoints",
            
            #          K M      N L
            #          G I      J H
            #       E----------------F
            #   /   |                |   \
            # A-----C----------------D-----B
            local TrackID = 0
            if(Sentence[2,string]==""){
                TrackID = SelectedTrack
            }else{
                TrackID = Sentence[2,string]:toNumber()
            }
            if(Plotted[TrackID,number]){
                local Points = Plots[TrackID,array]
                local Cnt = Points:count()
                
                local StartDir = 0
                local EndDir = 0
                
                local Type = TrackTypes[TrackID,string]
                switch(Type){
                    case "straight",
                        StartDir = StraightDir[TrackID,number]
                        EndDir = StartDir
                        break
                    case "arc",
                        StartDir = ArcStartDir[TrackID,number]
                        EndDir = ArcEndDir[TrackID,number]
                        break
                    case "banked_arc",
                        StartDir = BankedArcStartDir[TrackID,number]
                        EndDir = BankedArcEndDir[TrackID,number]
                        break
                    case "bezier",
                        StartDir = BezStartDir[TrackID,number]
                        EndDir = BezEndDir[TrackID,number]
                        break
                }
                
                local As = array()
                local Bs = array()
                local Cs = array()
                local Ds = array()
                local Es = array()
                local Fs = array()
                local Gs = array()
                local Hs = array()
                local Is = array()
                local Js = array()
                local Ks = array()
                local Ls = array()
                local Ms = array()
                local Ns = array()
                
                local Trace = Traces[TrackID,array]
                
                for(N=0,Points:count()){
                    local TraceVec = Trace[N,vector]
                    local JointsTable = table()
                    #print(TraceVec)
                    if(vec2(TraceVec)==vec2()){
                        JointsTable = getJointsByDN(Points[N,vector],TraceVec:z())
                    }else{
                        JointsTable = getJointsByDV(Points[N,vector],vec2(TraceVec))
                    }
                    As[N,vector] = JointsTable["A",vector]
                    Bs[N,vector] = JointsTable["B",vector]
                    Cs[N,vector] = JointsTable["C",vector]
                    Ds[N,vector] = JointsTable["D",vector]
                    Es[N,vector] = JointsTable["E",vector]
                    Fs[N,vector] = JointsTable["F",vector]
                    Gs[N,vector] = JointsTable["G",vector]
                    Hs[N,vector] = JointsTable["H",vector]
                    Is[N,vector] = JointsTable["I",vector]
                    Js[N,vector] = JointsTable["J",vector]
                    Ks[N,vector] = JointsTable["K",vector]
                    Ls[N,vector] = JointsTable["L",vector]
                    Ms[N,vector] = JointsTable["M",vector]
                    Ns[N,vector] = JointsTable["N",vector]
                }
                
                local JointsList = table()
                JointsList["A",array] = As
                JointsList["B",array] = Bs
                JointsList["C",array] = Cs
                JointsList["D",array] = Ds
                JointsList["E",array] = Es
                JointsList["F",array] = Fs
                JointsList["G",array] = Gs
                JointsList["H",array] = Hs
                JointsList["I",array] = Is
                JointsList["J",array] = Js
                JointsList["K",array] = Ks
                JointsList["L",array] = Ls
                JointsList["M",array] = Ms
                JointsList["N",array] = Ns
                #printTable(Ls)
                
                local PhysList = JointsList:clone()
                
                if(Type=="banked_arc"){ #Adjust for banking and copy over rail joints if necessary
                    JointsList:bankAdjust(BankedArcBlendIn[TrackID,vector2],BankedArcBlendOut[TrackID,vector2],BankHeight,BankedArcGoesLeft[TrackID,number]) #BlendIn BlendOut Height CurveLeft
                    #PhysList["G",array] = JointsList["G",array]
                    #PhysList["H",array] = JointsList["H",array]
                    #PhysList["I",array] = JointsList["I",array]
                    #PhysList["J",array] = JointsList["J",array]
                    PhysList["K",array] = JointsList["K",array]
                    PhysList["L",array] = JointsList["L",array]
                    PhysList["M",array] = JointsList["M",array]
                    PhysList["N",array] = JointsList["N",array]
                    
                }
                PhysJointsLists[TrackID,table] = PhysList
                JointsLists[TrackID,table] = JointsList
                
                
            }
            jprint(" Track Joints Written.")
            if(AutoVis){
                timer(".vis",100)
                if(TrackTypes[SelectedTrack,string]=="bezier"){
                    timer(".marktightest",200)
                }
            }
            if(AutoDraw){
                timer(".draw",500)
            }
            if(AutoCompile & (FinalCompileID==SelectedTrack)){
                timer(".select "+AutoCompileID,500)
                timer(".go",1000)
            }elseif(AutoVon){
                VonID++
                timer("loadvon",100)
            }
            hideChat(1)
            break
        case ".drawclear",
            RopeIndex = 0
            DrawAnchor:propDelete()
            jprint("Rope Drawings Cleared.")
            hideChat(1)
            break
        case ".draw",
            local TrackID = 0
            if(Sentence[2,string]==""){
                TrackID = SelectedTrack
            }else{
                TrackID = Sentence[2,string]:toNumber()
            }
            if(Plotted[TrackID,number]){
                if(RopeIndex==0){
                    RopeIndex = 1
                    DrawAnchor:propDelete()
                    
                    DrawAnchor = propSpawn("models/props_phx/construct/metal_plate1.mdl",E:pos(),E:angles(),1)
                    DrawAnchor:setAlpha(191)
                    weld(DrawAnchor,E)
                }
                DrawSeg = 1
                local DrawJL = JointsLists[TrackID,table]
                DA = DrawJL["A",array]
                DB = DrawJL["B",array]
                DC = DrawJL["C",array]
                DD = DrawJL["D",array]
                DE = DrawJL["E",array]
                DF = DrawJL["F",array]
                DG = DrawJL["G",array]
                DH = DrawJL["H",array]
                DI = DrawJL["I",array]
                DJ = DrawJL["J",array]
                DK = DrawJL["K",array]
                DL = DrawJL["L",array]
                DM = DrawJL["M",array]
                DN = DrawJL["N",array]
                
                
                jprint("Drawing Track using ropes...")
                timer("draw",100)
            }else{
                jprint("No plot data exists for this track piece!")
            }
            hideChat(1)
            break
        case ".planbrushes",
            if(!SMDQC){
                MasterString = initBlocks(array())
            }
            local Points = Plots[SelectedTrack,array]
            local Trace = Traces[SelectedTrack,array]
            local SegAssignments = array()
            local TotalSegments = Points:count()
            local Type = TrackTypes[SelectedTrack,string]
            
            local OnlyRails = (RidiculousTies==0) & (MakeBallast==0)
            
            for(N=1,TotalSegments){
                local SegType = 0
                
                local IsTransitionSeg = 0
                if(TrackTypes[SelectedTrack,string]=="banked_arc"){
                    local BlendIn = BankedArcBlendIn[SelectedTrack,vector2]
                    if((N>BlendIn:x()) & (N<=BlendIn:y())){
                        IsTransitionSeg = 1
                        #print("TS "+N)
                    }
                    
                    local BlendOut = BankedArcBlendOut[SelectedTrack,vector2]
                    if((N>TotalSegments-BlendOut:y()) & (N<=TotalSegments-BlendOut:x())){
                        IsTransitionSeg = 1
                        #print("TS "+N)
                    }
                }
                
                if(MakeBallast==2){ #Peaked Ballast Mode
                
                    if(IsTransitionSeg){
                        SegType = 3.5 #Tri Ballast, Tri Rails
                    }else{
                        local D1 = Trace[N-1,vector]
                        local D2 = Trace[N,vector]
                        
                        local Z1 = Points[N-1,vector]:z()
                        local Z2 = Points[N,vector]:z()
                        
                        if(D1==D2){ #Straight - Block Rails & Trapezoid Ballast
                            SegType = 0.5
                        }elseif(Z1==Z2){ #Flat Curve - Block Rails & Block Ballast
                            SegType = 1.5
                        }else{ #Curved Ramp - Tri Rails & Tri Ballast
                            SegType = 3.5
                        }
                    }
                }else{ #Trapezoidal/None Ballast Mode
                    if(IsTransitionSeg){
                        SegType = OnlyRails ? 3.25 : 3 #Tri Ballast, Tri Rails
                    }else{
                        local D1 = Trace[N-1,vector]
                        local D2 = Trace[N,vector]
                        
                        local Z1 = Points[N-1,vector]:z()
                        local Z2 = Points[N,vector]:z()
                        
                        if(D1==D2){ #Straight - Block Rails & Trapezoid Ballast
                            SegType = OnlyRails ? 0.25 : 0
                        }elseif(Z1==Z2){ #Flat Curve - Block Rails & Block Ballast
                            SegType = OnlyRails ? 0.25 : (Type=="banked_arc") ? 2 : 1
                        }else{ #Curved Ramp - Tri Rails & Tri Ballast
                            SegType = OnlyRails ? 3.25 : 3
                        }
                    }
                }
                #cprint(SegType:toString())
                SegAssignments[N,number] = SegType
            }
            #print(TotalSegments)
            #printTable(Points)
            #printTable(SegAssignments)
            
            local TC = array()
            if(TextureRailEnds){
                if(TotalSegments==1){
                    TC[1,number] = 3
                }else{
                    TC[1,number] = 1
                    TC[TotalSegments,number] = 2
                }
            }
            TexRailEnds[SelectedTrack,array] = TC
            
            SegTypeLists[SelectedTrack,array] = SegAssignments
            EntID = 1
            jprint(" Assigned Segment Codes.")
            if(1){
                timer(".makebrushes",100)
            }
            CompileStartTime = curtime()
            hideChat(1)
            break
        case ".planbrushes_sw",
            MainLeft = SwitchMainLeft[SelectedTrack,number]
            local VG1 = MainLeft ? "Main (Left)" : "Main (Right)"
            local VG2 = MainLeft ? "Diverging (Right)" : "Diverging (Left)"
            VisGroups = array(VG1,VG2)
            if(!SMDQC){
                MasterString = initBlocks(VisGroups)
            }
            #Assign Segment Codes:
            #3.5 for Tri Rail/Peaked Tri Ballast (Graded Curves)
            #3.25 for Tri Rails with Physics
            #1.5 for Block Rail/Peaked Tri Ballast (Flat Curves)
            #1 for Block Rail/Block Ballast (diverging paths after sewed ballast)
            #0.5 for Block Rail/Peaked Ballast (Straights only)
            #0.25 for Block Rails with physics
            #0 for Block Rail/Trapezoidal Ballast (diverging paths after sewed ballast)
            #-1 for Left Rail only (before initial divergence, and for the stock rails up to the frog segment if #4 or #5 does not apply)
            #-1.5 for Left Rail/Left PB Only
            #-1.75 for Left Rail / Full PB
            #-2 for Right rail only (same as -1)
            #-2.5 for Right Rail/Right PB Only
            #-2.75 for Right Rail / Full PB
            #-3 for both rails (stock rails before frog)
            #-4 for skip (make split-up rail brushes!)
            #-4.5 for Split-up rails, Full PB
            #-5 for true skip (used immediately before and after the StockToChop in certain cases)
            #-5.5 for Skip Rails, Full PB
            
            local SegAssignmentsMN = array()
            local SegAssignmentsDV = array()
            
            local MN = SwitchMainPiece[SelectedTrack,number]
            local DV = SwitchDivPiece[SelectedTrack,number]
            
            #NOTE: Rail1MN/Rail2DV go from the merge joint (StockToChop) to the "Root" (StockToChop-1), this effectively overrides the previous segment -> use mode 5
            #print("Rail1MN="+Rail1MN:count()+", Rail2MN="+Rail2MN:count()+", Rail3MN="+Rail3MN:count())
            #print("Rail1DV="+Rail1DV:count()+", Rail2DV="+Rail2DV:count()+", Rail3DV="+Rail3DV:count())
            local HasR1MN = Rail1MN:count()>0
            local HasR1DV = Rail1DV:count()>0
            
            if(MakeBallast==2){ #Peaked Ballast - Skips all the merging ballast code and uses only the standard piece code.
                for(N=1,NumSegsMN){
                    #Closure Index MN = the MN segment that converges with the DV Stock Index
                    #Stock Index MN = the MN segment that converges with the DV Closure Index
                    
                    local ST = 0
                    if(N==StockToChopMN){ #The chopped-up rail segment
                        ST = -4.5
                    }elseif(HasR1MN & (N==(StockToChopMN-1))){ #The one before the chopped-up segment if a patch is needed
                        ST = -5
                    }elseif(N==max(ClosureIndexMN,StockIndexMN)){ #No patch but the rail merges with something
                        ST = -5.5
                    }elseif(N<=RIMN){ #Before Frog
                        if(N<StockToChopMN){ #Before Chop
                            ST = MainLeft ? -1.5 : -2.5
                        }else{ #Between Chop and Frog
                            ST = MainLeft ? -1.75 : -2.75
                        }
                    }else{ #After Frog
                        ST = 1.5
                    }
                    SegAssignmentsMN[N,number] = ST
                }
                for(N=1,NumSegsDV){
                    local ST = 0
                    if(N==StockToChopDV){
                        if(SegAssignmentsDV[N-1,number] <= -5){ #Segment in danger of Z-fighting. Drop the near and near-1 E and F by a scale unit. Only do this on the DV side.
                            local JL = JointsLists[DV,table]
                            local Es = JL["E",array]
                            local Fs = JL["F",array]
                            Es[N,vector] = Es[N,vector] + vec(0,0,-2*Scale)
                            Fs[N,vector] = Fs[N,vector] + vec(0,0,-2*Scale)
                            Es[N-1,vector] = Es[N-1,vector] + vec(0,0,-2*Scale)
                            Fs[N-1,vector] = Fs[N-1,vector] + vec(0,0,-2*Scale)
                        }
                        ST = -4.5
                    }elseif(HasR1DV & (N==(StockToChopDV-1))){
                        ST = -5
                    }elseif(N==max(ClosureIndexDV,StockIndexDV)){
                        ST = -5.5
                    }elseif(N<=RIDV){
                        if(N<StockToChopDV){
                            ST = !MainLeft ? -1.5 : -2.5
                        }else{
                            ST = !MainLeft ? -1.75 : -2.75
                        }
                    }else{
                        ST = 1.5
                    }
                    SegAssignmentsDV[N,number] = ST
                }
            }else{ #Trapezoidal/No Ballast
                for(N=1,NumSegsMN){
                    #Closure Index MN = the MN segment that converges with the DV Stock Index
                    #Stock Index MN = the MN segment that converges with the DV Closure Index
                    
                    local ST = 0
                    if(N==StockToChopMN){
                        ST = -4
                    }elseif((N==max(ClosureIndexMN,StockIndexMN)) | (HasR1MN & (N==(StockToChopMN-1)))){
                        ST = -5
                    }elseif(N<=RIMN){
                        ST = MainLeft ? -1 : -2
                    }elseif(MainSegmentOverlap[N,number]){
                        ST = -3
                    }else{
                        ST = 0 #Redundant but whatever
                    }
                    SegAssignmentsMN[N,number] = ST
                }
                for(N=1,NumSegsDV){
                    
                    local ST = 0
                    if(N==StockToChopDV){
                        ST = -4
                    }elseif((N==max(ClosureIndexDV,StockIndexDV)) | (HasR1DV & (N==(StockToChopDV-1)))){
                        ST = -5
                    }elseif(N<=RIDV){
                        ST = !MainLeft ? -1 : -2
                    }elseif(DivSegmentOverlap[N,number]){
                        ST = -3
                    }else{
                        ST = 0 #Redundant but whatever
                    }
                    SegAssignmentsDV[N,number] = ST
                }

            }
            #print("Closure Index MN: "+ClosureIndexMN)
            #print("Closure Index DV: "+ClosureIndexDV)
            #print("Stock Index MN: "+StockIndexMN)
            #print("Stock Index DV: "+StockIndexDV)
            
            local TC = array()
            if(TextureRailEnds){
                if(NumSegsMN==1){
                    TC[1,number] = 3
                }else{
                    TC[1,number] = 1
                    local X = BezXovers[MN,number]
                    TC[X ? NumSegsMN/2 : NumSegsMN,number] = 2
                }
            }
            TexRailEnds[MN,array] = TC
            
            local TC = array()
            if(TextureRailEnds){
                if(NumSegsDV==1){
                    TC[1,number] = 3
                }else{
                    TC[1,number] = 1
                    local X = BezXovers[DV,number]
                    TC[X ? NumSegsDV/2 : NumSegsDV,number] = 2
                }
            }
            TexRailEnds[DV,array] = TC
            
            SegTypeLists[MN,array] = SegAssignmentsMN
            SegTypeLists[DV,array] = SegAssignmentsDV
            EntID = 1
            #print("MN:")
            #printTable(SegAssignmentsMN)
            #print("DV:")
            #printTable(SegAssignmentsDV)
            #print(StockToChopMN,StockToChopDV)
            jprint("Assigned Segment Codes.")
            if(1){
                timer(".makebrushes",100)
            }
            SwitchCompileStep = 1
            #0 for Not a Switch
            #1 for MN's MN normal
            #2 for MN's DV normal
            #3 for MN's Blended
            #4 for DV's MN normal
            #5 for DV's DV normal
            #6 for DV's Blended
            #7 for MN Phys MN
            #8 for MN Phys DV
            #9 for DV Phys MN
            #10 for DV Phys DV
            CompileStartTime = curtime()
            hideChat(1)
            break
        case ".makebrushes",
            PieceID = SelectedTrack
            local IsSwitch = TrackTypes[SelectedTrack,string]=="switch"
            if(IsSwitch){
                PieceID = ((SwitchCompileStep==1)|(SwitchCompileStep==4)|(SwitchCompileStep==7)|(SwitchCompileStep==9)) ? SwitchMainPiece[SelectedTrack,number] : SwitchDivPiece[SelectedTrack,number]
                SwitchXover = BezXovers[PieceID,number]
                if(SwitchXover){WholeSwitchXover = 1}
            }else{
                SwitchXover = 0
            }
            
            TexCodes = TexRailEnds[PieceID,array]
            #printTable(TexCodes)
            SegmentTypes = SegTypeLists[PieceID,array]
            #printTable(SegmentTypes)
            local JList = JointsLists[PieceID,table]
            
            JA = JList["A",array]
            JB = JList["B",array]
            JC = JList["C",array]
            JD = JList["D",array]
            JE = JList["E",array]
            JF = JList["F",array]
            JG = JList["G",array]
            JH = JList["H",array]
            JI = JList["I",array]
            JJ = JList["J",array]
            JK = JList["K",array]
            JL = JList["L",array]
            JM = JList["M",array]
            JN = JList["N",array]
            
            BrushWriteStep = 0 #0 = Initialize Segment, 1 = Build Brush, 3 = Finish
            InternalBrushID = (Sentence[2,string]=="phys") ? -1 : 1 #Positive number for making ref meshes, negative number for phys meshes
            if(IsSwitch){
                if(SwitchCompileStep==1){
                    SMD_Tag = "_mn_ref"
                    cprint("MN REF")
                }elseif(SwitchCompileStep==4){
                    SMD_Tag = "_dv_ref"
                    cprint("DV REF")
                }elseif(SwitchCompileStep==7){
                    SMD_Tag = "_mn_phys"
                    cprint("MN PHYS")
                }elseif(SwitchCompileStep==9){
                    SMD_Tag = "_dv_phys"
                    cprint("DV PHYS")
                }
            }else{
                if(InternalBrushID==-1){
                    SMD_Tag = "_phys"
                }else{
                    SMD_Tag = "_ref"
                }
            }
            SegID = 1 #+ ((SwitchCompileStep==1) ? NumOverlapsMN : (SwitchCompileStep==2) ? NumOverlapsDV : 0)
            if(SwitchCompileStep<=1){
                if(!SMDQC){
                    StartingBrushID = maxBrushID()
                    if(StartingBrushID==0){StartingBrushID = 1}
                }
                jprint("Building Reference Brushes"+(SwitchCompileStep==1 ? " (MN)" : "")+"...")
            }else{
                if(InternalBrushID>0){
                    jprint("Building Reference Brushes ("+(SwitchCompileStep==4 ? "MN" : "DV")+")...")
                }else{
                    jprint("Building Physics Brushes ("+((SwitchCompileStep==7)|(SwitchCompileStep==9) ? "MN" : "DV")+")...")
                }
            }
            
            #printTable(JA)
            if(SwitchCompileStep<=1){
                soundPlay(0,0,"player/taunt_bumpkins_banjo_music.wav")
                SoundIndex = 1
            }
            timer("makebrush",100)
            
            hideChat(1)
            break
        case ".brushdump",
            local Dump = ""
            for(N=1,maxBrushID()){
                Dump += BrushStrings[N,string]
            }
            fileWrite("brushdump.txt",Dump)
            jprint("Dumped Brushes to file.")
            hideChat(1)
            break
        case ".clearbrushes",
            BrushStrings:clearBrushes()
            jprint("Brushes Cleared.")
            hideChat(1)
            break
        case ".compile",
            EntID = 1
            CompileStep = 0 #Flag for continuing to next Entity. 0 = Initialize, 1 = Add Brush, 2 = Create Entity, 3 = Finish
            soundPlay(0,0,"player/taunt_bumpkins_banjo_music_fast.wav")
            timer("compile",100)
            
            hideChat(1)
            break
        case ".autodef",
            local TrackID = SelectedTrack
            local Type = TrackTypes[TrackID,string]
            if(Type=="bezier"){
                BezStartPos[TrackID,vector2] = vec2()
                BezEndPos[TrackID,vector2] = vec2(192,1024)
                BezStartDir[TrackID,number] = 0
                BezEndDir[TrackID,number] = 0
                BezStartCPLength[TrackID,number] = 512
                BezEndCPLength[TrackID,number] = 512
                BezHeight[TrackID,number] = 0
                BezSegments[TrackID,number] = 16
                
                BezStartPosDefined[TrackID,number] = 1
                BezStartDirDefined[TrackID,number] = 1
                BezEndPosDefined[TrackID,number] = 1
                BezEndDirDefined[TrackID,number] = 1
                BezStartCPLengthDefined[TrackID,number] = 1
                BezEndCPLengthDefined[TrackID,number] = 1
                BezHeightDefined[TrackID,number] = 1
                BezSegmentsDefined[TrackID,number] = 1
                FullyDefined[TrackID,number] = 1
                cprint("Bez Defined")
            }elseif(Type=="arc"){
                ArcStartPos[TrackID,vector2] = vec2()
                ArcEndPos[TrackID,vector2] = vec2(2048,2048)
                ArcStartDir[TrackID,number] = 0
                ArcEndDir[TrackID,number] = -8
                ArcRadius[TrackID,number] = 2048
                ArcHeight[TrackID,number] = 0
                ArcSegments[TrackID,number] = 16 
                
                ArcStartPosDefined[TrackID,number] = 1
                ArcEndPosDefined[TrackID,number] = 1
                ArcStartDirDefined[TrackID,number] = 1
                ArcEndDirDefined[TrackID,number] = 1
                ArcRadiusDefined[TrackID,number] = 1
                ArcHeightDefined[TrackID,number] = 1
                ArcSegmentsDefined[TrackID,number] = 1
                FullyDefined[TrackID,number] = 1
                
                
                cprint("Arc Defined")
            }elseif(Type=="straight"){
                StraightStartPos[TrackID,vector2] = vec2()
                StraightDir[TrackID,number] = 0
                StraightLength[TrackID,number] = 1536
                StraightHeight[TrackID,number] = 0
                StraightSegments[TrackID,number] = 4
                
                StraightStartPosDefined[TrackID,number] = 1
                StraightDirDefined[TrackID,number] = 1
                StraightLengthDefined[TrackID,number] = 1
                StraightHeightDefined[TrackID,number] = 1
                StraightSegmentsDefined[TrackID,number] = 1
                FullyDefined[TrackID,number] = 1
                
                cprint("Straight Defined")
            }elseif(Type=="switch"){
                SwitchMainPiece[TrackID,number] = 1
                SwitchDivPiece[TrackID,number] = 2
                SwitchSplit[TrackID,string] = "main"
                
                SwitchMainPieceDefined[TrackID,number] = 1
                SwitchDivPieceDefined[TrackID,number] = 1
                SwitchSplitDefined[TrackID,number] = 1
                FullyDefined[TrackID,number] = 1
                
                cprint("Switch Defined")
            }
            hideChat(1)
            break
        case ".stopscript",
            if(RunningScript){
                RunningScript = 0
                stoptimer("script")
            }
            hideChat(1)
            break
        case ".run",
        case ".runscript",
            if(!RunningScript){
                RunningScript = 1
                ScriptLine = 1
                #printColor(vec(255,255,0),"AAAA")
                soundPlay(0,0,"player/taunt_bumpkins_banjo_music.wav")
                soundPitch(0,75)
                timer("script",100)
            }
            
            
            hideChat(1)
            break
        case ".maketraceholos",
            holoCreate(1)
            holoModel(1,"cube")
            holoScale(1,vec(2,0.5,0.5))
            holoColor(1,vec(255,0,0))
            
            holoCreate(2)
            holoModel(2,"cube")
            holoScale(2,vec(0.5,2,0.5))
            holoColor(2,vec(255,255,0))
            
            holoCreate(3)
            holoModel(3,"cylinder")
            holoScale(3,vec(0.5,0.5,2))
            holoColor(3,vec(0,255,0))
            
            holoCreate(4)
            holoModel(4,"cylinder")
            holoScale(4,vec(0.5,0.5,2))
            holoColor(4,vec(0,0,255))
            
            TraceC = 0
            
            holoPos(1,E:toWorld(vec(Outer_MN[TraceC,vector2])))
            holoPos(2,E:toWorld(vec(Inner_MN[TraceC,vector2])))
            holoPos(3,E:toWorld(vec(Inner_DV[TraceC,vector2])))
            holoPos(4,E:toWorld(vec(Outer_DV[TraceC,vector2])))
            
            hideChat(1)
            break
        case ".go",
            
            if(TrackTypes[SelectedTrack,string]=="switch"){
                timer(".planbrushes_sw",100)
            }else{
                timer(".planbrushes",100)
            }
            vocalize("vo/engineer_cheers01.mp3")
            hideChat(1)
            break
        case ".debug",
            print("MN:")
            printTable(SegTypeLists[1,array])
            print("DV:")
            printTable(SegTypeLists[2,array])
            hideChat(1)
            break
        default,
            
            break
    }
}elseif(inputClk()){
    if(Active & !ActiveQ){
        ActiveQ = 1
        Driver = Pod:driver()
        runOnKeys(Driver,1)
    }elseif(!Active & ActiveQ){
        ActiveQ = 0
        runOnKeys(Driver,0)
    }
    if(~FileBuffer){
        BufferWrite = ->FileBuffer
        if(BufferWrite){
            jprint("File Buffer Connected.")
        }else{
            jprint("File Buffer Disconnected.")
        }
    }
    
}elseif(keyClk(Driver)){
    local W = Driver:keyPressed("W")
    local A = Driver:keyPressed("A")
    local S = Driver:keyPressed("S")
    local D = Driver:keyPressed("D")
    local Up = Driver:keyPressed("up") | Driver:keyPressed("rbracket")
    local Dn = Driver:keyPressed("down") | Driver:keyPressed("lbracket")
    local Mouse1 = Driver:keyPressed("mouse_left") | Driver:keyPressed("enter")
    local Mouse2 = Driver:keyPressed("mouse_right")
    local Space = Driver:keyPressed("space")
    
    if(W & !WQ){
        WQ = 1
        CS:pressW()
        timer("rept",RepeatDelay)
    }elseif(!W & WQ){
        WQ = 0
        stoptimer("rept")
    }
    if(S & !SQ){
        SQ = 1
        CS:pressS()
        timer("rept",RepeatDelay)
    }elseif(!S & SQ){
        SQ = 0
        stoptimer("rept")
    }
    if(A & !AQ){
        AQ = 1
        CS:pressA()
        timer("rept",RepeatDelay)
    }elseif(!A & AQ){
        AQ = 0
        stoptimer("rept")
    }
    if(D & !DQ){
        DQ = 1
        CS:pressD()
        timer("rept",RepeatDelay)
    }elseif(!D & DQ){
        DQ = 0
        stoptimer("rept")
    }
    if(Up & !UpQ){
        UpQ = 1
        CS:pressUp()
    }elseif(!Up & UpQ){
        UpQ = 0
    }
    if(Dn & !DnQ){
        DnQ = 1
        CS:pressDn()
    }elseif(!Dn & DnQ){
        DnQ = 0
    }
    if(Mouse1 & !M1Q){
        M1Q = 1
        CS:pressContinue()
    }elseif(!Mouse1 & M1Q){
        M1Q = 0
    }
    if(Mouse2 & !M2Q){
        M2Q = 1
        CS:pressBack()
    }elseif(!Mouse2 & M2Q){
        M2Q = 0
    }
    if(Space & !SpaceQ){
        SpaceQ = 1
        CS:pressSpace()
    }elseif(!Space & SpaceQ){
        SpaceQ = 0
    }
}elseif(clk("rept")){
    local W = Driver:keyPressed("W")
    local A = Driver:keyPressed("A")
    local S = Driver:keyPressed("S")
    local D = Driver:keyPressed("D")
    if(W){
        CS:pressW()
        timer("rept",RepeatPrd)
    }
    if(S){
        CS:pressS()
        timer("rept",RepeatPrd)
    }
    if(A){
        CS:pressA()
        timer("rept",RepeatPrd)
    }
    if(D){
        CS:pressD()
        timer("rept",RepeatPrd)
    }
}elseif(clk("updatemanifest")){
    fileWrite("johnhenry_saves/manifest.txt",vonEncode(Manifest))
    timer("reloadmanifest",1000)
}elseif(clk("loadcfg")){
    EGP_Datas = table()
    CS_Data = vonDecodeTable(fileRead())
    CS_Pieces = CS_Data:count()
    CS:genAll()
    timer("reloadmanifest",1000)
}elseif(clk("reloadmanifest")){
    fileLoad("johnhenry_saves/manifest.txt")
    if(!AutoSaving){
        CS:initPage(0)
    }
    AutoSaving = 0
}elseif(clk("FileTimeout")){
    signalSendDirect("push_file",FileBuffer)
    timer("FileTimeout",1000)
}elseif(signalClk("ack_file")){
    stoptimer("FileTimeout")
    FileExpecting = 0
}
